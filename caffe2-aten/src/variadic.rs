crate::ix!();

//-------------------------------------------[.cpp/pytorch/aten/src/ATen/core/Variadic.h]

/**
  | This class allows you to write variadic
  | functions which call a (possibly overloaded)
  | function on each argument, in order.
  |
  | This is most commonly used in autogenerated
  | code, where it is convenient to have a function
  | that can uniformly take arguments of different
  | types.
  |
  | If your arguments are homogenous consider using
  | a initializer_list instead.
  |
  | For examples of this in use, see
  | torch/csrc/utils/variadic.h
  |
  */
pub struct IterArgs<F> {

}

impl IterArgs<F> {

    #[inline] pub fn apply<Args>(&mut self) -> &mut F {
    
        todo!();
        /*
            return self();
        */
    }

    /**
      | NB: Use perfect forwarding here, otherwise
      | we'll make value copies of all arguments!
      |
      */
    #[inline] pub fn apply<T, Args>(&mut self, 
        arg:  T,
        args: Args) -> &mut F {
    
        todo!();
        /*
            self()(forward<T>(arg));
        if (self().short_circuit()) {
          return self();
        } else {
          return apply(forward<Args>(args)...);
        }
        */
    }

    /**
      | Here are some handy overloads which provide
      | sensible defaults for container-like
      | structures that one might be interested in
      | recursing into.
      |
      | You can enable them by adding:
      |
      |    using IterArgs<YourStructName>::operator()
      |
      | to your struct.
      |
      | These are not enabled by default because you
      | may be able to process these structures more
      | efficiently than handling them one-by-one.
      */
    pub fn invoke<T>(&mut self, args: &[T])  {
    
        todo!();
        /*
            for (const auto& arg : args) {
          self()(arg);
          if (self().short_circuit())
            return;
        }
        */
    }
    
    
    pub fn invoke<T>(&mut self, args: &TorchList<T>)  {
    
        todo!();
        /*
            for (const auto& arg : args) {
          self()(arg);
          if (self().short_circuit())
            return;
        }
        */
    }

    /**
      | NB: we need to specify vector manually as C++
      | won't do an implicit conversion to make
      | a template deduction go through.
      |
      */
    pub fn invoke<T>(&mut self, args: &Vec<T>)  {
    
        todo!();
        /*
            self()(ArrayRef<T>{args});
        */
    }
    
    pub fn short_circuit(&self) -> bool {
        
        todo!();
        /*
            return false;
        */
    }
    
    #[inline] pub fn self_(&mut self) -> &mut F {
        
        todo!();
        /*
            return *static_cast<F*>(this);
        */
    }
}
