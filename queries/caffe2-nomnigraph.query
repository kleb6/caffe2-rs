hello! could you please help me write a crate-description for the rust crate "caffe2-nomnigraph" containing the following symbols? not all of the symbols are defined in this crate, but they are used somehow (please do not explicitly list the symbols, or write anything other than a simple description.  no description header is necessary. however, please be descriptive without making too many assumptions):

A
Accepts
Arc
Attempts
B
C
Call
Criteria
D
DagMatching
DagMatchingMultiEdges
DagMatchingRandomLargeGraph
DataFlowTestGraph
DataFlowTestGraphCriteria
Default
EXPECT
FALSE
Failes
Fails
G
Graph
GraphType
HashMap
Have
Hello
Helper
Here
IsNodeMatch
IsSubtreeMatch
IsSubtreeMatchRealistic
IsSubtreeMatchRepeated
Le
Look
MatchGraph
MatchPredicate
Mutex
Node
NodeRef
NodeType
NomGraph
NonTerminal
Now
NumInputs
Option
Realistic
ReplaceGraphRealistic
Self
Simple
Special
String
SubgraphMatchResultType
SubgraphMatcher
TRUE
Test
TestGraph
TestGraphNodePrinter
TestMatchGraph
TestMatchPredicate
TestRandom
The
There
This
Tree
Use
\
above
actual
allowed
and
any
are
as
back
be
because
become
before
but
can
case
cases
child
children
clang
const
convertToDotString
converters
count
countMatch
create
createEdge
createNode
creating
criteria
dataB
dataC
dataF
dataI
dataInput
dataOut
dataflow
default
deleteNodes
diamond
edges
embed
embedded
emplace
excludeFromSubgraph
exepected
expected
expects
fail
false
flow
format
found
fuse
fused
fusedNode
getEdgesCount
getInEdges
getInNode
getMatchNodeMap
getMatchedSubgraph
getMutableNodes
getNodes
graph
graphs
have
in
index
input
into
invert
invertGraphTraversal
isMatch
isNodeMatch
isSubgraphMatch
just
k
kStarCount
label
labelMap
large
lazy
le
less
let
like
looks
make
map
match
matchDataI
matchOpB
matchOpBOutput
matchOpC
matchOpCInputs
matchOpCOutput
matchOpF
matchOpFOutput
matchOpG
matchResult
matches
matching
methods
move
n
new
nextInt
node
nodeIdx
nodeRef
nodes
nom
non
nonTerminal
not
numInputs
numNodes
numPatterns
number
off
one
only
opB
opC
opF
opFused
opG
opb
opc
opf
opg
or
out
output
overlap
pattern
patterns
predicate
printer
procedure
random
randomly
realistic
ref
repeated
repeatedly
replaceInEdges
replaceOutEdges
replaceSubgraph
reset
result
root
same
should
shows
simple
size
starCount
static
subgraph
subgraphs
subtree
tail
terminal
test
testGraph
testMatchPredicate
tests
than
that
then
there
thing
times
transformed
traversal
tree
type
unmatched
unwrap
use
v
verbose
visualize
we
which
while
will
with
wrong

A
C
Cycle
Data
EdgeRef
F
GenericOperator
Graph
GraphType
HashMap
Here
Invalid
NNEquality
NNKind
NeuralNetData
NeuralNetOperator
Node
NodeRef
NomGraph
Our
Self
String
TestClass
TestRandom
U
Very
\\l
\\n
arg
as
assert
b
bb
box
can
cast
cfg
const
convertToDotString
converters
create
createEdge
createNode
cycle
doesn
dot
dyn
edge
entry
equal
exit
false
file
generate
generator
getInEdges
getInstructions
getKind
getName
getOutEdges
getVersion
graph
hasOutput
have
head
inEdge
independent
instr
instruction
isa
label
labelMap
like
long
looks
map
n
new
next
nn
node
nom
number
op
os
ostringstream
outEdge
output
platform
printer
random
render
repr
sameKind
seed
shape
simple
str
tail
tensor
test
this
u
unsigned
unused
use
used
v
value
with

@brief
@note
@param
A
API
Adding
Adds
All
An
Any
Arg
Attempted
Be
Call
Check
Copy
Create
Creates
Creating
DEBUG
Data
Default
Delete
Deletes
Edge
EdgeRef
Effectively
EmptyEdgeData
Everything
First
Get
GraphType
HashSet
If
InEdges
Invalid
LinkedList
Move
NodeRef
NomGraph
NomNode
Note
Notifier
OutEdges
PRINT
Removes
Replace
Returns
Self
StorageType
Subgraph
SubgraphType
Subgraphs
Swap
Template
The
Then
There
They
This
U
Use
V
Validates
When
\brief
\n
\note
\p
\return
actually
add
addInEdge
addOutEdge
added
after
algorithms
all
an
and
another
any
are
arg
args
around
as
assert
assertion
back
base
basic
be
becomes
begin
being
below
break
but
call
can
caution
check
class
concerns
connected
const
constant
construction
contain
copy
could
count
create
createNode
createNodeInternal
created
cut
default
defines
delete
deleteEdge
deleteNode
deleted
deleters
dest
destEdges
destGraph
destNodes
directed
does
doesn
edge
edges
emplace
empty
end
entire
erase
example
exist
exists
exploited
fact
fail
false
file
find
first
flexible
forward
from
functions
generic
getEdgeIfExists
getEdges
getInEdges
getMutableEdges
getMutableNodes
getNodes
getOutEdges
given
graph
has
hasEdge
hasNode
have
head
held
helper
implementation
in
inEdge
inEdges
inherit
insert
instance
internal
invalid
isValid
isn
iter
its
known
list
matched
move
n
new
newNode
no
node
nodeRef
nodeRefs
nodes
not
note
notifier
nullptr
old
oldNode
only
or
out
outEdge
outEdges
output
owned
ownership
p\n
point
present
print
printf
rather
rectify
reference
referenced
references
refs
remove
removeEdge
removeEdgeInternal
removeInEdge
removeNode
removeOutEdge
removed
replace
replaceInEdges
replaceOutEdges
replaced
result
retains
rvalue
s
set
setHead
setInEdges
setOutEdges
setTail
sg
should
simple
simplify
simply
single
size
specified
splice
storage
stored
subgraph
supported
sure
swap
tail
technically
than
that
them
there
this
type
types
underlying
unsafe
use
used
usize
valid
validity
vectors
viewed
will
with
within

Basic
EXPECT
Graph
Match
createEdge
createNode
decltype
entry
exit
graph
m
match
n
nom
size
test

A
Anonymous
BBT
Basic
BasicBlock
BasicBlockRef
BasicBlockType
BasicBlocks
Because
Cannot
Control
ControlFlowGraph
ControlFlowGraphImpl
Deletes
Destructor
Drop
EdgeRef
G
Graph
GraphType
Hack
HashMap
Helper
Instruction
Must
Name
Named
Node
NodeDataType
NodeRef
NomGraph
Notifier
NotifierCallback
Program
Reserved
Self
String
Subgraph
SubgraphType
SubgraphType?
Subgraphs
TODO
Template
U
Value
\brief
\note
addNode
aggregated
already
an
analysis
anonymous
are
as
assert
b
back
base
basic
bb
bbNode
bbType
be
before
begin
block
blocks
callback
callbacks
can
cannot
case
cfg
class
come
control
count
create
createNode
dataflow
debugging
delete
deleteDestructorCallback
deleteInstruction
distance
drop
emplace
end
erase
execution
extracting
find
first
flow
from
function
functions
getMutableNodes
given
graph
has
hasInstruction
hasNode
help
holds
in
insert
instr
instruction
instructions
into
invoked
isa
labeled
like
misused
modified
move
must
n
name
named
need
new
newInstr
node
nodes
non
not
ordering
pair
parameter
pos
probably
push
refactor
reference
referenced
register
registerDestructorCallback
remove
removeNode
right
second
sg
simply
single
sizeof
something
static
stored
subgraph
that
this
token
tool
track
trackNode
trait
type
typename
untrack
untrackNode
untracked
use
used
using
we
well

?
@note
A
Arc
Callers
Check
Child
Continue
Create
Debug
EdgeRef
Expected
Fails
G
Graph
GraphType
HashMap
If
Make
Map
MatchGraph
MatchNodeMap
MatchPredicate
Matched
NodeRef
NomGraph
Note
Option
Otherwise
Predicate
ReplaceGraphOperation
Reuse
Self
String
Subgraph
SubgraphMatchResult
SubgraphMatchResultType
SubgraphType
SubgraphType?
TODO
The
There
This
Unmatched
Utility
We
abort
aborted
about
addEdge
addNode
algorithm
all
allow
and
any
are
around
as
attempt
base
based
be
because
been
before
break
but
callers
can
case
cases
certain
child
children
childrenCriteria
childrenCriteriaRef
consider
const
construct
contains
continue
convertToDotString
corresponding
count
countMatch
criteria
criteriaEdges
criteriaIdx
current
currentEdgeIdx
currently
dataflow
debug
debugMessage
debugString
default
deleting
do
documentation
does
doesn
doing
during
early
edge
edges
eliminate
emplace
empty
enabled
end
enough
entire
exclude
expected
expectedCount
failure
false
find
flag
follow
found
from
function
functional
getCount
getCriteria
getDebugString
getInEdges
getMatchNodeMap
getMatchedSubgraph
getMutableNodes
getOutEdges
given
graph
greedy
handle
has
hasNode
head
implementation
implies
important
improve
in
include
includeInSubgraph
included
including
incoming
indicates
intended
internal
interpretation
invert
invertGraphTraversal
isMatch
isNodeMatch
isNonTerminal
isStarCount
isSubgraphMatch
isSubgraphMatchInternal
isn
its
itself
kStarCount
lambda
let
like
longest
look
looking
make
map
match
matchNodeMap
matchPredicate
matchResult
matched
matchedNode
matchedNodeEntry
matchedNodes
matchedResult
matchedSubgraph
matches
matching
may
maybe
means
message
methods
move
msg
multiple
multiplicity
mutate
mutation
needs
new
next
nextNode
node
nodeRef
nodes
non
nonTerminal
not
notMatched
nullptr
numChildrenCriteria
numEdges
object
once
only
or
order
ordering
ostringstream
out
outgoing
own
ownSubgraph
owns
part
pass
passed
pattern
possible
predicate
previously
procedure
reachable
ref
regex
replace
replaceFunction
requirement
requires
responsible
result
returned
returns
right
root
rootCriteriaNode
rootCriteriaRef
rootNode
rooted
same
scanned
search
second
see
sequence
set
shared
should
shouldIncludeEdgeInSubgraph
shouldIncludeInSubgraph
size
specified
specifies
specify
star
still
str
subgraph
subgraphs
subsequent
sufficient
sure
tail
terminal
terminate
that
then
there
think
this
times
transform
transformation
traversal
type
typename
u
unlimited
unmatched
unwrap
up
use
useful
utilities
verify
want
we
whether
which
will
with
without
work
would

@brief
@return
A
Add
Although
An
Annotation
AnnotationKind
Annotations
Args
AveragePool
AveragePoolRelu
BatchNormalization
Box
Branch
Caffe
Cannot
ChannelShuffle
Clip
Commonly
Concat
ControlFlowGraph
Conv
ConvRelu
ConvTranspose
CopyFromOpenCL
CopyToOpenCL
Create
D
DEFINE
DFG
Data
DataType
Declare
Default
Derived
Discriminator
Export
FC
Flatten
Float
From
G
Generated
Generic
GenericOperator
Get
GivenTensorFill
GraphType
Half
HashSet
Instruction
Int
K
LLVM
Layout
MatchGraph
MatchPredicate
MaxPool
MaxPoolRelu
Mutable
NCHW
NHWC
NN
NNCFGraph
NNDataKind
NNGraph
NNKind
NNLayout
NNMatchGraph
NNMatchPredicate
NNModule
NNPhi
NNSubgraph
NOMNIGRAPH
Named
NeuralNetData
NeuralNetDataTrait
NeuralNetOperator
New
NewT
NodeHelper
NodeRef
NomGraph
NomTensor
Not
OldT
Op
OpNames
Opcode
Option
Phi
RTTI
Receive
Relu
Replace
Reshape
Returns
Same
Self
Send
Set
Simple
Softmax
String
Subgraph
SubgraphType
Sum
SumRelu
Tensor
The
This
U
Undefined
Unknown
Validate
Value
While
\brief
\p
about
add
additional
after
alias
all
allow
an
and
annotation
any
are
args
argument
as
assert
assumptions
attribute
automatically
avoid
b
back
base
be
being
break
but
can
case
cast
cause
check
class
classes
classof
clone
coalesce
compatible
const
constexpr
consume
consumer
consumers
contain
containing
contains
continue
control
convert
copy
count
create
createEdge
createNode
createUniqueDataNode
created
curr
d
dataFlow
default
define
delete
deleteNode
deleteNodes
deleteSubgraph
dependencies
determine
do
downcast
dyn
edges
emplace
encouraged
enum
enumerate
erase
export
external
extra
extraAnnotation
false
fed
filter
first
fix
flow
from
function
generic
getInputs
getKind
getMutableNodes
getName
getNodes
getOutputs
graph
graphs
h
has
have
helpers
how
ident
implementation
in
include
inheritedFrom
input
insert
insertOp
inserted
inserting
inside
into
isa
issues
iter
iterator
just
k
kind
layout
let
like
link
listed
m
macro
make
manipulation
match
may
move
much
multiple
must
mutableData
n
name
names
need
network
neural
new
newData
newNode
nn
nnOpPtr
nno
node
nodeIterator
nomnigraph
not
nullptr
old
op
opcode
operations
operator
ops
optional
or
order
out
output
outputs
outputted
pair
perhaps
phantomA
phantomB
place
pointer
predicate
producer
producers
ptr
ref
references
regardless
release
removeNode
replace
replaceNode
replaceSubgraph
represent
richer
rtti
rules
running
s
same
saved
second
seem
semantics
set
sg
single
size
specific
specifier
ss
static
str
stringstream
structure
style
subgraph
subtle
such
sure
switch
takes
tensor
that
them
there
these
they
this
trait
ty
type
typename
types
underlying
unique
unwrap
use
used
uses
using
valid
value
void
was
way
were
while
with
wrapper
you

All
Branch
Data
Default
Generic
Handles
Instruction
K
LLVM
Opcode
Phi
Return
Self
Terminator
TerminatorEnd
TerminatorStart
V
Value
ValueKind
\brief
base
basic
cast
classof
const
default
different
enum
execution
getKind
getOpcode
instructions
isTerminator
isa
k
kind
new
op
opcode
operations
range
set
style
terminator
types
usize
v
version

CF
CFGraph
CONT
FALSE
Finally
First
Get
HashSet
Malformed
NNCFGraph
NNGraph
NNMatchPredicate
NNModule
NNSubgraph
NOM
NeuralNetData
NeuralNetOperator
NodeRef
Now
OR
R
REQUIRE
RET
String
TODO
Tensor
This
U
Unknown
We
addInEdge
addOutEdge
algo
algorithm
all
an
and
any
argument
as
assert
back
bb
bbNode
be
because
begin
can
cannot
cf
cfTrackedNodes
coalesce
coalesceInsertedDataDependenciesHelper
const
consumer
consumers
contain
continue
controlFlow
copy
count
create
createAnonymousFunction
createEdge
createNode
currentBasicBlock
dataFlow
dependencies
dependency
dfNodes
do
does
edge
edges
emplace
end
excludeFromSubgraph
external
false
front
generic
getConsumers
getInEdges
getInputs
getInstructions
getMutableInstructions
getMutableNodes
getName
getNodes
getOutEdges
getOutputs
getProducer
getTrackedNodes
graph
has
hasConsumer
hasNode
hasProducer
have
head
helper
here
horrendously
improve
in
inEdge
inEdges
inefficient
input
insert
insertInstructionBefore
inserted
insertion
instr
instrsCopy
instructions
issues
iter
iterator
location
m
make
match
more
move
moveInstructionBefore
multiple
must
mutableData
mutate
n
name
new
newBbNode
newConsumer
newProducer
newSize
newTensorNode
nn
no
node
nodeConsumer
nodeConsumers
nodeOutput
nodeOutputs
nodeRef
nodes
nonTerminal
not
nullptr
old
oldConsumer
oldSize
oldTensorNode
only
out
outEdge
output
outputNode
outputs
passed
permutation
prevProducer
producer
producers
promote
pure
pushInstructionNode
rbegin
reconcile
ref
relationship
removeInEdge
removeOutEdge
rend
replace
repr
sccs
seen
set
setHead
setTail
simply
single
size
so
subgraph
tail
tarjans
tensor
tensorNode
that
this
track
tracked
types
unique
unordered
use
uses
usize
we
while
with
works

Cycle
DAG
EXPECT
GE
Graph
NodeRef
Random
Simple
Tarjans
TestClass
WithEdgeStorage
algorithm
back
createEdge
createGraph
createGraphWithCycle
createNode
emplace
graph
move
n
nodes
nom
rand
ri
sccs
size
tarjans
test

A
CYCLE
DFS
Each
G
Graph
GraphT
GraphType
HashMap
NodeRef
NodeRefT
OK
Result
Return
Self
TODO
This
TopoSort
TopoSortResult
TopoSortResultStatus
Topological
Visited
\brief
after
algorithm
all
and
are
as
back
been
begin
being
change
children
const
cycle
detected
dfs
edge
end
enum
false
find
from
function
getMutableNodes
getOutEdges
given
graph
has
head
ignore
in
infer
into
map
mark
more
new
newNode
newStatus
no
node
nodes
object
once
order
otherwise
outEdge
parameters
performs
processed
push
pushed
references
result
returns
reverse
sort
status
takes
than
this
topo
topological
type
unordered
use
using
visited
visiting
wrapper

APIs
EXPECT
FALSE
Fused
NNGraph
NNMatchGraph
NeuralNetGraph
NodeRef
Relu
ReplaceGraph
SubgraphMatchResultType
Sum
SumRelu
TRUE
Tensor
Test
\
blob
const
count
createEdge
createNode
deleteNodes
fusedNode
getInputs
getMatchNodeMap
getMatchedSubgraph
getNodes
getNodesCount
getProducer
graph
input
isMatch
isSubgraphMatch
make
matchExternalTensorNode
matchRelu
matchResult
matchRoot
matchSum
matchSumInput
matchSumOutput
matching
mg
move
nn
output
relu
reluOutput
renamed
renaming
replaceInEdges
replaceOutEdges
replaceSubgraph
setName
size
subgraph
sum
sumNode
sumOutput
sumRelu
test
unique

@brief
A
BFS
Cannot
Construct
Create
Find
G
Graph
GraphType
HashMap
HashSet
Helper
High
In
Induces
Invalid
M
Map
NodeRef
NomGraph
O
Option
Runs
SSA
Sanity
SubgraphType
This
We
\brief
addEdge
addNode
algorithm
all
allNodes
an
are
as
assert
back
begin
break
but
can
cannot
cases
check
child
connected
connecting
const
continue
create
createEdge
createNode
degenerate
delete
deleteEdge
description
determine
determing
does
dom
domFrontierMap
dominance
dominate
dominated
dominator
dominatorMap
dominatorTree
dominators
draw
edge
edges
efficient
empty
end
erase
exact
exist
find
finder
finding
from
front
frontier
frontiers
generated
getInEdges
getMutableNodes
getNodes
getOutEdges
given
graph
happen
has
hasNode
head
idom
idomMap
idomTree
ignored
immediate
immediateDominatorMap
implementations
in
inEdge
inEdges
induce
induceEdges
inedge
insert
insertion
iter
level
location
map
mapToTreeNode
more
move
n
never
newNode
newnode
nextPass
node
nodes
not
object
one
only
or
original
outEdge
parent
phi
please
predecessor
reachable
really
representation
restore
root
rootSCC
runner
scan
seen
set
sg
should
size
source
specify
starting
strictly
subgraph
tail
tarjans
temporarily
testNode
that
their
there
topologically
track
tree
typename
unordered
up
use
useful
variable
way
we
while
will

Add
AveragePool
AveragePoolRelu
BatchNormalization
ChannelShuffle
Clip
Concat
Conv
ConvRelu
ConvTranspose
CopyFromOpenCL
CopyToOpenCL
DEFINE
Declare
Default
Export
FC
Flatten
From
GivenTensorFill
MaxPool
MaxPoolRelu
NCHW
NHWC
NN
NNKind
NOMNIGRAPH
NeuralNetOperator
Option
RTTI
Receive
Relu
Reshape
Self
Send
Softmax
String
Sum
SumRelu
add
addAxis
average
averagePool
axis
axisW
base
broadcast
conv
default
destination
dilations
epsilon
false
from
getDilations
getGroup
getKernelShape
getPads
getStrides
group
isTest
kernel
kernelShape
let
max
maxPool
min
momentum
move
new
or
pads
pool
set
shape
source
spatial
strides
sum
test
unwrap
use
vec

ASSERT
CYCLE
Cycle
DAG
EXPECT
Graph
GraphT
LT
NomGraph
OK
Result
Simple
TRUE
TestClass
TopoSort
TopoSortT
algorithm
begin
createEdge
createTestNode
end
find
n
nodes
nom
res
size
status
test
topoSort
type
use

DominatorTree
EXPECT
Graph
InduceEdges
InduceEdgesCycle
Lec
NodeRef
SSA
Subgraph
SubgraphType
TRUE
Test
addNode
algorithm
b
c
checkMap
const
courses
createEdge
createGraph
createGraphWithCycle
createNode
cs
d
decltype
domFrontMap
dominanceFrontierMap
dominatorTree
edge
edu
entry
example
exit
first
getMutableEdges
getMutableNodes
graph
h
harvard
hasEdge
https
immediateDominatorMap
induceEdges
j
k
map
n
node
noderef
nom
page
pair
pdf
r
seas
second
set
sg
slides
sp
test
tree
unordered
using
www

AllMatch
As
Basic
BinaryMatch
EXPECT
EmptyGraph
Graph
NoMatch
NodeRef
RemovedMiddleNode
The
We
about
algorithm
all
as
back
binaryMatch
bit
case
count
createGraph
decltype
does
erase
exp
false
found
front
getMutableNodes
getNodes
getNodesCount
graph
interesting
match
matches
n
nodes
nom
not
part
predicate
set
should
size
such
test
that
this
those
v

Base
EqualityClass
EqualityClassDefault
First
G
GraphType
Match
MatchGraph
MatchNodeList
No
NodeEqualityDefault
NodeRef
Recurse
Self
SubgraphType
This
Try
U
accumulate
addNode
algorithm
anchor
and
as
b
back
bailout
best
both
candidate
candidateNode
case
could
current
currentSubgraph
defines
early
emplace
equal
file
front
getMutableNodes
getOutEdges
give
graph
head
here
in
list
match
matches
matching
matchingSubgraphs
n
new
node
nodes
nom
out
outEdge
recursive
recursiveMatch
result
size
sort
stack
subgraph
subgraphs
topoSort
topologically
type
typename
us
use
useful
utilities
we

@
@param
@return
Add
Append
Assumes
BFS
Convert
Converts
DOT
Data
DotGenerator
Draw
Edge
EdgePrinter
EdgeRef
Enqueue
Extract
Finalize
Find
G
Generate
Get
GraphT
GraphType
HashMap
In
Init
Input
LR\n
NOTE
No
Node
NodePrinter
NodeRef
Operator
Option
Output
Print
Prints
Self
String
SubgraphType
Touched
Track
\
\n
\nrankdir
acyclic
algorithm
and
annotate
are
as
assert
attr
attrib
attribute
back
child
cluster
clusters
const
continue
convert
convertStruct
count
createSubgraph
cur
d
default
digraph
doesn
dot
dotted
edge
edgePrinter
edges
emplace
extractor
first
from
front
generate
generateNode
getInEdges
getNodes
getOperatorDotString
getOperatorSubtreeDotString
getOutEdges
given
graph
hasEdge
head
hex
iff
in
incoming
input
inputInEdgeCt
into
its
label
labelMap
let
like
map
n
n\n
name
new
node
nodeDepthMap
nodePrinter
nodes
not
o
odd
op
opInEdge
operator
operators
ops
optional
or
order
ostringstream
output
parent
parentless
parents
parse
pop
preserved
prev
print
printer
ptr
push
queue
record
records
ref
refs
renders
s
second
sep
sg
shape
size
str
style
subgraph
subgraphs
subtree
support
tail
that
this
top
touched
type
typename
u
uint
unique
unordered
unwrap
use
w
while
with
workList
yet

@brief
Assumes
Data
Derived
Drop
If
Implements
It
LinkedList
NOM
Notifier
NotifierCallback
Notifies
OR
REQUIRE
Self
StorageType
These
This
\brief
`registerNotificationCallback`
accessors
all
an
are
as
back
be
begin
break
c
callback
callbackList
callbacks
cast
class
collapse
cond
cont
continue
curious
defines
delete
deleteCallback
derived
destructor
drop
dtor
dtorCallbacks
emplace
empty
enables
encoded
end
erase
export
expr
false
generic
gives
ident
in
information
into
line
list
listener
listeners
macro
move
negation
new
nom
not
notif
notifCallbacks
notification
notify
null
nullptr
only
or
partial
passes
passing
pattern
pointer
public
recursive
register
reinterpret
require
reset
ret
rules
single
specification
specified
state
then
this
thus
toDelete
type
u
update
used
useful
users
void
with
without
writing

@brief
@note
A
Add
Check
Constructor
EdgeRef
EdgeWrapper
EdgeWrapper?
Edges
Graph
GraphType
GraphWrapper
HasEdgeWrapper
Head
Helper
If
Index
InputGraph
LowLink
NodeRef
NodeWrapper
NomGraph
OnStack
SCC
See
Self
Stack
Subgraph
SubgraphType
Subgraphs
TODO
Tail
Tarjan
Tarjans
The
Thus
U
We
Wrap
WrappedGraph
WrappedInputGraph
WrappedSCCs
WrappedSubgraph
\brief
\bug
\p
\return
able
addEdge
addNode
algorithm
all
an
and
annotated
annotating
as
back
be
before
begin
but
components
composed
connect
connected
considered
const
contain
createEdge
createNode
datastructures
default
details
do
early
edge
edges
emplace
en
end
false
find
finding
form
found
from
function
generic
getEdges
getMutableEdges
getMutableNodes
getNodes
getOutEdges
graph
graphs
handle
head
here
how
https
implementation
in
include
included
index
infer
input
into
labels
later
link
low
map
min
move
mutableData
n
needed
new
newNode
node
nodes
not
org
original
our
outEdge
output
papers
parameters
phantomA
phantomB
pop
proper
recovering
recovery
reference
references
required
returned
reverse
root
s
sccNode
sccNodes
sccs
see
set
smarter
sorted
stack
strongly
subgraph
subgraphs
tail
tarjans
that
then
this
topologically
trait
type
typename
unordered
unwrap
unwrapSubgraph
up
use
used
valid
ve
w
want
way
we
while
wiki
wikipedia
will
with
within
works
wrap
wrapped
wrappedEdge
wrappedNode
wrappedS
wrappedSCC
wrappedSubgraph
wrapper
wraps

?
@brief
@yinghai
A
As
EdgeRef
F
Find
G
Graph
If
Invalid
Kahn
NodeRef
NomGraph
Only
Please
Subgraph
Swap
Tarjans
The
This
Topological
Topologically
U
add
addNode
algorithm
are
as
assert
back
based
begin
binary
boolean
clear
condition
continue
count
current
currently
cycle
detected
edgeSet
edges
emplace
en
end
erase
everything
exhausted
false
frontier
getInEdges
getMutableEdges
getMutableNodes
getOutEdges
graph
have
head
https
inEdge
initial
inspired
long
looking
m
main
match
matches
matching
n
nextFrontier
org
originally
outEdge
pop
s
set
should
size
sorted
sortedNodes
sorting
stillHasInEdge
store
subgraph
subgraphs
swappableCondition
there
type
typename
unordered
use
using
we
which
while
wiki
wikipedia
will
written

Back
Basic
Convert
Create
CreateNodeAndEdge
Current
DeleteEdge
DeleteNode
DotGenerator
EXPECT
FALSE
Full
G
Graph
HasNode
MoveSubgraph
Moves
NodeRef
NomGraph
ReplaceEdges
SubgraphType
TRUE
TestClass
TestGraph
TestNodePrinter
We
addEdge
addNode
address
addresses
and
as
because
check
clusters
compare
comparing
comparison
convertToDotRecordString
convertToDotString
converters
createEdge
createNode
createTestNode
delete
deleteEdge
deleteNode
digraph
doesn
dot
from
full
generator
getMutableEdges
getMutableNodes
graph
hasEdge
hasNode
id
includes
isValid
length
longer
move
moveEdge
moveNode
moveSubgraph
n
no
node
nodes
nom
not
once
original
output
pointer
prefix
replaceInEdges
replaceNode
replaceOutEdges
sanity
second
sg
should
single
size
stable
subgraph
swapNodes
switch
test
type
use
uses
with
