crate::ix!();

#[inline] pub fn decode<CodebookT, CodeT>(
    codebook:     &Tensor,
    codes:        &Tensor,
    decoded_grad: *const Tensor,
    output:       *mut Tensor,
    resize_only:  bool) 
{
    todo!();
    /*
        CAFFE_ENFORCE(codebook.IsType<CodebookT>());

      auto* cb_ptr = codebook.data<CodebookT>();
      int cb_size = codebook.numel();

      CAFFE_ENFORCE(codes.IsType<CodeT>());
      auto* code_ptr = codes.data<CodeT>();

      if (decoded_grad == nullptr) {
        // Forward pass: decode and store codebook values in output.
        output->ResizeLike(codes);
        auto* out_ptr = output->template mutable_data<CodebookT>();
        if (resizeOnly) {
          return;
        }

        int sz = output->numel();
        for (int i = 0; i < sz; i++) {
          DCHECK_LE(*code_ptr, cb_size);
          *out_ptr++ = cb_ptr[*code_ptr++];
        }
      } else {
        // Backward pass: decode and accumulate gradient w.r.t. codebook values.
        CAFFE_ENFORCE_EQ(codes.numel(), decoded_grad->numel());
        auto* gradient_ptr = decoded_grad->data<CodebookT>();
        auto* const gradient_end = gradient_ptr + decoded_grad->numel();

        CAFFE_ENFORCE_EQ(cb_size, output->numel());
        auto* out_ptr = output->template mutable_data<CodebookT>();
        while (gradient_ptr < gradient_end) {
          DCHECK_LE(*code_ptr, cb_size);
          out_ptr[*code_ptr++] += *gradient_ptr++;
        }
      }
    */
}

#[macro_export] macro_rules! REGISTER_DECODER {
    ($codebookType:ident, $codesType:ident) => {
        todo!();
        /*
        {                                                                    
            {TypeMeta::Id<codebookType>(), TypeMeta::Id<codesType>()},         
            [](const Tensor& codebook_,                                    
                const Tensor& codes_,                                       
                const Tensor* gradient_,                                    
                Tensor* outDecoded_,                                        
                bool resizeOnly_) {                                         
                Decode<codebookType, codesType>(                             
                    codebook_, codes_, gradient_, outDecoded_, resizeOnly_); 
            }                                                              
        }
        */
    }
}

#[inline] pub fn decode_general(
    codebook:     &Tensor,
    codes:        &Tensor,
    gradient:     *const Tensor,
    out_decoded:  *mut Tensor,
    resize_only:  bool)  
{
    todo!();
    /*
        const static std::map<
          std::pair<TypeIdentifier, TypeIdentifier>,
          std::function<void(
              const Tensor& codebook,
              const Tensor& codes,
              const Tensor* gradient,
              Tensor* outDecoded,
              bool resizeOnly)>>
          gDecoderMapper = {REGISTER_DECODER(float, uint8_t),
                            REGISTER_DECODER(float, uint16_t),
                            REGISTER_DECODER(float, int32_t)};

      gDecoderMapper.at({codebook.dtype().id(), codes.dtype().id()})(
          codebook, codes, gradient, outDecoded, resizeOnly);
    */
}

/**
  | Decode tensors based on given codebook,
  | 
  | The codebook is generated by model_quantize.py
  |
  */
#[derive(PartialEq,Eq)]
pub enum QuantDecodeRunTy {
  RUN_ALWAYS,
  RUN_ONCE,
}

pub struct QuantDecodeOp<const QuantDecodeRun: QuantDecodeRunTy> {
    //USE_OPERATOR_FUNCTIONS(CPUContext);
    storage: OperatorStorage,
    context: CPUContext,
    has_run: bool, // default = false
}

impl<const QuantDecodeRun: QuantDecodeRunTy> QuantDecodeOp<QuantDecodeRun> {
    
    pub fn new<Args>(args: Args) -> Self {
        todo!();
        /*
            : Operator<CPUContext>(std::forward<Args>(args)...)
        */
    }
    
    #[inline] pub fn run_on_device(&mut self) -> bool {
        
        todo!();
        /*
            CAFFE_ENFORCE_GT(InputSize(), 1);
        // first input is the codebook
        CAFFE_ENFORCE_EQ(InputSize(), OutputSize() + 1);

        const auto& codebook = Input(0);
        CAFFE_ENFORCE(codebook.template IsType<float>(), codebook.dtype().name());

        for (int i = 0; i < OutputSize(); i++) {
          auto& ci = Input(i + 1);
          auto* co = Output(i);

          DecodeGeneral(
              codebook,
              ci,
              nullptr,
              co,
              /*resizeOnly=*/QuantDecodeRun == QuantDecodeRunTy::RUN_ONCE &&
                  hasRun_);
        }
        hasRun_ = true;
        return true;
        */
    }
}


///---------------------------
#[test] fn quant_decode_gradient_op_example() {

    todo!();
    /*
    Input:
      codebook = [1.5, 2.5, 3.5]
      codes_0 = [0, 1, 1, 2]
      codes_1 = [2, 0, 0]


    Output:
      decoded_0 = [1.5, 2.5, 2.5, 3.5]
      decoded_1 = [3.5, 1.5, 1.5]
    */
}

/**
  | Decode inputs using codebook.
  | 
  | This is a general LUT operator that returns
  | tensors with values from codebook (input
  | 0) based on given indices in codes (input
  | 1 ~ n).
  |
  */
pub struct QuantDecodeGradientOp {
    //USE_OPERATOR_FUNCTIONS(CPUContext);
    storage: OperatorStorage,
    context: CPUContext,
}

num_outputs!{QuantDecodeGradient, 1}

num_inputs!{QuantDecodeGradient, 
    |input: i32| {
        input >= 3 && input % 2 == 1
    }
}

num_inputs_outputs!{QuantDecode, 
    |input: i32, output: i32| {
        input > 1 && output + 1 == input 
    }
}

inputs!{QuantDecode, 
    0 => ("codebook", "Codebook in 1d tensor (float)"),
    1 => ("codes_0", "Encoded codes 0 (uint8/uint16/int32)"),
    2 => ("codes_1", "Encoded codes 1 if existed (uint8/uint16/int32)"),
    3 => ("codes_n", "Encoded codes n if existed (uint8/uint16/int32)")
}

outputs!{QuantDecode, 
    0 => ("decoded_0", "Decoded tensor for codes_0 (float)"),
    1 => ("decoded_1", "Decoded tensor for codes_1 (float)"),
    2 => ("decoded_n", "Decoded tensor for codes_n (float)")
}

impl QuantDecodeGradientOp {
    
    pub fn new<Args>(args: Args) -> Self {
        todo!();
        /*
            : Operator<CPUContext>(std::forward<Args>(args)...)
        */
    }
    
    #[inline] pub fn run_on_device(&mut self) -> bool {
        
        todo!();
        /*
            // Inputs: 1 codebook, n tensors of codes, and n corresponding gradients.
        CAFFE_ENFORCE(InputSize() >= 3 && InputSize() % 2 == 1);
        const int num_code_tensors = (InputSize() - 1) / 2;
        CAFFE_ENFORCE_EQ(OutputSize(), 1);

        const auto& codebook = Input(0);
        CAFFE_ENFORCE(codebook.template IsType<float>(), codebook.dtype().name());

        auto* gradient = Output(0, codebook.sizes(), at::dtype<float>());
        auto* gradient_ptr = gradient->template mutable_data<float>();
        std::fill(gradient_ptr, gradient_ptr + gradient->numel(), 0);

        for (int i = 0; i < num_code_tensors; i++) {
          auto& codes_i = Input(i + 1);
          auto& output_gradient_i = Input(i + num_code_tensors + 1);
          DecodeGeneral(codebook, codes_i, &output_gradient_i, gradient, false);
        }
        return true;
        */
    }
}

register_cpu_operator!{QuantDecode, QuantDecodeOp<QuantDecodeRunTy::RUN_ALWAYS>}

register_cpu_gradient_operator!{QuantDecodeGradient, QuantDecodeGradientOp}

#[cfg(caffe2_use_mpscnn)]
register_cpu_operator!{ MPSCNNQuantDecode, QuantDecodeOp<QuantDecodeRunTy::RUN_ONCE>}

pub struct GetQuantDecodeGradient<'a> {

    base: GradientMakerStorage<'a>,
}

impl<'a> GetGradientDefs for GetQuantDecodeGradient<'a> {
    
    #[inline] fn get_gradient_defs(&mut self) -> Vec<OperatorDef> {
        
        todo!();
        /*
            CAFFE_ENFORCE_EQ(Def().input_size(), Def().output_size() + 1);
        vector<string> gradient_op_inputs;
        for (int i = 0; i < Def().input_size(); i++) {
          gradient_op_inputs.push_back(I(i));
        }
        for (int i = 0; i < Def().output_size(); i++) {
          gradient_op_inputs.push_back(GO(i));
        }
        return SingleGradientDef(
            "QuantDecodeGradient", "", gradient_op_inputs, vector<string>{GI(0)});
        */
    }
}

register_gradient!{QuantDecode, GetQuantDecodeGradient}
