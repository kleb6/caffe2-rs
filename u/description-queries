#!/usr/bin/env raku
use File::Find;
use Data::Dump::Tree;

my @crates = ".".IO.dir>>.grep({ /caffe2op*/ }).grep({ .so });

.say for @crates;

grammar MyTokens {
    rule TOP {
        .* <line> .*
    }

    proto rule line { * }

    rule line:sym<macro> { 
        ^^ <name> '!'
    }

    rule line:sym<decl>   { 
        <kw_pub>? <kw_tag> <name>
    }

    token kw_tag { <kw_struct> | <kw_type> | <kw_enum> | <kw_fn> }

    token name {
        <[A..Z a..z 0..9]>+
    }

    token kw_pub    { 'pub'    } 
    token kw_struct { 'struct' } 
    token kw_type   { 'type'   } 
    token kw_enum   { 'enum'   } 
    token kw_fn     { 'fn'     } 
}

class MyTokens::Actions {
    method TOP($/) {
        make $<line>.made
    }

    method line:sym<macro>($/) {
        make ~$<name>
    }

    method line:sym<decl>($/) {
        make ~$<name>
    }
}

sub extract-defs-from-text($text) {

    my @lines = $text.lines;

    gather for @lines {

        my $match = MyTokens.parse($_, actions => MyTokens::Actions.new);

        if so $match {
            take $match.made;
        }
    }
}

race for @crates -> $crate {

    my $outfile = "queries/$crate.query".IO;

    spurt $outfile, qq:to/END/;
    hello! 

    I am writing a rust crate called $crate. 

    It defines a mathematical operator used in DSP
    and machine learning computations.

    I would like you to help me write a rust crate
    description for it.

    Please write the description in the followin format:

    <short description tag used in the crate header>
    <double newline>
    <longer, in depth description and mathematical analysis>
    <END>

    Below are listed some tokens from this crate. 

    Please describe the mathematical ideas
    identified by this information alongside the
    relevant mathematical equations.

    thanks!

    please format your response in the Markdown file format.

    here are the tokens:
    END

    my $cargo-toml = "$crate/Cargo.toml";

    die "Cargo.toml DNE for crate: $crate" if not $cargo-toml.IO.e;

    my @sources = find(dir => "$crate/src/".IO).grep({ ! /lib/ }).grep({ ! /imports/ });

    for @sources -> $source {

        my $text = $source.IO.slurp;

        my @words = extract-defs-from-text($text).sort.unique.grep({ not /arg | new | input | output/ });

        for @words -> $word {
            spurt $outfile, "$word\n", :append;
        }
    }

    say "crate $crate -- done";
}

