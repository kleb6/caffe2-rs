// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `pytorch/caffe2/proto/prof_dag.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct TwoNumberStatsProto {
    // message fields
    mean: ::std::option::Option<f32>,
    stddev: ::std::option::Option<f32>,
    count: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TwoNumberStatsProto {
    fn default() -> &'a TwoNumberStatsProto {
        <TwoNumberStatsProto as ::protobuf::Message>::default_instance()
    }
}

impl TwoNumberStatsProto {
    pub fn new() -> TwoNumberStatsProto {
        ::std::default::Default::default()
    }

    // optional float mean = 1;


    pub fn get_mean(&self) -> f32 {
        self.mean.unwrap_or(0.)
    }
    pub fn clear_mean(&mut self) {
        self.mean = ::std::option::Option::None;
    }

    pub fn has_mean(&self) -> bool {
        self.mean.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean(&mut self, v: f32) {
        self.mean = ::std::option::Option::Some(v);
    }

    // optional float stddev = 2;


    pub fn get_stddev(&self) -> f32 {
        self.stddev.unwrap_or(0.)
    }
    pub fn clear_stddev(&mut self) {
        self.stddev = ::std::option::Option::None;
    }

    pub fn has_stddev(&self) -> bool {
        self.stddev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev(&mut self, v: f32) {
        self.stddev = ::std::option::Option::Some(v);
    }

    // optional int64 count = 3;


    pub fn get_count(&self) -> i64 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i64) {
        self.count = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TwoNumberStatsProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mean = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stddev = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.mean {
            my_size += 5;
        }
        if let Some(v) = self.stddev {
            my_size += 5;
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.mean {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.stddev {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TwoNumberStatsProto {
        TwoNumberStatsProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mean",
                |m: &TwoNumberStatsProto| { &m.mean },
                |m: &mut TwoNumberStatsProto| { &mut m.mean },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "stddev",
                |m: &TwoNumberStatsProto| { &m.stddev },
                |m: &mut TwoNumberStatsProto| { &mut m.stddev },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "count",
                |m: &TwoNumberStatsProto| { &m.count },
                |m: &mut TwoNumberStatsProto| { &mut m.count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TwoNumberStatsProto>(
                "TwoNumberStatsProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TwoNumberStatsProto {
        static instance: ::protobuf::rt::LazyV2<TwoNumberStatsProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TwoNumberStatsProto::new)
    }
}

impl ::protobuf::Clear for TwoNumberStatsProto {
    fn clear(&mut self) {
        self.mean = ::std::option::Option::None;
        self.stddev = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TwoNumberStatsProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TwoNumberStatsProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlobProfile {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub bytes_used: ::protobuf::SingularPtrField<TwoNumberStatsProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlobProfile {
    fn default() -> &'a BlobProfile {
        <BlobProfile as ::protobuf::Message>::default_instance()
    }
}

impl BlobProfile {
    pub fn new() -> BlobProfile {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .caffe2.TwoNumberStatsProto bytes_used = 3;


    pub fn get_bytes_used(&self) -> &TwoNumberStatsProto {
        self.bytes_used.as_ref().unwrap_or_else(|| <TwoNumberStatsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bytes_used(&mut self) {
        self.bytes_used.clear();
    }

    pub fn has_bytes_used(&self) -> bool {
        self.bytes_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bytes_used(&mut self, v: TwoNumberStatsProto) {
        self.bytes_used = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bytes_used(&mut self) -> &mut TwoNumberStatsProto {
        if self.bytes_used.is_none() {
            self.bytes_used.set_default();
        }
        self.bytes_used.as_mut().unwrap()
    }

    // Take field
    pub fn take_bytes_used(&mut self) -> TwoNumberStatsProto {
        self.bytes_used.take().unwrap_or_else(|| TwoNumberStatsProto::new())
    }
}

impl ::protobuf::Message for BlobProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.bytes_used {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bytes_used)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.bytes_used.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.bytes_used.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlobProfile {
        BlobProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BlobProfile| { &m.name },
                |m: &mut BlobProfile| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TwoNumberStatsProto>>(
                "bytes_used",
                |m: &BlobProfile| { &m.bytes_used },
                |m: &mut BlobProfile| { &mut m.bytes_used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlobProfile>(
                "BlobProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlobProfile {
        static instance: ::protobuf::rt::LazyV2<BlobProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlobProfile::new)
    }
}

impl ::protobuf::Clear for BlobProfile {
    fn clear(&mut self) {
        self.name.clear();
        self.bytes_used.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlobProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlobProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProfDAGProto {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    mean: ::std::option::Option<f32>,
    stddev: ::std::option::Option<f32>,
    pub execution_time: ::protobuf::SingularPtrField<TwoNumberStatsProto>,
    pub output_profile: ::protobuf::RepeatedField<BlobProfile>,
    pub extra_info: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfDAGProto {
    fn default() -> &'a ProfDAGProto {
        <ProfDAGProto as ::protobuf::Message>::default_instance()
    }
}

impl ProfDAGProto {
    pub fn new() -> ProfDAGProto {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required float mean = 2;


    pub fn get_mean(&self) -> f32 {
        self.mean.unwrap_or(0.)
    }
    pub fn clear_mean(&mut self) {
        self.mean = ::std::option::Option::None;
    }

    pub fn has_mean(&self) -> bool {
        self.mean.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean(&mut self, v: f32) {
        self.mean = ::std::option::Option::Some(v);
    }

    // required float stddev = 3;


    pub fn get_stddev(&self) -> f32 {
        self.stddev.unwrap_or(0.)
    }
    pub fn clear_stddev(&mut self) {
        self.stddev = ::std::option::Option::None;
    }

    pub fn has_stddev(&self) -> bool {
        self.stddev.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stddev(&mut self, v: f32) {
        self.stddev = ::std::option::Option::Some(v);
    }

    // optional .caffe2.TwoNumberStatsProto execution_time = 4;


    pub fn get_execution_time(&self) -> &TwoNumberStatsProto {
        self.execution_time.as_ref().unwrap_or_else(|| <TwoNumberStatsProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_execution_time(&mut self) {
        self.execution_time.clear();
    }

    pub fn has_execution_time(&self) -> bool {
        self.execution_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_time(&mut self, v: TwoNumberStatsProto) {
        self.execution_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_time(&mut self) -> &mut TwoNumberStatsProto {
        if self.execution_time.is_none() {
            self.execution_time.set_default();
        }
        self.execution_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_execution_time(&mut self) -> TwoNumberStatsProto {
        self.execution_time.take().unwrap_or_else(|| TwoNumberStatsProto::new())
    }

    // repeated .caffe2.BlobProfile output_profile = 5;


    pub fn get_output_profile(&self) -> &[BlobProfile] {
        &self.output_profile
    }
    pub fn clear_output_profile(&mut self) {
        self.output_profile.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_profile(&mut self, v: ::protobuf::RepeatedField<BlobProfile>) {
        self.output_profile = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_profile(&mut self) -> &mut ::protobuf::RepeatedField<BlobProfile> {
        &mut self.output_profile
    }

    // Take field
    pub fn take_output_profile(&mut self) -> ::protobuf::RepeatedField<BlobProfile> {
        ::std::mem::replace(&mut self.output_profile, ::protobuf::RepeatedField::new())
    }

    // repeated string extra_info = 7;


    pub fn get_extra_info(&self) -> &[::std::string::String] {
        &self.extra_info
    }
    pub fn clear_extra_info(&mut self) {
        self.extra_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_info(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.extra_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_info(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.extra_info
    }

    // Take field
    pub fn take_extra_info(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.extra_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProfDAGProto {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.mean.is_none() {
            return false;
        }
        if self.stddev.is_none() {
            return false;
        }
        for v in &self.execution_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_profile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mean = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.stddev = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execution_time)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.output_profile)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.extra_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.mean {
            my_size += 5;
        }
        if let Some(v) = self.stddev {
            my_size += 5;
        }
        if let Some(ref v) = self.execution_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.output_profile {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.extra_info {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.mean {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.stddev {
            os.write_float(3, v)?;
        }
        if let Some(ref v) = self.execution_time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.output_profile {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.extra_info {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfDAGProto {
        ProfDAGProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ProfDAGProto| { &m.name },
                |m: &mut ProfDAGProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mean",
                |m: &ProfDAGProto| { &m.mean },
                |m: &mut ProfDAGProto| { &mut m.mean },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "stddev",
                |m: &ProfDAGProto| { &m.stddev },
                |m: &mut ProfDAGProto| { &mut m.stddev },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TwoNumberStatsProto>>(
                "execution_time",
                |m: &ProfDAGProto| { &m.execution_time },
                |m: &mut ProfDAGProto| { &mut m.execution_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobProfile>>(
                "output_profile",
                |m: &ProfDAGProto| { &m.output_profile },
                |m: &mut ProfDAGProto| { &mut m.output_profile },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extra_info",
                |m: &ProfDAGProto| { &m.extra_info },
                |m: &mut ProfDAGProto| { &mut m.extra_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfDAGProto>(
                "ProfDAGProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfDAGProto {
        static instance: ::protobuf::rt::LazyV2<ProfDAGProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfDAGProto::new)
    }
}

impl ::protobuf::Clear for ProfDAGProto {
    fn clear(&mut self) {
        self.name.clear();
        self.mean = ::std::option::Option::None;
        self.stddev = ::std::option::Option::None;
        self.execution_time.clear();
        self.output_profile.clear();
        self.extra_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfDAGProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfDAGProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProfDAGProtos {
    // message fields
    pub stats: ::protobuf::RepeatedField<ProfDAGProto>,
    net_name: ::protobuf::SingularField<::std::string::String>,
    pub ops_stats: ::protobuf::RepeatedField<OpProfile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfDAGProtos {
    fn default() -> &'a ProfDAGProtos {
        <ProfDAGProtos as ::protobuf::Message>::default_instance()
    }
}

impl ProfDAGProtos {
    pub fn new() -> ProfDAGProtos {
        ::std::default::Default::default()
    }

    // repeated .caffe2.ProfDAGProto stats = 1;


    pub fn get_stats(&self) -> &[ProfDAGProto] {
        &self.stats
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: ::protobuf::RepeatedField<ProfDAGProto>) {
        self.stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats(&mut self) -> &mut ::protobuf::RepeatedField<ProfDAGProto> {
        &mut self.stats
    }

    // Take field
    pub fn take_stats(&mut self) -> ::protobuf::RepeatedField<ProfDAGProto> {
        ::std::mem::replace(&mut self.stats, ::protobuf::RepeatedField::new())
    }

    // optional string net_name = 2;


    pub fn get_net_name(&self) -> &str {
        match self.net_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_net_name(&mut self) {
        self.net_name.clear();
    }

    pub fn has_net_name(&self) -> bool {
        self.net_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_name(&mut self, v: ::std::string::String) {
        self.net_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_name(&mut self) -> &mut ::std::string::String {
        if self.net_name.is_none() {
            self.net_name.set_default();
        }
        self.net_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_name(&mut self) -> ::std::string::String {
        self.net_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .caffe2.OpProfile ops_stats = 3;


    pub fn get_ops_stats(&self) -> &[OpProfile] {
        &self.ops_stats
    }
    pub fn clear_ops_stats(&mut self) {
        self.ops_stats.clear();
    }

    // Param is passed by value, moved
    pub fn set_ops_stats(&mut self, v: ::protobuf::RepeatedField<OpProfile>) {
        self.ops_stats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ops_stats(&mut self) -> &mut ::protobuf::RepeatedField<OpProfile> {
        &mut self.ops_stats
    }

    // Take field
    pub fn take_ops_stats(&mut self) -> ::protobuf::RepeatedField<OpProfile> {
        ::std::mem::replace(&mut self.ops_stats, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProfDAGProtos {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ops_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.net_name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ops_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.net_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.ops_stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.stats {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.net_name.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.ops_stats {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfDAGProtos {
        ProfDAGProtos::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProfDAGProto>>(
                "stats",
                |m: &ProfDAGProtos| { &m.stats },
                |m: &mut ProfDAGProtos| { &mut m.stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "net_name",
                |m: &ProfDAGProtos| { &m.net_name },
                |m: &mut ProfDAGProtos| { &mut m.net_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpProfile>>(
                "ops_stats",
                |m: &ProfDAGProtos| { &m.ops_stats },
                |m: &mut ProfDAGProtos| { &mut m.ops_stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfDAGProtos>(
                "ProfDAGProtos",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfDAGProtos {
        static instance: ::protobuf::rt::LazyV2<ProfDAGProtos> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfDAGProtos::new)
    }
}

impl ::protobuf::Clear for ProfDAGProtos {
    fn clear(&mut self) {
        self.stats.clear();
        self.net_name.clear();
        self.ops_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfDAGProtos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfDAGProtos {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpProfile {
    // message fields
    idx: ::protobuf::SingularField<::std::string::String>,
    net_name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    exec_time_secs: ::std::option::Option<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpProfile {
    fn default() -> &'a OpProfile {
        <OpProfile as ::protobuf::Message>::default_instance()
    }
}

impl OpProfile {
    pub fn new() -> OpProfile {
        ::std::default::Default::default()
    }

    // optional string idx = 1;


    pub fn get_idx(&self) -> &str {
        match self.idx.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_idx(&mut self) {
        self.idx.clear();
    }

    pub fn has_idx(&self) -> bool {
        self.idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idx(&mut self, v: ::std::string::String) {
        self.idx = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_idx(&mut self) -> &mut ::std::string::String {
        if self.idx.is_none() {
            self.idx.set_default();
        }
        self.idx.as_mut().unwrap()
    }

    // Take field
    pub fn take_idx(&mut self) -> ::std::string::String {
        self.idx.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string net_name = 2;


    pub fn get_net_name(&self) -> &str {
        match self.net_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_net_name(&mut self) {
        self.net_name.clear();
    }

    pub fn has_net_name(&self) -> bool {
        self.net_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_name(&mut self, v: ::std::string::String) {
        self.net_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_name(&mut self) -> &mut ::std::string::String {
        if self.net_name.is_none() {
            self.net_name.set_default();
        }
        self.net_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_name(&mut self) -> ::std::string::String {
        self.net_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 3;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float exec_time_secs = 4;


    pub fn get_exec_time_secs(&self) -> f32 {
        self.exec_time_secs.unwrap_or(0.)
    }
    pub fn clear_exec_time_secs(&mut self) {
        self.exec_time_secs = ::std::option::Option::None;
    }

    pub fn has_exec_time_secs(&self) -> bool {
        self.exec_time_secs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_time_secs(&mut self, v: f32) {
        self.exec_time_secs = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OpProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.idx)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.net_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.exec_time_secs = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.idx.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.net_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.exec_time_secs {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.idx.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.net_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.exec_time_secs {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpProfile {
        OpProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "idx",
                |m: &OpProfile| { &m.idx },
                |m: &mut OpProfile| { &mut m.idx },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "net_name",
                |m: &OpProfile| { &m.net_name },
                |m: &mut OpProfile| { &mut m.net_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &OpProfile| { &m.field_type },
                |m: &mut OpProfile| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "exec_time_secs",
                |m: &OpProfile| { &m.exec_time_secs },
                |m: &mut OpProfile| { &mut m.exec_time_secs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpProfile>(
                "OpProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpProfile {
        static instance: ::protobuf::rt::LazyV2<OpProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpProfile::new)
    }
}

impl ::protobuf::Clear for OpProfile {
    fn clear(&mut self) {
        self.idx.clear();
        self.net_name.clear();
        self.field_type.clear();
        self.exec_time_secs = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n#pytorch/caffe2/proto/prof_dag.proto\x12\x06caffe2\"W\n\x13TwoNumberSt\
    atsProto\x12\x12\n\x04mean\x18\x01\x20\x01(\x02R\x04mean\x12\x16\n\x06st\
    ddev\x18\x02\x20\x01(\x02R\x06stddev\x12\x14\n\x05count\x18\x03\x20\x01(\
    \x03R\x05count\"]\n\x0bBlobProfile\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12:\n\nbytes_used\x18\x03\x20\x01(\x0b2\x1b.caffe2.TwoNumberSt\
    atsProtoR\tbytesUsed\"\xed\x01\n\x0cProfDAGProto\x12\x12\n\x04name\x18\
    \x01\x20\x02(\tR\x04name\x12\x12\n\x04mean\x18\x02\x20\x02(\x02R\x04mean\
    \x12\x16\n\x06stddev\x18\x03\x20\x02(\x02R\x06stddev\x12B\n\x0eexecution\
    _time\x18\x04\x20\x01(\x0b2\x1b.caffe2.TwoNumberStatsProtoR\rexecutionTi\
    me\x12:\n\x0eoutput_profile\x18\x05\x20\x03(\x0b2\x13.caffe2.BlobProfile\
    R\routputProfile\x12\x1d\n\nextra_info\x18\x07\x20\x03(\tR\textraInfo\"\
    \x86\x01\n\rProfDAGProtos\x12*\n\x05stats\x18\x01\x20\x03(\x0b2\x14.caff\
    e2.ProfDAGProtoR\x05stats\x12\x19\n\x08net_name\x18\x02\x20\x01(\tR\x07n\
    etName\x12.\n\tops_stats\x18\x03\x20\x03(\x0b2\x11.caffe2.OpProfileR\x08\
    opsStats\"r\n\tOpProfile\x12\x10\n\x03idx\x18\x01\x20\x01(\tR\x03idx\x12\
    \x19\n\x08net_name\x18\x02\x20\x01(\tR\x07netName\x12\x12\n\x04type\x18\
    \x03\x20\x01(\tR\x04type\x12$\n\x0eexec_time_secs\x18\x04\x20\x01(\x02R\
    \x0cexecTimeSecsJ\xc0\x15\n\x06\x12\x04\0\0D\x01\n\x08\n\x01\x0c\x12\x03\
    \0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\x0f\n\xc9\x04\n\x02\x04\0\x12\x04\
    \x0e\0\x12\x01\x1aD\x20A\x20two\x20number\x20summary\x20for\x20a\x20valu\
    e.\x20It\x20also\x20has\x20count\x20for\x20restoring.\n2\xf6\x03\x20A\
    \x20few\x20notes\x20about\x20the\x20Caffe2's\x20protobuffer\x20conventio\
    n:\n\x20(1)\x20Most\x20objects\x20are\x20registered\x20by\x20their\x20ty\
    pes,\x20such\x20as\x20operators\x20and\x20nets.\n\x20\x20\x20\x20\x20For\
    \x20these,\x20we\x20have\x20a\x20string-type\x20field\x20\"type\"\x20for\
    \x20registration\x20purposes.\n\x20(2)\x20We\x20do\x20not\x20use\x20exte\
    nsion\x20because\x20that\x20used\x20to\x20create\x20quite\x20some\x20con\
    flicts\n\x20\x20\x20\x20\x20in\x20Caffe's\x20protobuf\x20design.\n\x20(3\
    )\x20We\x20have\x20not\x20used\x20any\x20proto3\x20specific\x20features,\
    \x20such\x20as\x20Any\x20or\x20Map.\x20This\n\x20\x20\x20\x20\x20is\x20m\
    ainly\x20for\x20backward\x20compatibility\x20purposes\x20but\x20we\x20ma\
    y\x20consider\x20using\n\x20\x20\x20\x20\x20those\x20in\x20the\x20future\
    .\n\n\n\n\x03\x04\0\x01\x12\x03\x0e\x08\x1b\n\x0b\n\x04\x04\0\x02\0\x12\
    \x03\x0f\x02\x1a\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x0f\x02\n\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03\x0f\x0b\x10\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x0f\x11\x15\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x0f\x18\x19\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03\x10\x02\x1c\n\x0c\n\x05\x04\0\x02\x01\x04\x12\
    \x03\x10\x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x10\x0b\x10\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03\x10\x11\x17\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x10\x1a\x1b\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x11\x02\x1b\n\x0c\
    \n\x05\x04\0\x02\x02\x04\x12\x03\x11\x02\n\n\x0c\n\x05\x04\0\x02\x02\x05\
    \x12\x03\x11\x0b\x10\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x11\x11\x16\n\
    \x0c\n\x05\x04\0\x02\x02\x03\x12\x03\x11\x19\x1a\no\n\x02\x04\x01\x12\
    \x04\x16\0\x1c\x01\x1ac\x20Blob\x20profiling\x20information.\x20Profile\
    \x20for\x20a\x20blob\x20is\x20created\x20every\x20time\n\x20a\x20node\
    \x20outputs\x20to\x20the\x20blob.\n\n\n\n\x03\x04\x01\x01\x12\x03\x16\
    \x08\x13\nP\n\x04\x04\x01\x02\0\x12\x03\x18\x02\x1b\x1a7\x20Name\x20of\
    \x20the\x20blob\x20(corresponds\x20to\x20OperatorDef.output).\n\"\n\x20r\
    equired\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x18\x02\n\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03\x18\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03\x18\x12\x16\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x18\x19\x1a\n$\n\
    \x04\x04\x01\x02\x01\x12\x03\x1b\x02.\x1a\x17\x20Profiling\x20statistics\
    .\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x1b\x02\n\n\x0c\n\x05\x04\
    \x01\x02\x01\x06\x12\x03\x1b\x0b\x1e\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\
    \x03\x1b\x1f)\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03\x1b,-\n9\n\x02\x04\
    \x02\x12\x04\x1f\00\x01\x1a-\x20Protobuf\x20format\x20to\x20serialize\
    \x20profiler\x20data.\n\n\n\n\x03\x04\x02\x01\x12\x03\x1f\x08\x14\n(\n\
    \x04\x04\x02\x02\0\x12\x03!\x02\x1b\x1a\x1b\x20The\x20name\x20for\x20the\
    \x20operator\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03!\x02\n\n\x0c\n\x05\
    \x04\x02\x02\0\x05\x12\x03!\x0b\x11\n\x0c\n\x05\x04\x02\x02\0\x01\x12\
    \x03!\x12\x16\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03!\x19\x1a\n&\n\x04\
    \x04\x02\x02\x01\x12\x03#\x02\x1a\x1a\x19\x20The\x20mean\x20execution\
    \x20time\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03#\x02\n\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03#\x0b\x10\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03#\x11\x15\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03#\x18\x19\n%\n\
    \x04\x04\x02\x02\x02\x12\x03%\x02\x1c\x1a\x18\x20The\x20standard\x20devi\
    ation\n\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03%\x02\n\n\x0c\n\x05\x04\
    \x02\x02\x02\x05\x12\x03%\x0b\x10\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\
    \x03%\x11\x17\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03%\x1a\x1b\nH\n\x04\
    \x04\x02\x02\x03\x12\x03(\x022\x1a;\x20New\x20field\x20to\x20represent\
    \x20the\x20numbers\x20above,\x20and\x20with\x20count.\n\n\x0c\n\x05\x04\
    \x02\x02\x03\x04\x12\x03(\x02\n\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03(\
    \x0b\x1e\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03(\x1f-\n\x0c\n\x05\x04\
    \x02\x02\x03\x03\x12\x03(01\n4\n\x04\x04\x02\x02\x04\x12\x03+\x02*\x1a'\
    \x20Blob\x20profiles\x20that\x20this\x20node\x20outputs.\n\n\x0c\n\x05\
    \x04\x02\x02\x04\x04\x12\x03+\x02\n\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\
    \x03+\x0b\x16\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03+\x17%\n\x0c\n\x05\
    \x04\x02\x02\x04\x03\x12\x03+()\n>\n\x04\x04\x02\x02\x05\x12\x03.\x02!\
    \x1a1\x20The\x20extra_info\x20from\x20the\x20operator\x20device\x20optio\
    n.\n\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03.\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x05\x05\x12\x03.\x0b\x11\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03.\
    \x12\x1c\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03.\x1f\x20\n\x8c\x02\n\
    \x02\x04\x03\x12\x048\0<\x01\x1a\xff\x01\x20Operator\x20profiling\x20inf\
    ormation.\n\n\x20Note:\x20The\x20indices\x20for\x20elements\x20of\x20'st\
    ats'\x20and\x20the\x20indices\x20of\n\x20'output_profile'\x20inside\x20e\
    ach\x20'stats'\x20are\x20assumed\x20to\x20match\x20the\n\x20indices\x20o\
    f\x20'op'\x20elements\x20of\x20a\x20corresponding\x20NetDef\x20and\x20th\
    e\x20'output'\n\x20indices\x20within\x20each\x20'op'.\n\n\n\n\x03\x04\
    \x03\x01\x12\x038\x08\x15\n\x0b\n\x04\x04\x03\x02\0\x12\x039\x02\"\n\x0c\
    \n\x05\x04\x03\x02\0\x04\x12\x039\x02\n\n\x0c\n\x05\x04\x03\x02\0\x06\
    \x12\x039\x0b\x17\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x039\x18\x1d\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x039\x20!\n\x0b\n\x04\x04\x03\x02\x01\x12\x03\
    :\x02\x1f\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x03:\x02\n\n\x0c\n\x05\x04\
    \x03\x02\x01\x05\x12\x03:\x0b\x11\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\
    \x03:\x12\x1a\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03:\x1d\x1e\n\x0b\n\
    \x04\x04\x03\x02\x02\x12\x03;\x02#\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\
    \x03;\x02\n\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03;\x0b\x14\n\x0c\n\x05\
    \x04\x03\x02\x02\x01\x12\x03;\x15\x1e\n\x0c\n\x05\x04\x03\x02\x02\x03\
    \x12\x03;!\"\n<\n\x02\x04\x04\x12\x04?\0D\x01\x1a0\x20Represents\x20spec\
    ification\x20of\x20an\x20operation\x20cost.\n\n\n\n\x03\x04\x04\x01\x12\
    \x03?\x08\x11\n\x0b\n\x04\x04\x04\x02\0\x12\x03@\x02\x1a\n\x0c\n\x05\x04\
    \x04\x02\0\x04\x12\x03@\x02\n\n\x0c\n\x05\x04\x04\x02\0\x05\x12\x03@\x0b\
    \x11\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03@\x12\x15\n\x0c\n\x05\x04\x04\
    \x02\0\x03\x12\x03@\x18\x19\n\x0b\n\x04\x04\x04\x02\x01\x12\x03A\x02\x1f\
    \n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03A\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x01\x05\x12\x03A\x0b\x11\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03A\x12\
    \x1a\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03A\x1d\x1e\n\x0b\n\x04\x04\
    \x04\x02\x02\x12\x03B\x02\x1b\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03B\
    \x02\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03B\x0b\x11\n\x0c\n\x05\x04\
    \x04\x02\x02\x01\x12\x03B\x12\x16\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\
    \x03B\x19\x1a\n\x0b\n\x04\x04\x04\x02\x03\x12\x03C\x02$\n\x0c\n\x05\x04\
    \x04\x02\x03\x04\x12\x03C\x02\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03C\
    \x0b\x10\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03C\x11\x1f\n\x0c\n\x05\
    \x04\x04\x02\x03\x03\x12\x03C\"#\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
