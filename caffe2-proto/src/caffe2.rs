// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `pytorch/caffe2/proto/caffe2.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct TensorProto {
    // message fields
    pub dims: ::std::vec::Vec<i64>,
    data_type: ::std::option::Option<TensorProto_DataType>,
    data_format: ::std::option::Option<u32>,
    pub float_data: ::std::vec::Vec<f32>,
    pub int32_data: ::std::vec::Vec<i32>,
    byte_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub string_data: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub double_data: ::std::vec::Vec<f64>,
    pub int64_data: ::std::vec::Vec<i64>,
    raw_data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub device_detail: ::protobuf::SingularPtrField<DeviceOption>,
    pub segment: ::protobuf::SingularPtrField<TensorProto_Segment>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorProto {
    fn default() -> &'a TensorProto {
        <TensorProto as ::protobuf::Message>::default_instance()
    }
}

impl TensorProto {
    pub fn new() -> TensorProto {
        ::std::default::Default::default()
    }

    // repeated int64 dims = 1;


    pub fn get_dims(&self) -> &[i64] {
        &self.dims
    }
    pub fn clear_dims(&mut self) {
        self.dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dims
    }

    // Take field
    pub fn take_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dims, ::std::vec::Vec::new())
    }

    // optional .caffe2.TensorProto.DataType data_type = 2;


    pub fn get_data_type(&self) -> TensorProto_DataType {
        self.data_type.unwrap_or(TensorProto_DataType::FLOAT)
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: TensorProto_DataType) {
        self.data_type = ::std::option::Option::Some(v);
    }

    // optional uint32 data_format = 15;


    pub fn get_data_format(&self) -> u32 {
        self.data_format.unwrap_or(0u32)
    }
    pub fn clear_data_format(&mut self) {
        self.data_format = ::std::option::Option::None;
    }

    pub fn has_data_format(&self) -> bool {
        self.data_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_format(&mut self, v: u32) {
        self.data_format = ::std::option::Option::Some(v);
    }

    // repeated float float_data = 3;


    pub fn get_float_data(&self) -> &[f32] {
        &self.float_data
    }
    pub fn clear_float_data(&mut self) {
        self.float_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_float_data(&mut self, v: ::std::vec::Vec<f32>) {
        self.float_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_float_data(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.float_data
    }

    // Take field
    pub fn take_float_data(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.float_data, ::std::vec::Vec::new())
    }

    // repeated int32 int32_data = 4;


    pub fn get_int32_data(&self) -> &[i32] {
        &self.int32_data
    }
    pub fn clear_int32_data(&mut self) {
        self.int32_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_int32_data(&mut self, v: ::std::vec::Vec<i32>) {
        self.int32_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int32_data(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.int32_data
    }

    // Take field
    pub fn take_int32_data(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.int32_data, ::std::vec::Vec::new())
    }

    // optional bytes byte_data = 5;


    pub fn get_byte_data(&self) -> &[u8] {
        match self.byte_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_byte_data(&mut self) {
        self.byte_data.clear();
    }

    pub fn has_byte_data(&self) -> bool {
        self.byte_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_byte_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.byte_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_byte_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.byte_data.is_none() {
            self.byte_data.set_default();
        }
        self.byte_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_byte_data(&mut self) -> ::std::vec::Vec<u8> {
        self.byte_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // repeated bytes string_data = 6;


    pub fn get_string_data(&self) -> &[::std::vec::Vec<u8>] {
        &self.string_data
    }
    pub fn clear_string_data(&mut self) {
        self.string_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_string_data(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.string_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_string_data(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.string_data
    }

    // Take field
    pub fn take_string_data(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.string_data, ::protobuf::RepeatedField::new())
    }

    // repeated double double_data = 9;


    pub fn get_double_data(&self) -> &[f64] {
        &self.double_data
    }
    pub fn clear_double_data(&mut self) {
        self.double_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_double_data(&mut self, v: ::std::vec::Vec<f64>) {
        self.double_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_double_data(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.double_data
    }

    // Take field
    pub fn take_double_data(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.double_data, ::std::vec::Vec::new())
    }

    // repeated int64 int64_data = 10;


    pub fn get_int64_data(&self) -> &[i64] {
        &self.int64_data
    }
    pub fn clear_int64_data(&mut self) {
        self.int64_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_int64_data(&mut self, v: ::std::vec::Vec<i64>) {
        self.int64_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int64_data(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.int64_data
    }

    // Take field
    pub fn take_int64_data(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.int64_data, ::std::vec::Vec::new())
    }

    // optional bytes raw_data = 13;


    pub fn get_raw_data(&self) -> &[u8] {
        match self.raw_data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_raw_data(&mut self) {
        self.raw_data.clear();
    }

    pub fn has_raw_data(&self) -> bool {
        self.raw_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.raw_data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_raw_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.raw_data.is_none() {
            self.raw_data.set_default();
        }
        self.raw_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_raw_data(&mut self) -> ::std::vec::Vec<u8> {
        self.raw_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string name = 7;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .caffe2.DeviceOption device_detail = 8;


    pub fn get_device_detail(&self) -> &DeviceOption {
        self.device_detail.as_ref().unwrap_or_else(|| <DeviceOption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device_detail(&mut self) {
        self.device_detail.clear();
    }

    pub fn has_device_detail(&self) -> bool {
        self.device_detail.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_detail(&mut self, v: DeviceOption) {
        self.device_detail = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_detail(&mut self) -> &mut DeviceOption {
        if self.device_detail.is_none() {
            self.device_detail.set_default();
        }
        self.device_detail.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_detail(&mut self) -> DeviceOption {
        self.device_detail.take().unwrap_or_else(|| DeviceOption::new())
    }

    // optional .caffe2.TensorProto.Segment segment = 11;


    pub fn get_segment(&self) -> &TensorProto_Segment {
        self.segment.as_ref().unwrap_or_else(|| <TensorProto_Segment as ::protobuf::Message>::default_instance())
    }
    pub fn clear_segment(&mut self) {
        self.segment.clear();
    }

    pub fn has_segment(&self) -> bool {
        self.segment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_segment(&mut self, v: TensorProto_Segment) {
        self.segment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_segment(&mut self) -> &mut TensorProto_Segment {
        if self.segment.is_none() {
            self.segment.set_default();
        }
        self.segment.as_mut().unwrap()
    }

    // Take field
    pub fn take_segment(&mut self) -> TensorProto_Segment {
        self.segment.take().unwrap_or_else(|| TensorProto_Segment::new())
    }
}

impl ::protobuf::Message for TensorProto {
    fn is_initialized(&self) -> bool {
        for v in &self.device_detail {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.segment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dims)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.data_type, 2, &mut self.unknown_fields)?
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.data_format = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.float_data)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.int32_data)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.byte_data)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.string_data)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.double_data)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.int64_data)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.raw_data)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_detail)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.segment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dims {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        if let Some(v) = self.data_format {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.float_data.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.float_data.len() * 4) as u32) + (self.float_data.len() * 4) as u32;
        }
        if !self.int32_data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(4, &self.int32_data);
        }
        if let Some(ref v) = self.byte_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        for value in &self.string_data {
            my_size += ::protobuf::rt::bytes_size(6, &value);
        };
        if !self.double_data.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.double_data.len() * 8) as u32) + (self.double_data.len() * 8) as u32;
        }
        if !self.int64_data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(10, &self.int64_data);
        }
        if let Some(ref v) = self.raw_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(13, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.device_detail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.segment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dims {
            os.write_int64(1, *v)?;
        };
        if let Some(v) = self.data_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.data_format {
            os.write_uint32(15, v)?;
        }
        if !self.float_data.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.float_data.len() * 4) as u32)?;
            for v in &self.float_data {
                os.write_float_no_tag(*v)?;
            };
        }
        if !self.int32_data.is_empty() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.int32_data))?;
            for v in &self.int32_data {
                os.write_int32_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.byte_data.as_ref() {
            os.write_bytes(5, &v)?;
        }
        for v in &self.string_data {
            os.write_bytes(6, &v)?;
        };
        if !self.double_data.is_empty() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.double_data.len() * 8) as u32)?;
            for v in &self.double_data {
                os.write_double_no_tag(*v)?;
            };
        }
        if !self.int64_data.is_empty() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.int64_data))?;
            for v in &self.int64_data {
                os.write_int64_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.raw_data.as_ref() {
            os.write_bytes(13, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.device_detail.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.segment.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorProto {
        TensorProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dims",
                |m: &TensorProto| { &m.dims },
                |m: &mut TensorProto| { &mut m.dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TensorProto_DataType>>(
                "data_type",
                |m: &TensorProto| { &m.data_type },
                |m: &mut TensorProto| { &mut m.data_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "data_format",
                |m: &TensorProto| { &m.data_format },
                |m: &mut TensorProto| { &mut m.data_format },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "float_data",
                |m: &TensorProto| { &m.float_data },
                |m: &mut TensorProto| { &mut m.float_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "int32_data",
                |m: &TensorProto| { &m.int32_data },
                |m: &mut TensorProto| { &mut m.int32_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "byte_data",
                |m: &TensorProto| { &m.byte_data },
                |m: &mut TensorProto| { &mut m.byte_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "string_data",
                |m: &TensorProto| { &m.string_data },
                |m: &mut TensorProto| { &mut m.string_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "double_data",
                |m: &TensorProto| { &m.double_data },
                |m: &mut TensorProto| { &mut m.double_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "int64_data",
                |m: &TensorProto| { &m.int64_data },
                |m: &mut TensorProto| { &mut m.int64_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "raw_data",
                |m: &TensorProto| { &m.raw_data },
                |m: &mut TensorProto| { &mut m.raw_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TensorProto| { &m.name },
                |m: &mut TensorProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceOption>>(
                "device_detail",
                |m: &TensorProto| { &m.device_detail },
                |m: &mut TensorProto| { &mut m.device_detail },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto_Segment>>(
                "segment",
                |m: &TensorProto| { &m.segment },
                |m: &mut TensorProto| { &mut m.segment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TensorProto>(
                "TensorProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TensorProto {
        static instance: ::protobuf::rt::LazyV2<TensorProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorProto::new)
    }
}

impl ::protobuf::Clear for TensorProto {
    fn clear(&mut self) {
        self.dims.clear();
        self.data_type = ::std::option::Option::None;
        self.data_format = ::std::option::Option::None;
        self.float_data.clear();
        self.int32_data.clear();
        self.byte_data.clear();
        self.string_data.clear();
        self.double_data.clear();
        self.int64_data.clear();
        self.raw_data.clear();
        self.name.clear();
        self.device_detail.clear();
        self.segment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorProto_Segment {
    // message fields
    begin: ::std::option::Option<i64>,
    end: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorProto_Segment {
    fn default() -> &'a TensorProto_Segment {
        <TensorProto_Segment as ::protobuf::Message>::default_instance()
    }
}

impl TensorProto_Segment {
    pub fn new() -> TensorProto_Segment {
        ::std::default::Default::default()
    }

    // required int64 begin = 1;


    pub fn get_begin(&self) -> i64 {
        self.begin.unwrap_or(0)
    }
    pub fn clear_begin(&mut self) {
        self.begin = ::std::option::Option::None;
    }

    pub fn has_begin(&self) -> bool {
        self.begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_begin(&mut self, v: i64) {
        self.begin = ::std::option::Option::Some(v);
    }

    // required int64 end = 2;


    pub fn get_end(&self) -> i64 {
        self.end.unwrap_or(0)
    }
    pub fn clear_end(&mut self) {
        self.end = ::std::option::Option::None;
    }

    pub fn has_end(&self) -> bool {
        self.end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end(&mut self, v: i64) {
        self.end = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TensorProto_Segment {
    fn is_initialized(&self) -> bool {
        if self.begin.is_none() {
            return false;
        }
        if self.end.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.begin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.end = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.begin {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.end {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.begin {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.end {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorProto_Segment {
        TensorProto_Segment::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "begin",
                |m: &TensorProto_Segment| { &m.begin },
                |m: &mut TensorProto_Segment| { &mut m.begin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "end",
                |m: &TensorProto_Segment| { &m.end },
                |m: &mut TensorProto_Segment| { &mut m.end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TensorProto_Segment>(
                "TensorProto.Segment",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TensorProto_Segment {
        static instance: ::protobuf::rt::LazyV2<TensorProto_Segment> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorProto_Segment::new)
    }
}

impl ::protobuf::Clear for TensorProto_Segment {
    fn clear(&mut self) {
        self.begin = ::std::option::Option::None;
        self.end = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorProto_Segment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto_Segment {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TensorProto_DataType {
    UNDEFINED = 0,
    FLOAT = 1,
    INT32 = 2,
    BYTE = 3,
    STRING = 4,
    BOOL = 5,
    UINT8 = 6,
    INT8 = 7,
    UINT16 = 8,
    INT16 = 9,
    INT64 = 10,
    FLOAT16 = 12,
    DOUBLE = 13,
    ZERO_COLLISION_HASH = 14,
    REBATCHING_BUFFER = 15,
}

impl ::protobuf::ProtobufEnum for TensorProto_DataType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TensorProto_DataType> {
        match value {
            0 => ::std::option::Option::Some(TensorProto_DataType::UNDEFINED),
            1 => ::std::option::Option::Some(TensorProto_DataType::FLOAT),
            2 => ::std::option::Option::Some(TensorProto_DataType::INT32),
            3 => ::std::option::Option::Some(TensorProto_DataType::BYTE),
            4 => ::std::option::Option::Some(TensorProto_DataType::STRING),
            5 => ::std::option::Option::Some(TensorProto_DataType::BOOL),
            6 => ::std::option::Option::Some(TensorProto_DataType::UINT8),
            7 => ::std::option::Option::Some(TensorProto_DataType::INT8),
            8 => ::std::option::Option::Some(TensorProto_DataType::UINT16),
            9 => ::std::option::Option::Some(TensorProto_DataType::INT16),
            10 => ::std::option::Option::Some(TensorProto_DataType::INT64),
            12 => ::std::option::Option::Some(TensorProto_DataType::FLOAT16),
            13 => ::std::option::Option::Some(TensorProto_DataType::DOUBLE),
            14 => ::std::option::Option::Some(TensorProto_DataType::ZERO_COLLISION_HASH),
            15 => ::std::option::Option::Some(TensorProto_DataType::REBATCHING_BUFFER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TensorProto_DataType] = &[
            TensorProto_DataType::UNDEFINED,
            TensorProto_DataType::FLOAT,
            TensorProto_DataType::INT32,
            TensorProto_DataType::BYTE,
            TensorProto_DataType::STRING,
            TensorProto_DataType::BOOL,
            TensorProto_DataType::UINT8,
            TensorProto_DataType::INT8,
            TensorProto_DataType::UINT16,
            TensorProto_DataType::INT16,
            TensorProto_DataType::INT64,
            TensorProto_DataType::FLOAT16,
            TensorProto_DataType::DOUBLE,
            TensorProto_DataType::ZERO_COLLISION_HASH,
            TensorProto_DataType::REBATCHING_BUFFER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TensorProto_DataType>("TensorProto.DataType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TensorProto_DataType {
}

impl ::std::default::Default for TensorProto_DataType {
    fn default() -> Self {
        TensorProto_DataType::UNDEFINED
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto_DataType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TensorProto_SerializationFormat {
    FMT_PROTOBUF = 0,
    FMT_BFLOAT16 = 1,
}

impl ::protobuf::ProtobufEnum for TensorProto_SerializationFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TensorProto_SerializationFormat> {
        match value {
            0 => ::std::option::Option::Some(TensorProto_SerializationFormat::FMT_PROTOBUF),
            1 => ::std::option::Option::Some(TensorProto_SerializationFormat::FMT_BFLOAT16),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TensorProto_SerializationFormat] = &[
            TensorProto_SerializationFormat::FMT_PROTOBUF,
            TensorProto_SerializationFormat::FMT_BFLOAT16,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TensorProto_SerializationFormat>("TensorProto.SerializationFormat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TensorProto_SerializationFormat {
}

impl ::std::default::Default for TensorProto_SerializationFormat {
    fn default() -> Self {
        TensorProto_SerializationFormat::FMT_PROTOBUF
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProto_SerializationFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QTensorProto {
    // message fields
    pub dims: ::std::vec::Vec<i64>,
    precision: ::std::option::Option<i32>,
    scale: ::std::option::Option<f64>,
    bias: ::std::option::Option<f64>,
    is_signed: ::std::option::Option<bool>,
    pub data: ::std::vec::Vec<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    data_type: ::std::option::Option<TensorProto_DataType>,
    pub scales: ::std::vec::Vec<f64>,
    pub biases: ::std::vec::Vec<f64>,
    axis: ::std::option::Option<i32>,
    is_multiparam: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QTensorProto {
    fn default() -> &'a QTensorProto {
        <QTensorProto as ::protobuf::Message>::default_instance()
    }
}

impl QTensorProto {
    pub fn new() -> QTensorProto {
        ::std::default::Default::default()
    }

    // repeated int64 dims = 1;


    pub fn get_dims(&self) -> &[i64] {
        &self.dims
    }
    pub fn clear_dims(&mut self) {
        self.dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dims
    }

    // Take field
    pub fn take_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dims, ::std::vec::Vec::new())
    }

    // required int32 precision = 2;


    pub fn get_precision(&self) -> i32 {
        self.precision.unwrap_or(0)
    }
    pub fn clear_precision(&mut self) {
        self.precision = ::std::option::Option::None;
    }

    pub fn has_precision(&self) -> bool {
        self.precision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precision(&mut self, v: i32) {
        self.precision = ::std::option::Option::Some(v);
    }

    // required double scale = 3;


    pub fn get_scale(&self) -> f64 {
        self.scale.unwrap_or(0.)
    }
    pub fn clear_scale(&mut self) {
        self.scale = ::std::option::Option::None;
    }

    pub fn has_scale(&self) -> bool {
        self.scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scale(&mut self, v: f64) {
        self.scale = ::std::option::Option::Some(v);
    }

    // required double bias = 4;


    pub fn get_bias(&self) -> f64 {
        self.bias.unwrap_or(0.)
    }
    pub fn clear_bias(&mut self) {
        self.bias = ::std::option::Option::None;
    }

    pub fn has_bias(&self) -> bool {
        self.bias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bias(&mut self, v: f64) {
        self.bias = ::std::option::Option::Some(v);
    }

    // required bool is_signed = 5;


    pub fn get_is_signed(&self) -> bool {
        self.is_signed.unwrap_or(false)
    }
    pub fn clear_is_signed(&mut self) {
        self.is_signed = ::std::option::Option::None;
    }

    pub fn has_is_signed(&self) -> bool {
        self.is_signed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_signed(&mut self, v: bool) {
        self.is_signed = ::std::option::Option::Some(v);
    }

    // repeated int32 data = 6;


    pub fn get_data(&self) -> &[i32] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<i32>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.data, ::std::vec::Vec::new())
    }

    // optional string name = 7;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .caffe2.TensorProto.DataType data_type = 8;


    pub fn get_data_type(&self) -> TensorProto_DataType {
        self.data_type.unwrap_or(TensorProto_DataType::INT32)
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: TensorProto_DataType) {
        self.data_type = ::std::option::Option::Some(v);
    }

    // repeated double scales = 9;


    pub fn get_scales(&self) -> &[f64] {
        &self.scales
    }
    pub fn clear_scales(&mut self) {
        self.scales.clear();
    }

    // Param is passed by value, moved
    pub fn set_scales(&mut self, v: ::std::vec::Vec<f64>) {
        self.scales = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scales(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.scales
    }

    // Take field
    pub fn take_scales(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.scales, ::std::vec::Vec::new())
    }

    // repeated double biases = 10;


    pub fn get_biases(&self) -> &[f64] {
        &self.biases
    }
    pub fn clear_biases(&mut self) {
        self.biases.clear();
    }

    // Param is passed by value, moved
    pub fn set_biases(&mut self, v: ::std::vec::Vec<f64>) {
        self.biases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_biases(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.biases
    }

    // Take field
    pub fn take_biases(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.biases, ::std::vec::Vec::new())
    }

    // optional int32 axis = 11;


    pub fn get_axis(&self) -> i32 {
        self.axis.unwrap_or(0)
    }
    pub fn clear_axis(&mut self) {
        self.axis = ::std::option::Option::None;
    }

    pub fn has_axis(&self) -> bool {
        self.axis.is_some()
    }

    // Param is passed by value, moved
    pub fn set_axis(&mut self, v: i32) {
        self.axis = ::std::option::Option::Some(v);
    }

    // optional bool is_multiparam = 12;


    pub fn get_is_multiparam(&self) -> bool {
        self.is_multiparam.unwrap_or(false)
    }
    pub fn clear_is_multiparam(&mut self) {
        self.is_multiparam = ::std::option::Option::None;
    }

    pub fn has_is_multiparam(&self) -> bool {
        self.is_multiparam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_multiparam(&mut self, v: bool) {
        self.is_multiparam = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for QTensorProto {
    fn is_initialized(&self) -> bool {
        if self.precision.is_none() {
            return false;
        }
        if self.scale.is_none() {
            return false;
        }
        if self.bias.is_none() {
            return false;
        }
        if self.is_signed.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dims)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.precision = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.scale = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bias = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_signed = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.data)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                8 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.data_type, 8, &mut self.unknown_fields)?
                },
                9 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.scales)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.biases)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.axis = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_multiparam = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dims {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.precision {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.scale {
            my_size += 9;
        }
        if let Some(v) = self.bias {
            my_size += 9;
        }
        if let Some(v) = self.is_signed {
            my_size += 2;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_size(6, &self.data);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::enum_size(8, v);
        }
        my_size += 9 * self.scales.len() as u32;
        my_size += 9 * self.biases.len() as u32;
        if let Some(v) = self.axis {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_multiparam {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dims {
            os.write_int64(1, *v)?;
        };
        if let Some(v) = self.precision {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.scale {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.bias {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.is_signed {
            os.write_bool(5, v)?;
        }
        if !self.data.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_data_size(&self.data))?;
            for v in &self.data {
                os.write_int32_no_tag(*v)?;
            };
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.data_type {
            os.write_enum(8, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.scales {
            os.write_double(9, *v)?;
        };
        for v in &self.biases {
            os.write_double(10, *v)?;
        };
        if let Some(v) = self.axis {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.is_multiparam {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QTensorProto {
        QTensorProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dims",
                |m: &QTensorProto| { &m.dims },
                |m: &mut QTensorProto| { &mut m.dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "precision",
                |m: &QTensorProto| { &m.precision },
                |m: &mut QTensorProto| { &mut m.precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "scale",
                |m: &QTensorProto| { &m.scale },
                |m: &mut QTensorProto| { &mut m.scale },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bias",
                |m: &QTensorProto| { &m.bias },
                |m: &mut QTensorProto| { &mut m.bias },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_signed",
                |m: &QTensorProto| { &m.is_signed },
                |m: &mut QTensorProto| { &mut m.is_signed },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "data",
                |m: &QTensorProto| { &m.data },
                |m: &mut QTensorProto| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &QTensorProto| { &m.name },
                |m: &mut QTensorProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TensorProto_DataType>>(
                "data_type",
                |m: &QTensorProto| { &m.data_type },
                |m: &mut QTensorProto| { &mut m.data_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "scales",
                |m: &QTensorProto| { &m.scales },
                |m: &mut QTensorProto| { &mut m.scales },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "biases",
                |m: &QTensorProto| { &m.biases },
                |m: &mut QTensorProto| { &mut m.biases },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "axis",
                |m: &QTensorProto| { &m.axis },
                |m: &mut QTensorProto| { &mut m.axis },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_multiparam",
                |m: &QTensorProto| { &m.is_multiparam },
                |m: &mut QTensorProto| { &mut m.is_multiparam },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QTensorProto>(
                "QTensorProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QTensorProto {
        static instance: ::protobuf::rt::LazyV2<QTensorProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QTensorProto::new)
    }
}

impl ::protobuf::Clear for QTensorProto {
    fn clear(&mut self) {
        self.dims.clear();
        self.precision = ::std::option::Option::None;
        self.scale = ::std::option::Option::None;
        self.bias = ::std::option::Option::None;
        self.is_signed = ::std::option::Option::None;
        self.data.clear();
        self.name.clear();
        self.data_type = ::std::option::Option::None;
        self.scales.clear();
        self.biases.clear();
        self.axis = ::std::option::Option::None;
        self.is_multiparam = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QTensorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QTensorProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorProtos {
    // message fields
    pub protos: ::protobuf::RepeatedField<TensorProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorProtos {
    fn default() -> &'a TensorProtos {
        <TensorProtos as ::protobuf::Message>::default_instance()
    }
}

impl TensorProtos {
    pub fn new() -> TensorProtos {
        ::std::default::Default::default()
    }

    // repeated .caffe2.TensorProto protos = 1;


    pub fn get_protos(&self) -> &[TensorProto] {
        &self.protos
    }
    pub fn clear_protos(&mut self) {
        self.protos.clear();
    }

    // Param is passed by value, moved
    pub fn set_protos(&mut self, v: ::protobuf::RepeatedField<TensorProto>) {
        self.protos = v;
    }

    // Mutable pointer to the field.
    pub fn mut_protos(&mut self) -> &mut ::protobuf::RepeatedField<TensorProto> {
        &mut self.protos
    }

    // Take field
    pub fn take_protos(&mut self) -> ::protobuf::RepeatedField<TensorProto> {
        ::std::mem::replace(&mut self.protos, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TensorProtos {
    fn is_initialized(&self) -> bool {
        for v in &self.protos {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.protos)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.protos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.protos {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorProtos {
        TensorProtos::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto>>(
                "protos",
                |m: &TensorProtos| { &m.protos },
                |m: &mut TensorProtos| { &mut m.protos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TensorProtos>(
                "TensorProtos",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TensorProtos {
        static instance: ::protobuf::rt::LazyV2<TensorProtos> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorProtos::new)
    }
}

impl ::protobuf::Clear for TensorProtos {
    fn clear(&mut self) {
        self.protos.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorProtos {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorProtos {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorShape {
    // message fields
    pub dims: ::std::vec::Vec<i64>,
    data_type: ::std::option::Option<TensorProto_DataType>,
    pub unknown_dims: ::std::vec::Vec<i32>,
    unknown_shape: ::std::option::Option<bool>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorShape {
    fn default() -> &'a TensorShape {
        <TensorShape as ::protobuf::Message>::default_instance()
    }
}

impl TensorShape {
    pub fn new() -> TensorShape {
        ::std::default::Default::default()
    }

    // repeated int64 dims = 1;


    pub fn get_dims(&self) -> &[i64] {
        &self.dims
    }
    pub fn clear_dims(&mut self) {
        self.dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dims
    }

    // Take field
    pub fn take_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dims, ::std::vec::Vec::new())
    }

    // optional .caffe2.TensorProto.DataType data_type = 2;


    pub fn get_data_type(&self) -> TensorProto_DataType {
        self.data_type.unwrap_or(TensorProto_DataType::FLOAT)
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = ::std::option::Option::None;
    }

    pub fn has_data_type(&self) -> bool {
        self.data_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: TensorProto_DataType) {
        self.data_type = ::std::option::Option::Some(v);
    }

    // repeated int32 unknown_dims = 3;


    pub fn get_unknown_dims(&self) -> &[i32] {
        &self.unknown_dims
    }
    pub fn clear_unknown_dims(&mut self) {
        self.unknown_dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_unknown_dims(&mut self, v: ::std::vec::Vec<i32>) {
        self.unknown_dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_unknown_dims(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.unknown_dims
    }

    // Take field
    pub fn take_unknown_dims(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.unknown_dims, ::std::vec::Vec::new())
    }

    // optional bool unknown_shape = 4;


    pub fn get_unknown_shape(&self) -> bool {
        self.unknown_shape.unwrap_or(false)
    }
    pub fn clear_unknown_shape(&mut self) {
        self.unknown_shape = ::std::option::Option::None;
    }

    pub fn has_unknown_shape(&self) -> bool {
        self.unknown_shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unknown_shape(&mut self, v: bool) {
        self.unknown_shape = ::std::option::Option::Some(v);
    }

    // optional string name = 5;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TensorShape {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dims)?;
                },
                2 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.data_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.unknown_dims)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unknown_shape = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dims {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.data_type {
            my_size += ::protobuf::rt::enum_size(2, v);
        }
        for value in &self.unknown_dims {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.unknown_shape {
            my_size += 2;
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dims {
            os.write_int64(1, *v)?;
        };
        if let Some(v) = self.data_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
        }
        for v in &self.unknown_dims {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.unknown_shape {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorShape {
        TensorShape::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dims",
                |m: &TensorShape| { &m.dims },
                |m: &mut TensorShape| { &mut m.dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TensorProto_DataType>>(
                "data_type",
                |m: &TensorShape| { &m.data_type },
                |m: &mut TensorShape| { &mut m.data_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "unknown_dims",
                |m: &TensorShape| { &m.unknown_dims },
                |m: &mut TensorShape| { &mut m.unknown_dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unknown_shape",
                |m: &TensorShape| { &m.unknown_shape },
                |m: &mut TensorShape| { &mut m.unknown_shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TensorShape| { &m.name },
                |m: &mut TensorShape| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TensorShape>(
                "TensorShape",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TensorShape {
        static instance: ::protobuf::rt::LazyV2<TensorShape> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorShape::new)
    }
}

impl ::protobuf::Clear for TensorShape {
    fn clear(&mut self) {
        self.dims.clear();
        self.data_type = ::std::option::Option::None;
        self.unknown_dims.clear();
        self.unknown_shape = ::std::option::Option::None;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorShape {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorShape {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorShapes {
    // message fields
    pub shapes: ::protobuf::RepeatedField<TensorShape>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorShapes {
    fn default() -> &'a TensorShapes {
        <TensorShapes as ::protobuf::Message>::default_instance()
    }
}

impl TensorShapes {
    pub fn new() -> TensorShapes {
        ::std::default::Default::default()
    }

    // repeated .caffe2.TensorShape shapes = 1;


    pub fn get_shapes(&self) -> &[TensorShape] {
        &self.shapes
    }
    pub fn clear_shapes(&mut self) {
        self.shapes.clear();
    }

    // Param is passed by value, moved
    pub fn set_shapes(&mut self, v: ::protobuf::RepeatedField<TensorShape>) {
        self.shapes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shapes(&mut self) -> &mut ::protobuf::RepeatedField<TensorShape> {
        &mut self.shapes
    }

    // Take field
    pub fn take_shapes(&mut self) -> ::protobuf::RepeatedField<TensorShape> {
        ::std::mem::replace(&mut self.shapes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TensorShapes {
    fn is_initialized(&self) -> bool {
        for v in &self.shapes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shapes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.shapes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.shapes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorShapes {
        TensorShapes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorShape>>(
                "shapes",
                |m: &TensorShapes| { &m.shapes },
                |m: &mut TensorShapes| { &mut m.shapes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TensorShapes>(
                "TensorShapes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TensorShapes {
        static instance: ::protobuf::rt::LazyV2<TensorShapes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorShapes::new)
    }
}

impl ::protobuf::Clear for TensorShapes {
    fn clear(&mut self) {
        self.shapes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorShapes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorShapes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorBoundShape {
    // message fields
    pub shape: ::protobuf::SingularPtrField<TensorShape>,
    pub dim_type: ::std::vec::Vec<TensorBoundShape_DimType>,
    name: ::protobuf::SingularField<::std::string::String>,
    shape_is_final: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorBoundShape {
    fn default() -> &'a TensorBoundShape {
        <TensorBoundShape as ::protobuf::Message>::default_instance()
    }
}

impl TensorBoundShape {
    pub fn new() -> TensorBoundShape {
        ::std::default::Default::default()
    }

    // optional .caffe2.TensorShape shape = 1;


    pub fn get_shape(&self) -> &TensorShape {
        self.shape.as_ref().unwrap_or_else(|| <TensorShape as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: TensorShape) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut TensorShape {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> TensorShape {
        self.shape.take().unwrap_or_else(|| TensorShape::new())
    }

    // repeated .caffe2.TensorBoundShape.DimType dim_type = 2;


    pub fn get_dim_type(&self) -> &[TensorBoundShape_DimType] {
        &self.dim_type
    }
    pub fn clear_dim_type(&mut self) {
        self.dim_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_dim_type(&mut self, v: ::std::vec::Vec<TensorBoundShape_DimType>) {
        self.dim_type = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dim_type(&mut self) -> &mut ::std::vec::Vec<TensorBoundShape_DimType> {
        &mut self.dim_type
    }

    // Take field
    pub fn take_dim_type(&mut self) -> ::std::vec::Vec<TensorBoundShape_DimType> {
        ::std::mem::replace(&mut self.dim_type, ::std::vec::Vec::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool shape_is_final = 4;


    pub fn get_shape_is_final(&self) -> bool {
        self.shape_is_final.unwrap_or(false)
    }
    pub fn clear_shape_is_final(&mut self) {
        self.shape_is_final = ::std::option::Option::None;
    }

    pub fn has_shape_is_final(&self) -> bool {
        self.shape_is_final.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape_is_final(&mut self, v: bool) {
        self.shape_is_final = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TensorBoundShape {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.dim_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shape_is_final = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.dim_type {
            my_size += ::protobuf::rt::enum_size(2, *value);
        };
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.shape_is_final {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.dim_type {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(v))?;
        };
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.shape_is_final {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorBoundShape {
        TensorBoundShape::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorShape>>(
                "shape",
                |m: &TensorBoundShape| { &m.shape },
                |m: &mut TensorBoundShape| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TensorBoundShape_DimType>>(
                "dim_type",
                |m: &TensorBoundShape| { &m.dim_type },
                |m: &mut TensorBoundShape| { &mut m.dim_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TensorBoundShape| { &m.name },
                |m: &mut TensorBoundShape| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "shape_is_final",
                |m: &TensorBoundShape| { &m.shape_is_final },
                |m: &mut TensorBoundShape| { &mut m.shape_is_final },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TensorBoundShape>(
                "TensorBoundShape",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TensorBoundShape {
        static instance: ::protobuf::rt::LazyV2<TensorBoundShape> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorBoundShape::new)
    }
}

impl ::protobuf::Clear for TensorBoundShape {
    fn clear(&mut self) {
        self.shape.clear();
        self.dim_type.clear();
        self.name.clear();
        self.shape_is_final = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorBoundShape {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorBoundShape {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TensorBoundShape_DimType {
    UNKNOWN = 0,
    CONSTANT = 1,
    BATCH = 2,
    BATCH_OF_FEATURE_MAX = 3,
    BATCH_OF_FEATURE_MAX_DEFAULT = 4,
    FEATURE_MAX = 5,
    FEATURE_MAX_DEFAULT = 6,
}

impl ::protobuf::ProtobufEnum for TensorBoundShape_DimType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TensorBoundShape_DimType> {
        match value {
            0 => ::std::option::Option::Some(TensorBoundShape_DimType::UNKNOWN),
            1 => ::std::option::Option::Some(TensorBoundShape_DimType::CONSTANT),
            2 => ::std::option::Option::Some(TensorBoundShape_DimType::BATCH),
            3 => ::std::option::Option::Some(TensorBoundShape_DimType::BATCH_OF_FEATURE_MAX),
            4 => ::std::option::Option::Some(TensorBoundShape_DimType::BATCH_OF_FEATURE_MAX_DEFAULT),
            5 => ::std::option::Option::Some(TensorBoundShape_DimType::FEATURE_MAX),
            6 => ::std::option::Option::Some(TensorBoundShape_DimType::FEATURE_MAX_DEFAULT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TensorBoundShape_DimType] = &[
            TensorBoundShape_DimType::UNKNOWN,
            TensorBoundShape_DimType::CONSTANT,
            TensorBoundShape_DimType::BATCH,
            TensorBoundShape_DimType::BATCH_OF_FEATURE_MAX,
            TensorBoundShape_DimType::BATCH_OF_FEATURE_MAX_DEFAULT,
            TensorBoundShape_DimType::FEATURE_MAX,
            TensorBoundShape_DimType::FEATURE_MAX_DEFAULT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TensorBoundShape_DimType>("TensorBoundShape.DimType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TensorBoundShape_DimType {
}

impl ::std::default::Default for TensorBoundShape_DimType {
    fn default() -> Self {
        TensorBoundShape_DimType::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorBoundShape_DimType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TensorBoundShapes {
    // message fields
    pub shapes: ::protobuf::RepeatedField<TensorBoundShape>,
    max_batch_size: ::std::option::Option<i64>,
    max_feature_len: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TensorBoundShapes {
    fn default() -> &'a TensorBoundShapes {
        <TensorBoundShapes as ::protobuf::Message>::default_instance()
    }
}

impl TensorBoundShapes {
    pub fn new() -> TensorBoundShapes {
        ::std::default::Default::default()
    }

    // repeated .caffe2.TensorBoundShape shapes = 1;


    pub fn get_shapes(&self) -> &[TensorBoundShape] {
        &self.shapes
    }
    pub fn clear_shapes(&mut self) {
        self.shapes.clear();
    }

    // Param is passed by value, moved
    pub fn set_shapes(&mut self, v: ::protobuf::RepeatedField<TensorBoundShape>) {
        self.shapes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shapes(&mut self) -> &mut ::protobuf::RepeatedField<TensorBoundShape> {
        &mut self.shapes
    }

    // Take field
    pub fn take_shapes(&mut self) -> ::protobuf::RepeatedField<TensorBoundShape> {
        ::std::mem::replace(&mut self.shapes, ::protobuf::RepeatedField::new())
    }

    // optional int64 max_batch_size = 2;


    pub fn get_max_batch_size(&self) -> i64 {
        self.max_batch_size.unwrap_or(0)
    }
    pub fn clear_max_batch_size(&mut self) {
        self.max_batch_size = ::std::option::Option::None;
    }

    pub fn has_max_batch_size(&self) -> bool {
        self.max_batch_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_batch_size(&mut self, v: i64) {
        self.max_batch_size = ::std::option::Option::Some(v);
    }

    // optional int64 max_feature_len = 3;


    pub fn get_max_feature_len(&self) -> i64 {
        self.max_feature_len.unwrap_or(0)
    }
    pub fn clear_max_feature_len(&mut self) {
        self.max_feature_len = ::std::option::Option::None;
    }

    pub fn has_max_feature_len(&self) -> bool {
        self.max_feature_len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_feature_len(&mut self, v: i64) {
        self.max_feature_len = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for TensorBoundShapes {
    fn is_initialized(&self) -> bool {
        for v in &self.shapes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shapes)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_batch_size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_feature_len = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.shapes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.max_batch_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_feature_len {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.shapes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.max_batch_size {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.max_feature_len {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TensorBoundShapes {
        TensorBoundShapes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorBoundShape>>(
                "shapes",
                |m: &TensorBoundShapes| { &m.shapes },
                |m: &mut TensorBoundShapes| { &mut m.shapes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_batch_size",
                |m: &TensorBoundShapes| { &m.max_batch_size },
                |m: &mut TensorBoundShapes| { &mut m.max_batch_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_feature_len",
                |m: &TensorBoundShapes| { &m.max_feature_len },
                |m: &mut TensorBoundShapes| { &mut m.max_feature_len },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TensorBoundShapes>(
                "TensorBoundShapes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TensorBoundShapes {
        static instance: ::protobuf::rt::LazyV2<TensorBoundShapes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TensorBoundShapes::new)
    }
}

impl ::protobuf::Clear for TensorBoundShapes {
    fn clear(&mut self) {
        self.shapes.clear();
        self.max_batch_size = ::std::option::Option::None;
        self.max_feature_len = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TensorBoundShapes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TensorBoundShapes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AOTConfig {
    // message fields
    max_batch_size: ::std::option::Option<i64>,
    max_seq_size: ::std::option::Option<i64>,
    in_batch_broadcast: ::std::option::Option<bool>,
    onnxifi_blacklist_ops: ::protobuf::SingularField<::std::string::String>,
    onnxifi_min_ops: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AOTConfig {
    fn default() -> &'a AOTConfig {
        <AOTConfig as ::protobuf::Message>::default_instance()
    }
}

impl AOTConfig {
    pub fn new() -> AOTConfig {
        ::std::default::Default::default()
    }

    // required int64 max_batch_size = 1;


    pub fn get_max_batch_size(&self) -> i64 {
        self.max_batch_size.unwrap_or(0)
    }
    pub fn clear_max_batch_size(&mut self) {
        self.max_batch_size = ::std::option::Option::None;
    }

    pub fn has_max_batch_size(&self) -> bool {
        self.max_batch_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_batch_size(&mut self, v: i64) {
        self.max_batch_size = ::std::option::Option::Some(v);
    }

    // required int64 max_seq_size = 2;


    pub fn get_max_seq_size(&self) -> i64 {
        self.max_seq_size.unwrap_or(0)
    }
    pub fn clear_max_seq_size(&mut self) {
        self.max_seq_size = ::std::option::Option::None;
    }

    pub fn has_max_seq_size(&self) -> bool {
        self.max_seq_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_seq_size(&mut self, v: i64) {
        self.max_seq_size = ::std::option::Option::Some(v);
    }

    // required bool in_batch_broadcast = 3;


    pub fn get_in_batch_broadcast(&self) -> bool {
        self.in_batch_broadcast.unwrap_or(false)
    }
    pub fn clear_in_batch_broadcast(&mut self) {
        self.in_batch_broadcast = ::std::option::Option::None;
    }

    pub fn has_in_batch_broadcast(&self) -> bool {
        self.in_batch_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_batch_broadcast(&mut self, v: bool) {
        self.in_batch_broadcast = ::std::option::Option::Some(v);
    }

    // optional string onnxifi_blacklist_ops = 4;


    pub fn get_onnxifi_blacklist_ops(&self) -> &str {
        match self.onnxifi_blacklist_ops.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_onnxifi_blacklist_ops(&mut self) {
        self.onnxifi_blacklist_ops.clear();
    }

    pub fn has_onnxifi_blacklist_ops(&self) -> bool {
        self.onnxifi_blacklist_ops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onnxifi_blacklist_ops(&mut self, v: ::std::string::String) {
        self.onnxifi_blacklist_ops = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_onnxifi_blacklist_ops(&mut self) -> &mut ::std::string::String {
        if self.onnxifi_blacklist_ops.is_none() {
            self.onnxifi_blacklist_ops.set_default();
        }
        self.onnxifi_blacklist_ops.as_mut().unwrap()
    }

    // Take field
    pub fn take_onnxifi_blacklist_ops(&mut self) -> ::std::string::String {
        self.onnxifi_blacklist_ops.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 onnxifi_min_ops = 5;


    pub fn get_onnxifi_min_ops(&self) -> i32 {
        self.onnxifi_min_ops.unwrap_or(0)
    }
    pub fn clear_onnxifi_min_ops(&mut self) {
        self.onnxifi_min_ops = ::std::option::Option::None;
    }

    pub fn has_onnxifi_min_ops(&self) -> bool {
        self.onnxifi_min_ops.is_some()
    }

    // Param is passed by value, moved
    pub fn set_onnxifi_min_ops(&mut self, v: i32) {
        self.onnxifi_min_ops = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AOTConfig {
    fn is_initialized(&self) -> bool {
        if self.max_batch_size.is_none() {
            return false;
        }
        if self.max_seq_size.is_none() {
            return false;
        }
        if self.in_batch_broadcast.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_batch_size = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_seq_size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_batch_broadcast = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.onnxifi_blacklist_ops)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.onnxifi_min_ops = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.max_batch_size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.max_seq_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.in_batch_broadcast {
            my_size += 2;
        }
        if let Some(ref v) = self.onnxifi_blacklist_ops.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.onnxifi_min_ops {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.max_batch_size {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.max_seq_size {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.in_batch_broadcast {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.onnxifi_blacklist_ops.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.onnxifi_min_ops {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AOTConfig {
        AOTConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_batch_size",
                |m: &AOTConfig| { &m.max_batch_size },
                |m: &mut AOTConfig| { &mut m.max_batch_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_seq_size",
                |m: &AOTConfig| { &m.max_seq_size },
                |m: &mut AOTConfig| { &mut m.max_seq_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "in_batch_broadcast",
                |m: &AOTConfig| { &m.in_batch_broadcast },
                |m: &mut AOTConfig| { &mut m.in_batch_broadcast },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "onnxifi_blacklist_ops",
                |m: &AOTConfig| { &m.onnxifi_blacklist_ops },
                |m: &mut AOTConfig| { &mut m.onnxifi_blacklist_ops },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "onnxifi_min_ops",
                |m: &AOTConfig| { &m.onnxifi_min_ops },
                |m: &mut AOTConfig| { &mut m.onnxifi_min_ops },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AOTConfig>(
                "AOTConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AOTConfig {
        static instance: ::protobuf::rt::LazyV2<AOTConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AOTConfig::new)
    }
}

impl ::protobuf::Clear for AOTConfig {
    fn clear(&mut self) {
        self.max_batch_size = ::std::option::Option::None;
        self.max_seq_size = ::std::option::Option::None;
        self.in_batch_broadcast = ::std::option::Option::None;
        self.onnxifi_blacklist_ops.clear();
        self.onnxifi_min_ops = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AOTConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AOTConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Argument {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    f: ::std::option::Option<f32>,
    i: ::std::option::Option<i64>,
    s: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub t: ::protobuf::SingularPtrField<TensorProto>,
    pub n: ::protobuf::SingularPtrField<NetDef>,
    pub floats: ::std::vec::Vec<f32>,
    pub ints: ::std::vec::Vec<i64>,
    pub strings: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub tensors: ::protobuf::RepeatedField<TensorProto>,
    pub nets: ::protobuf::RepeatedField<NetDef>,
    pub qtensors: ::protobuf::RepeatedField<QTensorProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Argument {
    fn default() -> &'a Argument {
        <Argument as ::protobuf::Message>::default_instance()
    }
}

impl Argument {
    pub fn new() -> Argument {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float f = 2;


    pub fn get_f(&self) -> f32 {
        self.f.unwrap_or(0.)
    }
    pub fn clear_f(&mut self) {
        self.f = ::std::option::Option::None;
    }

    pub fn has_f(&self) -> bool {
        self.f.is_some()
    }

    // Param is passed by value, moved
    pub fn set_f(&mut self, v: f32) {
        self.f = ::std::option::Option::Some(v);
    }

    // optional int64 i = 3;


    pub fn get_i(&self) -> i64 {
        self.i.unwrap_or(0)
    }
    pub fn clear_i(&mut self) {
        self.i = ::std::option::Option::None;
    }

    pub fn has_i(&self) -> bool {
        self.i.is_some()
    }

    // Param is passed by value, moved
    pub fn set_i(&mut self, v: i64) {
        self.i = ::std::option::Option::Some(v);
    }

    // optional bytes s = 4;


    pub fn get_s(&self) -> &[u8] {
        match self.s.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_s(&mut self) {
        self.s.clear();
    }

    pub fn has_s(&self) -> bool {
        self.s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_s(&mut self, v: ::std::vec::Vec<u8>) {
        self.s = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.s.is_none() {
            self.s.set_default();
        }
        self.s.as_mut().unwrap()
    }

    // Take field
    pub fn take_s(&mut self) -> ::std::vec::Vec<u8> {
        self.s.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .caffe2.TensorProto t = 10;


    pub fn get_t(&self) -> &TensorProto {
        self.t.as_ref().unwrap_or_else(|| <TensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_t(&mut self) {
        self.t.clear();
    }

    pub fn has_t(&self) -> bool {
        self.t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_t(&mut self, v: TensorProto) {
        self.t = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_t(&mut self) -> &mut TensorProto {
        if self.t.is_none() {
            self.t.set_default();
        }
        self.t.as_mut().unwrap()
    }

    // Take field
    pub fn take_t(&mut self) -> TensorProto {
        self.t.take().unwrap_or_else(|| TensorProto::new())
    }

    // optional .caffe2.NetDef n = 8;


    pub fn get_n(&self) -> &NetDef {
        self.n.as_ref().unwrap_or_else(|| <NetDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_n(&mut self) {
        self.n.clear();
    }

    pub fn has_n(&self) -> bool {
        self.n.is_some()
    }

    // Param is passed by value, moved
    pub fn set_n(&mut self, v: NetDef) {
        self.n = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_n(&mut self) -> &mut NetDef {
        if self.n.is_none() {
            self.n.set_default();
        }
        self.n.as_mut().unwrap()
    }

    // Take field
    pub fn take_n(&mut self) -> NetDef {
        self.n.take().unwrap_or_else(|| NetDef::new())
    }

    // repeated float floats = 5;


    pub fn get_floats(&self) -> &[f32] {
        &self.floats
    }
    pub fn clear_floats(&mut self) {
        self.floats.clear();
    }

    // Param is passed by value, moved
    pub fn set_floats(&mut self, v: ::std::vec::Vec<f32>) {
        self.floats = v;
    }

    // Mutable pointer to the field.
    pub fn mut_floats(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.floats
    }

    // Take field
    pub fn take_floats(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.floats, ::std::vec::Vec::new())
    }

    // repeated int64 ints = 6;


    pub fn get_ints(&self) -> &[i64] {
        &self.ints
    }
    pub fn clear_ints(&mut self) {
        self.ints.clear();
    }

    // Param is passed by value, moved
    pub fn set_ints(&mut self, v: ::std::vec::Vec<i64>) {
        self.ints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ints(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.ints
    }

    // Take field
    pub fn take_ints(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.ints, ::std::vec::Vec::new())
    }

    // repeated bytes strings = 7;


    pub fn get_strings(&self) -> &[::std::vec::Vec<u8>] {
        &self.strings
    }
    pub fn clear_strings(&mut self) {
        self.strings.clear();
    }

    // Param is passed by value, moved
    pub fn set_strings(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.strings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_strings(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.strings
    }

    // Take field
    pub fn take_strings(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.strings, ::protobuf::RepeatedField::new())
    }

    // repeated .caffe2.TensorProto tensors = 11;


    pub fn get_tensors(&self) -> &[TensorProto] {
        &self.tensors
    }
    pub fn clear_tensors(&mut self) {
        self.tensors.clear();
    }

    // Param is passed by value, moved
    pub fn set_tensors(&mut self, v: ::protobuf::RepeatedField<TensorProto>) {
        self.tensors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tensors(&mut self) -> &mut ::protobuf::RepeatedField<TensorProto> {
        &mut self.tensors
    }

    // Take field
    pub fn take_tensors(&mut self) -> ::protobuf::RepeatedField<TensorProto> {
        ::std::mem::replace(&mut self.tensors, ::protobuf::RepeatedField::new())
    }

    // repeated .caffe2.NetDef nets = 9;


    pub fn get_nets(&self) -> &[NetDef] {
        &self.nets
    }
    pub fn clear_nets(&mut self) {
        self.nets.clear();
    }

    // Param is passed by value, moved
    pub fn set_nets(&mut self, v: ::protobuf::RepeatedField<NetDef>) {
        self.nets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nets(&mut self) -> &mut ::protobuf::RepeatedField<NetDef> {
        &mut self.nets
    }

    // Take field
    pub fn take_nets(&mut self) -> ::protobuf::RepeatedField<NetDef> {
        ::std::mem::replace(&mut self.nets, ::protobuf::RepeatedField::new())
    }

    // repeated .caffe2.QTensorProto qtensors = 12;


    pub fn get_qtensors(&self) -> &[QTensorProto] {
        &self.qtensors
    }
    pub fn clear_qtensors(&mut self) {
        self.qtensors.clear();
    }

    // Param is passed by value, moved
    pub fn set_qtensors(&mut self, v: ::protobuf::RepeatedField<QTensorProto>) {
        self.qtensors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_qtensors(&mut self) -> &mut ::protobuf::RepeatedField<QTensorProto> {
        &mut self.qtensors
    }

    // Take field
    pub fn take_qtensors(&mut self) -> ::protobuf::RepeatedField<QTensorProto> {
        ::std::mem::replace(&mut self.qtensors, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Argument {
    fn is_initialized(&self) -> bool {
        for v in &self.t {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.n {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tensors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.qtensors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.f = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.i = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.s)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.t)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.n)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.floats)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.ints)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.strings)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tensors)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nets)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.qtensors)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.f {
            my_size += 5;
        }
        if let Some(v) = self.i {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.s.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.t.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.n.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 5 * self.floats.len() as u32;
        for value in &self.ints {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.strings {
            my_size += ::protobuf::rt::bytes_size(7, &value);
        };
        for value in &self.tensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.nets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.qtensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.f {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.i {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.s.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.t.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.n.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.floats {
            os.write_float(5, *v)?;
        };
        for v in &self.ints {
            os.write_int64(6, *v)?;
        };
        for v in &self.strings {
            os.write_bytes(7, &v)?;
        };
        for v in &self.tensors {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.nets {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.qtensors {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Argument {
        Argument::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Argument| { &m.name },
                |m: &mut Argument| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "f",
                |m: &Argument| { &m.f },
                |m: &mut Argument| { &mut m.f },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "i",
                |m: &Argument| { &m.i },
                |m: &mut Argument| { &mut m.i },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "s",
                |m: &Argument| { &m.s },
                |m: &mut Argument| { &mut m.s },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto>>(
                "t",
                |m: &Argument| { &m.t },
                |m: &mut Argument| { &mut m.t },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetDef>>(
                "n",
                |m: &Argument| { &m.n },
                |m: &mut Argument| { &mut m.n },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "floats",
                |m: &Argument| { &m.floats },
                |m: &mut Argument| { &mut m.floats },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ints",
                |m: &Argument| { &m.ints },
                |m: &mut Argument| { &mut m.ints },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "strings",
                |m: &Argument| { &m.strings },
                |m: &mut Argument| { &mut m.strings },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto>>(
                "tensors",
                |m: &Argument| { &m.tensors },
                |m: &mut Argument| { &mut m.tensors },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetDef>>(
                "nets",
                |m: &Argument| { &m.nets },
                |m: &mut Argument| { &mut m.nets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QTensorProto>>(
                "qtensors",
                |m: &Argument| { &m.qtensors },
                |m: &mut Argument| { &mut m.qtensors },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Argument>(
                "Argument",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Argument {
        static instance: ::protobuf::rt::LazyV2<Argument> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Argument::new)
    }
}

impl ::protobuf::Clear for Argument {
    fn clear(&mut self) {
        self.name.clear();
        self.f = ::std::option::Option::None;
        self.i = ::std::option::Option::None;
        self.s.clear();
        self.t.clear();
        self.n.clear();
        self.floats.clear();
        self.ints.clear();
        self.strings.clear();
        self.tensors.clear();
        self.nets.clear();
        self.qtensors.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Argument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Argument {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceOption {
    // message fields
    device_type: ::std::option::Option<i32>,
    device_id: ::std::option::Option<i32>,
    random_seed: ::std::option::Option<u32>,
    node_name: ::protobuf::SingularField<::std::string::String>,
    numa_node_id: ::std::option::Option<i32>,
    pub extra_info: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceOption {
    fn default() -> &'a DeviceOption {
        <DeviceOption as ::protobuf::Message>::default_instance()
    }
}

impl DeviceOption {
    pub fn new() -> DeviceOption {
        ::std::default::Default::default()
    }

    // optional int32 device_type = 1;


    pub fn get_device_type(&self) -> i32 {
        self.device_type.unwrap_or(0i32)
    }
    pub fn clear_device_type(&mut self) {
        self.device_type = ::std::option::Option::None;
    }

    pub fn has_device_type(&self) -> bool {
        self.device_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_type(&mut self, v: i32) {
        self.device_type = ::std::option::Option::Some(v);
    }

    // optional int32 device_id = 2;


    pub fn get_device_id(&self) -> i32 {
        self.device_id.unwrap_or(0)
    }
    pub fn clear_device_id(&mut self) {
        self.device_id = ::std::option::Option::None;
    }

    pub fn has_device_id(&self) -> bool {
        self.device_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: i32) {
        self.device_id = ::std::option::Option::Some(v);
    }

    // optional uint32 random_seed = 3;


    pub fn get_random_seed(&self) -> u32 {
        self.random_seed.unwrap_or(0)
    }
    pub fn clear_random_seed(&mut self) {
        self.random_seed = ::std::option::Option::None;
    }

    pub fn has_random_seed(&self) -> bool {
        self.random_seed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_seed(&mut self, v: u32) {
        self.random_seed = ::std::option::Option::Some(v);
    }

    // optional string node_name = 4;


    pub fn get_node_name(&self) -> &str {
        match self.node_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_node_name(&mut self) {
        self.node_name.clear();
    }

    pub fn has_node_name(&self) -> bool {
        self.node_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_name(&mut self, v: ::std::string::String) {
        self.node_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_name(&mut self) -> &mut ::std::string::String {
        if self.node_name.is_none() {
            self.node_name.set_default();
        }
        self.node_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_name(&mut self) -> ::std::string::String {
        self.node_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 numa_node_id = 5;


    pub fn get_numa_node_id(&self) -> i32 {
        self.numa_node_id.unwrap_or(0)
    }
    pub fn clear_numa_node_id(&mut self) {
        self.numa_node_id = ::std::option::Option::None;
    }

    pub fn has_numa_node_id(&self) -> bool {
        self.numa_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numa_node_id(&mut self, v: i32) {
        self.numa_node_id = ::std::option::Option::Some(v);
    }

    // repeated string extra_info = 6;


    pub fn get_extra_info(&self) -> &[::std::string::String] {
        &self.extra_info
    }
    pub fn clear_extra_info(&mut self) {
        self.extra_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_extra_info(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.extra_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_extra_info(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.extra_info
    }

    // Take field
    pub fn take_extra_info(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.extra_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeviceOption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_type = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.device_id = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.random_seed = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.node_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.numa_node_id = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.extra_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.device_type {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.device_id {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.random_seed {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.node_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.numa_node_id {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.extra_info {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.device_type {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.device_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.random_seed {
            os.write_uint32(3, v)?;
        }
        if let Some(ref v) = self.node_name.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.numa_node_id {
            os.write_int32(5, v)?;
        }
        for v in &self.extra_info {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceOption {
        DeviceOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "device_type",
                |m: &DeviceOption| { &m.device_type },
                |m: &mut DeviceOption| { &mut m.device_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "device_id",
                |m: &DeviceOption| { &m.device_id },
                |m: &mut DeviceOption| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "random_seed",
                |m: &DeviceOption| { &m.random_seed },
                |m: &mut DeviceOption| { &mut m.random_seed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_name",
                |m: &DeviceOption| { &m.node_name },
                |m: &mut DeviceOption| { &mut m.node_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "numa_node_id",
                |m: &DeviceOption| { &m.numa_node_id },
                |m: &mut DeviceOption| { &mut m.numa_node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extra_info",
                |m: &DeviceOption| { &m.extra_info },
                |m: &mut DeviceOption| { &mut m.extra_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceOption>(
                "DeviceOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceOption {
        static instance: ::protobuf::rt::LazyV2<DeviceOption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceOption::new)
    }
}

impl ::protobuf::Clear for DeviceOption {
    fn clear(&mut self) {
        self.device_type = ::std::option::Option::None;
        self.device_id = ::std::option::Option::None;
        self.random_seed = ::std::option::Option::None;
        self.node_name.clear();
        self.numa_node_id = ::std::option::Option::None;
        self.extra_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OperatorDef {
    // message fields
    pub input: ::protobuf::RepeatedField<::std::string::String>,
    pub output: ::protobuf::RepeatedField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    pub arg: ::protobuf::RepeatedField<Argument>,
    pub device_option: ::protobuf::SingularPtrField<DeviceOption>,
    engine: ::protobuf::SingularField<::std::string::String>,
    pub control_input: ::protobuf::RepeatedField<::std::string::String>,
    is_gradient_op: ::std::option::Option<bool>,
    debug_info: ::protobuf::SingularField<::std::string::String>,
    domain: ::protobuf::SingularField<::std::string::String>,
    op_version: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OperatorDef {
    fn default() -> &'a OperatorDef {
        <OperatorDef as ::protobuf::Message>::default_instance()
    }
}

impl OperatorDef {
    pub fn new() -> OperatorDef {
        ::std::default::Default::default()
    }

    // repeated string input = 1;


    pub fn get_input(&self) -> &[::std::string::String] {
        &self.input
    }
    pub fn clear_input(&mut self) {
        self.input.clear();
    }

    // Param is passed by value, moved
    pub fn set_input(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.input
    }

    // Take field
    pub fn take_input(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.input, ::protobuf::RepeatedField::new())
    }

    // repeated string output = 2;


    pub fn get_output(&self) -> &[::std::string::String] {
        &self.output
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.output = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.output
    }

    // Take field
    pub fn take_output(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.output, ::protobuf::RepeatedField::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 4;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .caffe2.Argument arg = 5;


    pub fn get_arg(&self) -> &[Argument] {
        &self.arg
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::protobuf::RepeatedField<Argument>) {
        self.arg = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arg(&mut self) -> &mut ::protobuf::RepeatedField<Argument> {
        &mut self.arg
    }

    // Take field
    pub fn take_arg(&mut self) -> ::protobuf::RepeatedField<Argument> {
        ::std::mem::replace(&mut self.arg, ::protobuf::RepeatedField::new())
    }

    // optional .caffe2.DeviceOption device_option = 6;


    pub fn get_device_option(&self) -> &DeviceOption {
        self.device_option.as_ref().unwrap_or_else(|| <DeviceOption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device_option(&mut self) {
        self.device_option.clear();
    }

    pub fn has_device_option(&self) -> bool {
        self.device_option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_option(&mut self, v: DeviceOption) {
        self.device_option = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_option(&mut self) -> &mut DeviceOption {
        if self.device_option.is_none() {
            self.device_option.set_default();
        }
        self.device_option.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_option(&mut self) -> DeviceOption {
        self.device_option.take().unwrap_or_else(|| DeviceOption::new())
    }

    // optional string engine = 7;


    pub fn get_engine(&self) -> &str {
        match self.engine.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_engine(&mut self) {
        self.engine.clear();
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: ::std::string::String) {
        self.engine = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_engine(&mut self) -> &mut ::std::string::String {
        if self.engine.is_none() {
            self.engine.set_default();
        }
        self.engine.as_mut().unwrap()
    }

    // Take field
    pub fn take_engine(&mut self) -> ::std::string::String {
        self.engine.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string control_input = 8;


    pub fn get_control_input(&self) -> &[::std::string::String] {
        &self.control_input
    }
    pub fn clear_control_input(&mut self) {
        self.control_input.clear();
    }

    // Param is passed by value, moved
    pub fn set_control_input(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.control_input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_control_input(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.control_input
    }

    // Take field
    pub fn take_control_input(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.control_input, ::protobuf::RepeatedField::new())
    }

    // optional bool is_gradient_op = 9;


    pub fn get_is_gradient_op(&self) -> bool {
        self.is_gradient_op.unwrap_or(false)
    }
    pub fn clear_is_gradient_op(&mut self) {
        self.is_gradient_op = ::std::option::Option::None;
    }

    pub fn has_is_gradient_op(&self) -> bool {
        self.is_gradient_op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_gradient_op(&mut self, v: bool) {
        self.is_gradient_op = ::std::option::Option::Some(v);
    }

    // optional string debug_info = 10;


    pub fn get_debug_info(&self) -> &str {
        match self.debug_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_debug_info(&mut self) {
        self.debug_info.clear();
    }

    pub fn has_debug_info(&self) -> bool {
        self.debug_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_info(&mut self, v: ::std::string::String) {
        self.debug_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_info(&mut self) -> &mut ::std::string::String {
        if self.debug_info.is_none() {
            self.debug_info.set_default();
        }
        self.debug_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_info(&mut self) -> ::std::string::String {
        self.debug_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string domain = 11;


    pub fn get_domain(&self) -> &str {
        match self.domain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_domain(&mut self) {
        self.domain.clear();
    }

    pub fn has_domain(&self) -> bool {
        self.domain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain(&mut self, v: ::std::string::String) {
        self.domain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain(&mut self) -> &mut ::std::string::String {
        if self.domain.is_none() {
            self.domain.set_default();
        }
        self.domain.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain(&mut self) -> ::std::string::String {
        self.domain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 op_version = 12;


    pub fn get_op_version(&self) -> i64 {
        self.op_version.unwrap_or(0)
    }
    pub fn clear_op_version(&mut self) {
        self.op_version = ::std::option::Option::None;
    }

    pub fn has_op_version(&self) -> bool {
        self.op_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_version(&mut self, v: i64) {
        self.op_version = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OperatorDef {
    fn is_initialized(&self) -> bool {
        for v in &self.arg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.input)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.output)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arg)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_option)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.engine)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.control_input)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_gradient_op = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.debug_info)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.domain)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.op_version = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.input {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.output {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.arg {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.device_option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.engine.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        for value in &self.control_input {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.is_gradient_op {
            my_size += 2;
        }
        if let Some(ref v) = self.debug_info.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.domain.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.op_version {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.input {
            os.write_string(1, &v)?;
        };
        for v in &self.output {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.arg {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.device_option.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.engine.as_ref() {
            os.write_string(7, &v)?;
        }
        for v in &self.control_input {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.is_gradient_op {
            os.write_bool(9, v)?;
        }
        if let Some(ref v) = self.debug_info.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.domain.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.op_version {
            os.write_int64(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OperatorDef {
        OperatorDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "input",
                |m: &OperatorDef| { &m.input },
                |m: &mut OperatorDef| { &mut m.input },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "output",
                |m: &OperatorDef| { &m.output },
                |m: &mut OperatorDef| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OperatorDef| { &m.name },
                |m: &mut OperatorDef| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &OperatorDef| { &m.field_type },
                |m: &mut OperatorDef| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Argument>>(
                "arg",
                |m: &OperatorDef| { &m.arg },
                |m: &mut OperatorDef| { &mut m.arg },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceOption>>(
                "device_option",
                |m: &OperatorDef| { &m.device_option },
                |m: &mut OperatorDef| { &mut m.device_option },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "engine",
                |m: &OperatorDef| { &m.engine },
                |m: &mut OperatorDef| { &mut m.engine },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "control_input",
                |m: &OperatorDef| { &m.control_input },
                |m: &mut OperatorDef| { &mut m.control_input },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_gradient_op",
                |m: &OperatorDef| { &m.is_gradient_op },
                |m: &mut OperatorDef| { &mut m.is_gradient_op },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "debug_info",
                |m: &OperatorDef| { &m.debug_info },
                |m: &mut OperatorDef| { &mut m.debug_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "domain",
                |m: &OperatorDef| { &m.domain },
                |m: &mut OperatorDef| { &mut m.domain },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "op_version",
                |m: &OperatorDef| { &m.op_version },
                |m: &mut OperatorDef| { &mut m.op_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OperatorDef>(
                "OperatorDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OperatorDef {
        static instance: ::protobuf::rt::LazyV2<OperatorDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OperatorDef::new)
    }
}

impl ::protobuf::Clear for OperatorDef {
    fn clear(&mut self) {
        self.input.clear();
        self.output.clear();
        self.name.clear();
        self.field_type.clear();
        self.arg.clear();
        self.device_option.clear();
        self.engine.clear();
        self.control_input.clear();
        self.is_gradient_op = ::std::option::Option::None;
        self.debug_info.clear();
        self.domain.clear();
        self.op_version = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OperatorDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperatorDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MapFieldEntry {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    val: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MapFieldEntry {
    fn default() -> &'a MapFieldEntry {
        <MapFieldEntry as ::protobuf::Message>::default_instance()
    }
}

impl MapFieldEntry {
    pub fn new() -> MapFieldEntry {
        ::std::default::Default::default()
    }

    // required string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string val = 2;


    pub fn get_val(&self) -> &str {
        match self.val.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::string::String) {
        self.val = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val(&mut self) -> &mut ::std::string::String {
        if self.val.is_none() {
            self.val.set_default();
        }
        self.val.as_mut().unwrap()
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::string::String {
        self.val.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for MapFieldEntry {
    fn is_initialized(&self) -> bool {
        if self.key.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.val)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.val.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.val.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MapFieldEntry {
        MapFieldEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &MapFieldEntry| { &m.key },
                |m: &mut MapFieldEntry| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "val",
                |m: &MapFieldEntry| { &m.val },
                |m: &mut MapFieldEntry| { &mut m.val },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MapFieldEntry>(
                "MapFieldEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MapFieldEntry {
        static instance: ::protobuf::rt::LazyV2<MapFieldEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MapFieldEntry::new)
    }
}

impl ::protobuf::Clear for MapFieldEntry {
    fn clear(&mut self) {
        self.key.clear();
        self.val.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MapFieldEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapFieldEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BackendOptions {
    // message fields
    backend_name: ::protobuf::SingularField<::std::string::String>,
    pub option: ::protobuf::RepeatedField<MapFieldEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BackendOptions {
    fn default() -> &'a BackendOptions {
        <BackendOptions as ::protobuf::Message>::default_instance()
    }
}

impl BackendOptions {
    pub fn new() -> BackendOptions {
        ::std::default::Default::default()
    }

    // required string backend_name = 1;


    pub fn get_backend_name(&self) -> &str {
        match self.backend_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_backend_name(&mut self) {
        self.backend_name.clear();
    }

    pub fn has_backend_name(&self) -> bool {
        self.backend_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_backend_name(&mut self, v: ::std::string::String) {
        self.backend_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend_name(&mut self) -> &mut ::std::string::String {
        if self.backend_name.is_none() {
            self.backend_name.set_default();
        }
        self.backend_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_backend_name(&mut self) -> ::std::string::String {
        self.backend_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .caffe2.MapFieldEntry option = 2;


    pub fn get_option(&self) -> &[MapFieldEntry] {
        &self.option
    }
    pub fn clear_option(&mut self) {
        self.option.clear();
    }

    // Param is passed by value, moved
    pub fn set_option(&mut self, v: ::protobuf::RepeatedField<MapFieldEntry>) {
        self.option = v;
    }

    // Mutable pointer to the field.
    pub fn mut_option(&mut self) -> &mut ::protobuf::RepeatedField<MapFieldEntry> {
        &mut self.option
    }

    // Take field
    pub fn take_option(&mut self) -> ::protobuf::RepeatedField<MapFieldEntry> {
        ::std::mem::replace(&mut self.option, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BackendOptions {
    fn is_initialized(&self) -> bool {
        if self.backend_name.is_none() {
            return false;
        }
        for v in &self.option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.backend_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.option)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.backend_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.option {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.backend_name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.option {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BackendOptions {
        BackendOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backend_name",
                |m: &BackendOptions| { &m.backend_name },
                |m: &mut BackendOptions| { &mut m.backend_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MapFieldEntry>>(
                "option",
                |m: &BackendOptions| { &m.option },
                |m: &mut BackendOptions| { &mut m.option },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BackendOptions>(
                "BackendOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BackendOptions {
        static instance: ::protobuf::rt::LazyV2<BackendOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BackendOptions::new)
    }
}

impl ::protobuf::Clear for BackendOptions {
    fn clear(&mut self) {
        self.backend_name.clear();
        self.option.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BackendOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BackendOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PartitionInfo {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub device_id: ::std::vec::Vec<i32>,
    extra_info: ::protobuf::SingularField<::std::string::String>,
    pub backend_options: ::protobuf::RepeatedField<BackendOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PartitionInfo {
    fn default() -> &'a PartitionInfo {
        <PartitionInfo as ::protobuf::Message>::default_instance()
    }
}

impl PartitionInfo {
    pub fn new() -> PartitionInfo {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated int32 device_id = 2;


    pub fn get_device_id(&self) -> &[i32] {
        &self.device_id
    }
    pub fn clear_device_id(&mut self) {
        self.device_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_id(&mut self, v: ::std::vec::Vec<i32>) {
        self.device_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_id(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.device_id
    }

    // Take field
    pub fn take_device_id(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.device_id, ::std::vec::Vec::new())
    }

    // optional string extra_info = 3;


    pub fn get_extra_info(&self) -> &str {
        match self.extra_info.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_extra_info(&mut self) {
        self.extra_info.clear();
    }

    pub fn has_extra_info(&self) -> bool {
        self.extra_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extra_info(&mut self, v: ::std::string::String) {
        self.extra_info = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extra_info(&mut self) -> &mut ::std::string::String {
        if self.extra_info.is_none() {
            self.extra_info.set_default();
        }
        self.extra_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_extra_info(&mut self) -> ::std::string::String {
        self.extra_info.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .caffe2.BackendOptions backend_options = 4;


    pub fn get_backend_options(&self) -> &[BackendOptions] {
        &self.backend_options
    }
    pub fn clear_backend_options(&mut self) {
        self.backend_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_backend_options(&mut self, v: ::protobuf::RepeatedField<BackendOptions>) {
        self.backend_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_backend_options(&mut self) -> &mut ::protobuf::RepeatedField<BackendOptions> {
        &mut self.backend_options
    }

    // Take field
    pub fn take_backend_options(&mut self) -> ::protobuf::RepeatedField<BackendOptions> {
        ::std::mem::replace(&mut self.backend_options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PartitionInfo {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        for v in &self.backend_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.device_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.extra_info)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.backend_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.device_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.extra_info.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.backend_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.device_id {
            os.write_int32(2, *v)?;
        };
        if let Some(ref v) = self.extra_info.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.backend_options {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PartitionInfo {
        PartitionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PartitionInfo| { &m.name },
                |m: &mut PartitionInfo| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "device_id",
                |m: &PartitionInfo| { &m.device_id },
                |m: &mut PartitionInfo| { &mut m.device_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "extra_info",
                |m: &PartitionInfo| { &m.extra_info },
                |m: &mut PartitionInfo| { &mut m.extra_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BackendOptions>>(
                "backend_options",
                |m: &PartitionInfo| { &m.backend_options },
                |m: &mut PartitionInfo| { &mut m.backend_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PartitionInfo>(
                "PartitionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PartitionInfo {
        static instance: ::protobuf::rt::LazyV2<PartitionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PartitionInfo::new)
    }
}

impl ::protobuf::Clear for PartitionInfo {
    fn clear(&mut self) {
        self.name.clear();
        self.device_id.clear();
        self.extra_info.clear();
        self.backend_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PartitionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartitionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetDef {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub op: ::protobuf::RepeatedField<OperatorDef>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    num_workers: ::std::option::Option<i32>,
    pub device_option: ::protobuf::SingularPtrField<DeviceOption>,
    pub arg: ::protobuf::RepeatedField<Argument>,
    pub external_input: ::protobuf::RepeatedField<::std::string::String>,
    pub external_output: ::protobuf::RepeatedField<::std::string::String>,
    pub partition_info: ::protobuf::RepeatedField<PartitionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetDef {
    fn default() -> &'a NetDef {
        <NetDef as ::protobuf::Message>::default_instance()
    }
}

impl NetDef {
    pub fn new() -> NetDef {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .caffe2.OperatorDef op = 2;


    pub fn get_op(&self) -> &[OperatorDef] {
        &self.op
    }
    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::protobuf::RepeatedField<OperatorDef>) {
        self.op = v;
    }

    // Mutable pointer to the field.
    pub fn mut_op(&mut self) -> &mut ::protobuf::RepeatedField<OperatorDef> {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::protobuf::RepeatedField<OperatorDef> {
        ::std::mem::replace(&mut self.op, ::protobuf::RepeatedField::new())
    }

    // optional string type = 3;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 num_workers = 4;


    pub fn get_num_workers(&self) -> i32 {
        self.num_workers.unwrap_or(0)
    }
    pub fn clear_num_workers(&mut self) {
        self.num_workers = ::std::option::Option::None;
    }

    pub fn has_num_workers(&self) -> bool {
        self.num_workers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_workers(&mut self, v: i32) {
        self.num_workers = ::std::option::Option::Some(v);
    }

    // optional .caffe2.DeviceOption device_option = 5;


    pub fn get_device_option(&self) -> &DeviceOption {
        self.device_option.as_ref().unwrap_or_else(|| <DeviceOption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device_option(&mut self) {
        self.device_option.clear();
    }

    pub fn has_device_option(&self) -> bool {
        self.device_option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_option(&mut self, v: DeviceOption) {
        self.device_option = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_option(&mut self) -> &mut DeviceOption {
        if self.device_option.is_none() {
            self.device_option.set_default();
        }
        self.device_option.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_option(&mut self) -> DeviceOption {
        self.device_option.take().unwrap_or_else(|| DeviceOption::new())
    }

    // repeated .caffe2.Argument arg = 6;


    pub fn get_arg(&self) -> &[Argument] {
        &self.arg
    }
    pub fn clear_arg(&mut self) {
        self.arg.clear();
    }

    // Param is passed by value, moved
    pub fn set_arg(&mut self, v: ::protobuf::RepeatedField<Argument>) {
        self.arg = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arg(&mut self) -> &mut ::protobuf::RepeatedField<Argument> {
        &mut self.arg
    }

    // Take field
    pub fn take_arg(&mut self) -> ::protobuf::RepeatedField<Argument> {
        ::std::mem::replace(&mut self.arg, ::protobuf::RepeatedField::new())
    }

    // repeated string external_input = 7;


    pub fn get_external_input(&self) -> &[::std::string::String] {
        &self.external_input
    }
    pub fn clear_external_input(&mut self) {
        self.external_input.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_input(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.external_input = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_input(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.external_input
    }

    // Take field
    pub fn take_external_input(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.external_input, ::protobuf::RepeatedField::new())
    }

    // repeated string external_output = 8;


    pub fn get_external_output(&self) -> &[::std::string::String] {
        &self.external_output
    }
    pub fn clear_external_output(&mut self) {
        self.external_output.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_output(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.external_output = v;
    }

    // Mutable pointer to the field.
    pub fn mut_external_output(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.external_output
    }

    // Take field
    pub fn take_external_output(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.external_output, ::protobuf::RepeatedField::new())
    }

    // repeated .caffe2.PartitionInfo partition_info = 9;


    pub fn get_partition_info(&self) -> &[PartitionInfo] {
        &self.partition_info
    }
    pub fn clear_partition_info(&mut self) {
        self.partition_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_partition_info(&mut self, v: ::protobuf::RepeatedField<PartitionInfo>) {
        self.partition_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partition_info(&mut self) -> &mut ::protobuf::RepeatedField<PartitionInfo> {
        &mut self.partition_info
    }

    // Take field
    pub fn take_partition_info(&mut self) -> ::protobuf::RepeatedField<PartitionInfo> {
        ::std::mem::replace(&mut self.partition_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NetDef {
    fn is_initialized(&self) -> bool {
        for v in &self.op {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_option {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partition_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.op)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_workers = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_option)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arg)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.external_input)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.external_output)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.partition_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.op {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.num_workers {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.arg {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.external_input {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.external_output {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.partition_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.op {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.num_workers {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.device_option.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.arg {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.external_input {
            os.write_string(7, &v)?;
        };
        for v in &self.external_output {
            os.write_string(8, &v)?;
        };
        for v in &self.partition_info {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetDef {
        NetDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NetDef| { &m.name },
                |m: &mut NetDef| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OperatorDef>>(
                "op",
                |m: &NetDef| { &m.op },
                |m: &mut NetDef| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &NetDef| { &m.field_type },
                |m: &mut NetDef| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_workers",
                |m: &NetDef| { &m.num_workers },
                |m: &mut NetDef| { &mut m.num_workers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceOption>>(
                "device_option",
                |m: &NetDef| { &m.device_option },
                |m: &mut NetDef| { &mut m.device_option },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Argument>>(
                "arg",
                |m: &NetDef| { &m.arg },
                |m: &mut NetDef| { &mut m.arg },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "external_input",
                |m: &NetDef| { &m.external_input },
                |m: &mut NetDef| { &mut m.external_input },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "external_output",
                |m: &NetDef| { &m.external_output },
                |m: &mut NetDef| { &mut m.external_output },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PartitionInfo>>(
                "partition_info",
                |m: &NetDef| { &m.partition_info },
                |m: &mut NetDef| { &mut m.partition_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetDef>(
                "NetDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetDef {
        static instance: ::protobuf::rt::LazyV2<NetDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetDef::new)
    }
}

impl ::protobuf::Clear for NetDef {
    fn clear(&mut self) {
        self.name.clear();
        self.op.clear();
        self.field_type.clear();
        self.num_workers = ::std::option::Option::None;
        self.device_option.clear();
        self.arg.clear();
        self.external_input.clear();
        self.external_output.clear();
        self.partition_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutionStep {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub substep: ::protobuf::RepeatedField<ExecutionStep>,
    pub network: ::protobuf::RepeatedField<::std::string::String>,
    num_iter: ::std::option::Option<i64>,
    criteria_network: ::protobuf::SingularField<::std::string::String>,
    report_net: ::protobuf::SingularField<::std::string::String>,
    report_interval: ::std::option::Option<i32>,
    run_every_ms: ::std::option::Option<i64>,
    concurrent_substeps: ::std::option::Option<bool>,
    should_stop_blob: ::protobuf::SingularField<::std::string::String>,
    only_once: ::std::option::Option<bool>,
    create_workspace: ::std::option::Option<bool>,
    num_concurrent_instances: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionStep {
    fn default() -> &'a ExecutionStep {
        <ExecutionStep as ::protobuf::Message>::default_instance()
    }
}

impl ExecutionStep {
    pub fn new() -> ExecutionStep {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .caffe2.ExecutionStep substep = 2;


    pub fn get_substep(&self) -> &[ExecutionStep] {
        &self.substep
    }
    pub fn clear_substep(&mut self) {
        self.substep.clear();
    }

    // Param is passed by value, moved
    pub fn set_substep(&mut self, v: ::protobuf::RepeatedField<ExecutionStep>) {
        self.substep = v;
    }

    // Mutable pointer to the field.
    pub fn mut_substep(&mut self) -> &mut ::protobuf::RepeatedField<ExecutionStep> {
        &mut self.substep
    }

    // Take field
    pub fn take_substep(&mut self) -> ::protobuf::RepeatedField<ExecutionStep> {
        ::std::mem::replace(&mut self.substep, ::protobuf::RepeatedField::new())
    }

    // repeated string network = 3;


    pub fn get_network(&self) -> &[::std::string::String] {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.network = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.network, ::protobuf::RepeatedField::new())
    }

    // optional int64 num_iter = 4;


    pub fn get_num_iter(&self) -> i64 {
        self.num_iter.unwrap_or(0)
    }
    pub fn clear_num_iter(&mut self) {
        self.num_iter = ::std::option::Option::None;
    }

    pub fn has_num_iter(&self) -> bool {
        self.num_iter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_iter(&mut self, v: i64) {
        self.num_iter = ::std::option::Option::Some(v);
    }

    // optional string criteria_network = 5;


    pub fn get_criteria_network(&self) -> &str {
        match self.criteria_network.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_criteria_network(&mut self) {
        self.criteria_network.clear();
    }

    pub fn has_criteria_network(&self) -> bool {
        self.criteria_network.is_some()
    }

    // Param is passed by value, moved
    pub fn set_criteria_network(&mut self, v: ::std::string::String) {
        self.criteria_network = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_criteria_network(&mut self) -> &mut ::std::string::String {
        if self.criteria_network.is_none() {
            self.criteria_network.set_default();
        }
        self.criteria_network.as_mut().unwrap()
    }

    // Take field
    pub fn take_criteria_network(&mut self) -> ::std::string::String {
        self.criteria_network.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string report_net = 7;


    pub fn get_report_net(&self) -> &str {
        match self.report_net.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_report_net(&mut self) {
        self.report_net.clear();
    }

    pub fn has_report_net(&self) -> bool {
        self.report_net.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_net(&mut self, v: ::std::string::String) {
        self.report_net = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report_net(&mut self) -> &mut ::std::string::String {
        if self.report_net.is_none() {
            self.report_net.set_default();
        }
        self.report_net.as_mut().unwrap()
    }

    // Take field
    pub fn take_report_net(&mut self) -> ::std::string::String {
        self.report_net.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 report_interval = 8;


    pub fn get_report_interval(&self) -> i32 {
        self.report_interval.unwrap_or(0)
    }
    pub fn clear_report_interval(&mut self) {
        self.report_interval = ::std::option::Option::None;
    }

    pub fn has_report_interval(&self) -> bool {
        self.report_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_interval(&mut self, v: i32) {
        self.report_interval = ::std::option::Option::Some(v);
    }

    // optional int64 run_every_ms = 11;


    pub fn get_run_every_ms(&self) -> i64 {
        self.run_every_ms.unwrap_or(0)
    }
    pub fn clear_run_every_ms(&mut self) {
        self.run_every_ms = ::std::option::Option::None;
    }

    pub fn has_run_every_ms(&self) -> bool {
        self.run_every_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_run_every_ms(&mut self, v: i64) {
        self.run_every_ms = ::std::option::Option::Some(v);
    }

    // optional bool concurrent_substeps = 6;


    pub fn get_concurrent_substeps(&self) -> bool {
        self.concurrent_substeps.unwrap_or(false)
    }
    pub fn clear_concurrent_substeps(&mut self) {
        self.concurrent_substeps = ::std::option::Option::None;
    }

    pub fn has_concurrent_substeps(&self) -> bool {
        self.concurrent_substeps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_concurrent_substeps(&mut self, v: bool) {
        self.concurrent_substeps = ::std::option::Option::Some(v);
    }

    // optional string should_stop_blob = 9;


    pub fn get_should_stop_blob(&self) -> &str {
        match self.should_stop_blob.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_should_stop_blob(&mut self) {
        self.should_stop_blob.clear();
    }

    pub fn has_should_stop_blob(&self) -> bool {
        self.should_stop_blob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_should_stop_blob(&mut self, v: ::std::string::String) {
        self.should_stop_blob = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_should_stop_blob(&mut self) -> &mut ::std::string::String {
        if self.should_stop_blob.is_none() {
            self.should_stop_blob.set_default();
        }
        self.should_stop_blob.as_mut().unwrap()
    }

    // Take field
    pub fn take_should_stop_blob(&mut self) -> ::std::string::String {
        self.should_stop_blob.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool only_once = 10;


    pub fn get_only_once(&self) -> bool {
        self.only_once.unwrap_or(false)
    }
    pub fn clear_only_once(&mut self) {
        self.only_once = ::std::option::Option::None;
    }

    pub fn has_only_once(&self) -> bool {
        self.only_once.is_some()
    }

    // Param is passed by value, moved
    pub fn set_only_once(&mut self, v: bool) {
        self.only_once = ::std::option::Option::Some(v);
    }

    // optional bool create_workspace = 12;


    pub fn get_create_workspace(&self) -> bool {
        self.create_workspace.unwrap_or(false)
    }
    pub fn clear_create_workspace(&mut self) {
        self.create_workspace = ::std::option::Option::None;
    }

    pub fn has_create_workspace(&self) -> bool {
        self.create_workspace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_create_workspace(&mut self, v: bool) {
        self.create_workspace = ::std::option::Option::Some(v);
    }

    // optional int32 num_concurrent_instances = 13;


    pub fn get_num_concurrent_instances(&self) -> i32 {
        self.num_concurrent_instances.unwrap_or(0)
    }
    pub fn clear_num_concurrent_instances(&mut self) {
        self.num_concurrent_instances = ::std::option::Option::None;
    }

    pub fn has_num_concurrent_instances(&self) -> bool {
        self.num_concurrent_instances.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_concurrent_instances(&mut self, v: i32) {
        self.num_concurrent_instances = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ExecutionStep {
    fn is_initialized(&self) -> bool {
        for v in &self.substep {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.substep)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.network)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_iter = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.criteria_network)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.report_net)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.report_interval = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.run_every_ms = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.concurrent_substeps = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.should_stop_blob)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.only_once = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.create_workspace = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_concurrent_instances = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.substep {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.network {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.num_iter {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.criteria_network.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.report_net.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.report_interval {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.run_every_ms {
            my_size += ::protobuf::rt::value_size(11, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.concurrent_substeps {
            my_size += 2;
        }
        if let Some(ref v) = self.should_stop_blob.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.only_once {
            my_size += 2;
        }
        if let Some(v) = self.create_workspace {
            my_size += 2;
        }
        if let Some(v) = self.num_concurrent_instances {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.substep {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.network {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.num_iter {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.criteria_network.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.report_net.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.report_interval {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.run_every_ms {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.concurrent_substeps {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.should_stop_blob.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.only_once {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.create_workspace {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.num_concurrent_instances {
            os.write_int32(13, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecutionStep {
        ExecutionStep::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ExecutionStep| { &m.name },
                |m: &mut ExecutionStep| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutionStep>>(
                "substep",
                |m: &ExecutionStep| { &m.substep },
                |m: &mut ExecutionStep| { &mut m.substep },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "network",
                |m: &ExecutionStep| { &m.network },
                |m: &mut ExecutionStep| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_iter",
                |m: &ExecutionStep| { &m.num_iter },
                |m: &mut ExecutionStep| { &mut m.num_iter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "criteria_network",
                |m: &ExecutionStep| { &m.criteria_network },
                |m: &mut ExecutionStep| { &mut m.criteria_network },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "report_net",
                |m: &ExecutionStep| { &m.report_net },
                |m: &mut ExecutionStep| { &mut m.report_net },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "report_interval",
                |m: &ExecutionStep| { &m.report_interval },
                |m: &mut ExecutionStep| { &mut m.report_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "run_every_ms",
                |m: &ExecutionStep| { &m.run_every_ms },
                |m: &mut ExecutionStep| { &mut m.run_every_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "concurrent_substeps",
                |m: &ExecutionStep| { &m.concurrent_substeps },
                |m: &mut ExecutionStep| { &mut m.concurrent_substeps },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "should_stop_blob",
                |m: &ExecutionStep| { &m.should_stop_blob },
                |m: &mut ExecutionStep| { &mut m.should_stop_blob },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "only_once",
                |m: &ExecutionStep| { &m.only_once },
                |m: &mut ExecutionStep| { &mut m.only_once },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "create_workspace",
                |m: &ExecutionStep| { &m.create_workspace },
                |m: &mut ExecutionStep| { &mut m.create_workspace },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_concurrent_instances",
                |m: &ExecutionStep| { &m.num_concurrent_instances },
                |m: &mut ExecutionStep| { &mut m.num_concurrent_instances },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecutionStep>(
                "ExecutionStep",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecutionStep {
        static instance: ::protobuf::rt::LazyV2<ExecutionStep> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecutionStep::new)
    }
}

impl ::protobuf::Clear for ExecutionStep {
    fn clear(&mut self) {
        self.name.clear();
        self.substep.clear();
        self.network.clear();
        self.num_iter = ::std::option::Option::None;
        self.criteria_network.clear();
        self.report_net.clear();
        self.report_interval = ::std::option::Option::None;
        self.run_every_ms = ::std::option::Option::None;
        self.concurrent_substeps = ::std::option::Option::None;
        self.should_stop_blob.clear();
        self.only_once = ::std::option::Option::None;
        self.create_workspace = ::std::option::Option::None;
        self.num_concurrent_instances = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionStep {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionStep {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PlanDef {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub network: ::protobuf::RepeatedField<NetDef>,
    pub execution_step: ::protobuf::RepeatedField<ExecutionStep>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PlanDef {
    fn default() -> &'a PlanDef {
        <PlanDef as ::protobuf::Message>::default_instance()
    }
}

impl PlanDef {
    pub fn new() -> PlanDef {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .caffe2.NetDef network = 2;


    pub fn get_network(&self) -> &[NetDef] {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::protobuf::RepeatedField<NetDef>) {
        self.network = v;
    }

    // Mutable pointer to the field.
    pub fn mut_network(&mut self) -> &mut ::protobuf::RepeatedField<NetDef> {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::protobuf::RepeatedField<NetDef> {
        ::std::mem::replace(&mut self.network, ::protobuf::RepeatedField::new())
    }

    // repeated .caffe2.ExecutionStep execution_step = 3;


    pub fn get_execution_step(&self) -> &[ExecutionStep] {
        &self.execution_step
    }
    pub fn clear_execution_step(&mut self) {
        self.execution_step.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_step(&mut self, v: ::protobuf::RepeatedField<ExecutionStep>) {
        self.execution_step = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execution_step(&mut self) -> &mut ::protobuf::RepeatedField<ExecutionStep> {
        &mut self.execution_step
    }

    // Take field
    pub fn take_execution_step(&mut self) -> ::protobuf::RepeatedField<ExecutionStep> {
        ::std::mem::replace(&mut self.execution_step, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PlanDef {
    fn is_initialized(&self) -> bool {
        for v in &self.network {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.execution_step {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.network)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.execution_step)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.network {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.execution_step {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.network {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.execution_step {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PlanDef {
        PlanDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PlanDef| { &m.name },
                |m: &mut PlanDef| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetDef>>(
                "network",
                |m: &PlanDef| { &m.network },
                |m: &mut PlanDef| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutionStep>>(
                "execution_step",
                |m: &PlanDef| { &m.execution_step },
                |m: &mut PlanDef| { &mut m.execution_step },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PlanDef>(
                "PlanDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PlanDef {
        static instance: ::protobuf::rt::LazyV2<PlanDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PlanDef::new)
    }
}

impl ::protobuf::Clear for PlanDef {
    fn clear(&mut self) {
        self.name.clear();
        self.network.clear();
        self.execution_step.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PlanDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlanDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlobProto {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    pub tensor: ::protobuf::SingularPtrField<TensorProto>,
    content: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    pub qtensor: ::protobuf::SingularPtrField<QTensorProto>,
    content_num_chunks: ::std::option::Option<i32>,
    content_chunk_id: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlobProto {
    fn default() -> &'a BlobProto {
        <BlobProto as ::protobuf::Message>::default_instance()
    }
}

impl BlobProto {
    pub fn new() -> BlobProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 2;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .caffe2.TensorProto tensor = 3;


    pub fn get_tensor(&self) -> &TensorProto {
        self.tensor.as_ref().unwrap_or_else(|| <TensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tensor(&mut self) {
        self.tensor.clear();
    }

    pub fn has_tensor(&self) -> bool {
        self.tensor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tensor(&mut self, v: TensorProto) {
        self.tensor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tensor(&mut self) -> &mut TensorProto {
        if self.tensor.is_none() {
            self.tensor.set_default();
        }
        self.tensor.as_mut().unwrap()
    }

    // Take field
    pub fn take_tensor(&mut self) -> TensorProto {
        self.tensor.take().unwrap_or_else(|| TensorProto::new())
    }

    // optional bytes content = 4;


    pub fn get_content(&self) -> &[u8] {
        match self.content.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    pub fn has_content(&self) -> bool {
        self.content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.content.is_none() {
            self.content.set_default();
        }
        self.content.as_mut().unwrap()
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        self.content.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional .caffe2.QTensorProto qtensor = 5;


    pub fn get_qtensor(&self) -> &QTensorProto {
        self.qtensor.as_ref().unwrap_or_else(|| <QTensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_qtensor(&mut self) {
        self.qtensor.clear();
    }

    pub fn has_qtensor(&self) -> bool {
        self.qtensor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qtensor(&mut self, v: QTensorProto) {
        self.qtensor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qtensor(&mut self) -> &mut QTensorProto {
        if self.qtensor.is_none() {
            self.qtensor.set_default();
        }
        self.qtensor.as_mut().unwrap()
    }

    // Take field
    pub fn take_qtensor(&mut self) -> QTensorProto {
        self.qtensor.take().unwrap_or_else(|| QTensorProto::new())
    }

    // optional int32 content_num_chunks = 6;


    pub fn get_content_num_chunks(&self) -> i32 {
        self.content_num_chunks.unwrap_or(0)
    }
    pub fn clear_content_num_chunks(&mut self) {
        self.content_num_chunks = ::std::option::Option::None;
    }

    pub fn has_content_num_chunks(&self) -> bool {
        self.content_num_chunks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_num_chunks(&mut self, v: i32) {
        self.content_num_chunks = ::std::option::Option::Some(v);
    }

    // optional int32 content_chunk_id = 7;


    pub fn get_content_chunk_id(&self) -> i32 {
        self.content_chunk_id.unwrap_or(0)
    }
    pub fn clear_content_chunk_id(&mut self) {
        self.content_chunk_id = ::std::option::Option::None;
    }

    pub fn has_content_chunk_id(&self) -> bool {
        self.content_chunk_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_content_chunk_id(&mut self, v: i32) {
        self.content_chunk_id = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlobProto {
    fn is_initialized(&self) -> bool {
        for v in &self.tensor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.qtensor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tensor)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.content)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.qtensor)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.content_num_chunks = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.content_chunk_id = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.tensor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.content.as_ref() {
            my_size += ::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(ref v) = self.qtensor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.content_num_chunks {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.content_chunk_id {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.tensor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.content.as_ref() {
            os.write_bytes(4, &v)?;
        }
        if let Some(ref v) = self.qtensor.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.content_num_chunks {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.content_chunk_id {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlobProto {
        BlobProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &BlobProto| { &m.name },
                |m: &mut BlobProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &BlobProto| { &m.field_type },
                |m: &mut BlobProto| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TensorProto>>(
                "tensor",
                |m: &BlobProto| { &m.tensor },
                |m: &mut BlobProto| { &mut m.tensor },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &BlobProto| { &m.content },
                |m: &mut BlobProto| { &mut m.content },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QTensorProto>>(
                "qtensor",
                |m: &BlobProto| { &m.qtensor },
                |m: &mut BlobProto| { &mut m.qtensor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "content_num_chunks",
                |m: &BlobProto| { &m.content_num_chunks },
                |m: &mut BlobProto| { &mut m.content_num_chunks },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "content_chunk_id",
                |m: &BlobProto| { &m.content_chunk_id },
                |m: &mut BlobProto| { &mut m.content_chunk_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlobProto>(
                "BlobProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlobProto {
        static instance: ::protobuf::rt::LazyV2<BlobProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlobProto::new)
    }
}

impl ::protobuf::Clear for BlobProto {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type.clear();
        self.tensor.clear();
        self.content.clear();
        self.qtensor.clear();
        self.content_num_chunks = ::std::option::Option::None;
        self.content_chunk_id = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlobProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlobProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DBReaderProto {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    source: ::protobuf::SingularField<::std::string::String>,
    db_type: ::protobuf::SingularField<::std::string::String>,
    key: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DBReaderProto {
    fn default() -> &'a DBReaderProto {
        <DBReaderProto as ::protobuf::Message>::default_instance()
    }
}

impl DBReaderProto {
    pub fn new() -> DBReaderProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string source = 2;


    pub fn get_source(&self) -> &str {
        match self.source.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: ::std::string::String) {
        self.source = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut ::std::string::String {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> ::std::string::String {
        self.source.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string db_type = 3;


    pub fn get_db_type(&self) -> &str {
        match self.db_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_db_type(&mut self) {
        self.db_type.clear();
    }

    pub fn has_db_type(&self) -> bool {
        self.db_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_db_type(&mut self, v: ::std::string::String) {
        self.db_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_db_type(&mut self) -> &mut ::std::string::String {
        if self.db_type.is_none() {
            self.db_type.set_default();
        }
        self.db_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_db_type(&mut self) -> ::std::string::String {
        self.db_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string key = 4;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for DBReaderProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.source)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.db_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.db_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.db_type.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DBReaderProto {
        DBReaderProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DBReaderProto| { &m.name },
                |m: &mut DBReaderProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source",
                |m: &DBReaderProto| { &m.source },
                |m: &mut DBReaderProto| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "db_type",
                |m: &DBReaderProto| { &m.db_type },
                |m: &mut DBReaderProto| { &mut m.db_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &DBReaderProto| { &m.key },
                |m: &mut DBReaderProto| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DBReaderProto>(
                "DBReaderProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DBReaderProto {
        static instance: ::protobuf::rt::LazyV2<DBReaderProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DBReaderProto::new)
    }
}

impl ::protobuf::Clear for DBReaderProto {
    fn clear(&mut self) {
        self.name.clear();
        self.source.clear();
        self.db_type.clear();
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DBReaderProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DBReaderProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BlobSerializationOptions {
    // message fields
    blob_name_regex: ::protobuf::SingularField<::std::string::String>,
    chunk_size: ::std::option::Option<i64>,
    float_format: ::std::option::Option<BlobSerializationOptions_FloatFormat>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlobSerializationOptions {
    fn default() -> &'a BlobSerializationOptions {
        <BlobSerializationOptions as ::protobuf::Message>::default_instance()
    }
}

impl BlobSerializationOptions {
    pub fn new() -> BlobSerializationOptions {
        ::std::default::Default::default()
    }

    // optional string blob_name_regex = 1;


    pub fn get_blob_name_regex(&self) -> &str {
        match self.blob_name_regex.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_blob_name_regex(&mut self) {
        self.blob_name_regex.clear();
    }

    pub fn has_blob_name_regex(&self) -> bool {
        self.blob_name_regex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blob_name_regex(&mut self, v: ::std::string::String) {
        self.blob_name_regex = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blob_name_regex(&mut self) -> &mut ::std::string::String {
        if self.blob_name_regex.is_none() {
            self.blob_name_regex.set_default();
        }
        self.blob_name_regex.as_mut().unwrap()
    }

    // Take field
    pub fn take_blob_name_regex(&mut self) -> ::std::string::String {
        self.blob_name_regex.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 chunk_size = 2;


    pub fn get_chunk_size(&self) -> i64 {
        self.chunk_size.unwrap_or(0)
    }
    pub fn clear_chunk_size(&mut self) {
        self.chunk_size = ::std::option::Option::None;
    }

    pub fn has_chunk_size(&self) -> bool {
        self.chunk_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chunk_size(&mut self, v: i64) {
        self.chunk_size = ::std::option::Option::Some(v);
    }

    // optional .caffe2.BlobSerializationOptions.FloatFormat float_format = 3;


    pub fn get_float_format(&self) -> BlobSerializationOptions_FloatFormat {
        self.float_format.unwrap_or(BlobSerializationOptions_FloatFormat::FLOAT_DEFAULT)
    }
    pub fn clear_float_format(&mut self) {
        self.float_format = ::std::option::Option::None;
    }

    pub fn has_float_format(&self) -> bool {
        self.float_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_float_format(&mut self, v: BlobSerializationOptions_FloatFormat) {
        self.float_format = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BlobSerializationOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.blob_name_regex)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.chunk_size = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.float_format, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.blob_name_regex.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.chunk_size {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.float_format {
            my_size += ::protobuf::rt::enum_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.blob_name_regex.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.chunk_size {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.float_format {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlobSerializationOptions {
        BlobSerializationOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "blob_name_regex",
                |m: &BlobSerializationOptions| { &m.blob_name_regex },
                |m: &mut BlobSerializationOptions| { &mut m.blob_name_regex },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "chunk_size",
                |m: &BlobSerializationOptions| { &m.chunk_size },
                |m: &mut BlobSerializationOptions| { &mut m.chunk_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<BlobSerializationOptions_FloatFormat>>(
                "float_format",
                |m: &BlobSerializationOptions| { &m.float_format },
                |m: &mut BlobSerializationOptions| { &mut m.float_format },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlobSerializationOptions>(
                "BlobSerializationOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BlobSerializationOptions {
        static instance: ::protobuf::rt::LazyV2<BlobSerializationOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BlobSerializationOptions::new)
    }
}

impl ::protobuf::Clear for BlobSerializationOptions {
    fn clear(&mut self) {
        self.blob_name_regex.clear();
        self.chunk_size = ::std::option::Option::None;
        self.float_format = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlobSerializationOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlobSerializationOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum BlobSerializationOptions_FloatFormat {
    FLOAT_DEFAULT = 0,
    FLOAT_PROTOBUF = 1,
    FLOAT_BFLOAT16 = 2,
}

impl ::protobuf::ProtobufEnum for BlobSerializationOptions_FloatFormat {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BlobSerializationOptions_FloatFormat> {
        match value {
            0 => ::std::option::Option::Some(BlobSerializationOptions_FloatFormat::FLOAT_DEFAULT),
            1 => ::std::option::Option::Some(BlobSerializationOptions_FloatFormat::FLOAT_PROTOBUF),
            2 => ::std::option::Option::Some(BlobSerializationOptions_FloatFormat::FLOAT_BFLOAT16),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [BlobSerializationOptions_FloatFormat] = &[
            BlobSerializationOptions_FloatFormat::FLOAT_DEFAULT,
            BlobSerializationOptions_FloatFormat::FLOAT_PROTOBUF,
            BlobSerializationOptions_FloatFormat::FLOAT_BFLOAT16,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<BlobSerializationOptions_FloatFormat>("BlobSerializationOptions.FloatFormat", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for BlobSerializationOptions_FloatFormat {
}

impl ::std::default::Default for BlobSerializationOptions_FloatFormat {
    fn default() -> Self {
        BlobSerializationOptions_FloatFormat::FLOAT_DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for BlobSerializationOptions_FloatFormat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SerializationOptions {
    // message fields
    pub options: ::protobuf::RepeatedField<BlobSerializationOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SerializationOptions {
    fn default() -> &'a SerializationOptions {
        <SerializationOptions as ::protobuf::Message>::default_instance()
    }
}

impl SerializationOptions {
    pub fn new() -> SerializationOptions {
        ::std::default::Default::default()
    }

    // repeated .caffe2.BlobSerializationOptions options = 1;


    pub fn get_options(&self) -> &[BlobSerializationOptions] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<BlobSerializationOptions>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<BlobSerializationOptions> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<BlobSerializationOptions> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SerializationOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.options {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SerializationOptions {
        SerializationOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BlobSerializationOptions>>(
                "options",
                |m: &SerializationOptions| { &m.options },
                |m: &mut SerializationOptions| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SerializationOptions>(
                "SerializationOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SerializationOptions {
        static instance: ::protobuf::rt::LazyV2<SerializationOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SerializationOptions::new)
    }
}

impl ::protobuf::Clear for SerializationOptions {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SerializationOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SerializationOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DeviceTypeProto {
    PROTO_CPU = 0,
    PROTO_CUDA = 1,
    PROTO_MKLDNN = 2,
    PROTO_OPENGL = 3,
    PROTO_OPENCL = 4,
    PROTO_IDEEP = 5,
    PROTO_HIP = 6,
    PROTO_FPGA = 7,
    PROTO_MSNPU = 8,
    PROTO_XLA = 9,
    PROTO_MLC = 10,
    PROTO_COMPILE_TIME_MAX_DEVICE_TYPES = 11,
}

impl ::protobuf::ProtobufEnum for DeviceTypeProto {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DeviceTypeProto> {
        match value {
            0 => ::std::option::Option::Some(DeviceTypeProto::PROTO_CPU),
            1 => ::std::option::Option::Some(DeviceTypeProto::PROTO_CUDA),
            2 => ::std::option::Option::Some(DeviceTypeProto::PROTO_MKLDNN),
            3 => ::std::option::Option::Some(DeviceTypeProto::PROTO_OPENGL),
            4 => ::std::option::Option::Some(DeviceTypeProto::PROTO_OPENCL),
            5 => ::std::option::Option::Some(DeviceTypeProto::PROTO_IDEEP),
            6 => ::std::option::Option::Some(DeviceTypeProto::PROTO_HIP),
            7 => ::std::option::Option::Some(DeviceTypeProto::PROTO_FPGA),
            8 => ::std::option::Option::Some(DeviceTypeProto::PROTO_MSNPU),
            9 => ::std::option::Option::Some(DeviceTypeProto::PROTO_XLA),
            10 => ::std::option::Option::Some(DeviceTypeProto::PROTO_MLC),
            11 => ::std::option::Option::Some(DeviceTypeProto::PROTO_COMPILE_TIME_MAX_DEVICE_TYPES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DeviceTypeProto] = &[
            DeviceTypeProto::PROTO_CPU,
            DeviceTypeProto::PROTO_CUDA,
            DeviceTypeProto::PROTO_MKLDNN,
            DeviceTypeProto::PROTO_OPENGL,
            DeviceTypeProto::PROTO_OPENCL,
            DeviceTypeProto::PROTO_IDEEP,
            DeviceTypeProto::PROTO_HIP,
            DeviceTypeProto::PROTO_FPGA,
            DeviceTypeProto::PROTO_MSNPU,
            DeviceTypeProto::PROTO_XLA,
            DeviceTypeProto::PROTO_MLC,
            DeviceTypeProto::PROTO_COMPILE_TIME_MAX_DEVICE_TYPES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DeviceTypeProto>("DeviceTypeProto", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DeviceTypeProto {
}

impl ::std::default::Default for DeviceTypeProto {
    fn default() -> Self {
        DeviceTypeProto::PROTO_CPU
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceTypeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!pytorch/caffe2/proto/caffe2.proto\x12\x06caffe2\"\xb4\x06\n\x0bTensor\
    Proto\x12\x12\n\x04dims\x18\x01\x20\x03(\x03R\x04dims\x12@\n\tdata_type\
    \x18\x02\x20\x01(\x0e2\x1c.caffe2.TensorProto.DataType:\x05FLOATR\x08dat\
    aType\x12\"\n\x0bdata_format\x18\x0f\x20\x01(\r:\x010R\ndataFormat\x12!\
    \n\nfloat_data\x18\x03\x20\x03(\x02R\tfloatDataB\x02\x10\x01\x12!\n\nint\
    32_data\x18\x04\x20\x03(\x05R\tint32DataB\x02\x10\x01\x12\x1b\n\tbyte_da\
    ta\x18\x05\x20\x01(\x0cR\x08byteData\x12\x1f\n\x0bstring_data\x18\x06\
    \x20\x03(\x0cR\nstringData\x12#\n\x0bdouble_data\x18\t\x20\x03(\x01R\ndo\
    ubleDataB\x02\x10\x01\x12!\n\nint64_data\x18\n\x20\x03(\x03R\tint64DataB\
    \x02\x10\x01\x12\x19\n\x08raw_data\x18\r\x20\x01(\x0cR\x07rawData\x12\
    \x12\n\x04name\x18\x07\x20\x01(\tR\x04name\x129\n\rdevice_detail\x18\x08\
    \x20\x01(\x0b2\x14.caffe2.DeviceOptionR\x0cdeviceDetail\x125\n\x07segmen\
    t\x18\x0b\x20\x01(\x0b2\x1b.caffe2.TensorProto.SegmentR\x07segment\x1a1\
    \n\x07Segment\x12\x14\n\x05begin\x18\x01\x20\x02(\x03R\x05begin\x12\x10\
    \n\x03end\x18\x02\x20\x02(\x03R\x03end\"\xcf\x01\n\x08DataType\x12\r\n\t\
    UNDEFINED\x10\0\x12\t\n\x05FLOAT\x10\x01\x12\t\n\x05INT32\x10\x02\x12\
    \x08\n\x04BYTE\x10\x03\x12\n\n\x06STRING\x10\x04\x12\x08\n\x04BOOL\x10\
    \x05\x12\t\n\x05UINT8\x10\x06\x12\x08\n\x04INT8\x10\x07\x12\n\n\x06UINT1\
    6\x10\x08\x12\t\n\x05INT16\x10\t\x12\t\n\x05INT64\x10\n\x12\x0b\n\x07FLO\
    AT16\x10\x0c\x12\n\n\x06DOUBLE\x10\r\x12\x17\n\x13ZERO_COLLISION_HASH\
    \x10\x0e\x12\x15\n\x11REBATCHING_BUFFER\x10\x0f\"9\n\x13SerializationFor\
    mat\x12\x10\n\x0cFMT_PROTOBUF\x10\0\x12\x10\n\x0cFMT_BFLOAT16\x10\x01\"\
    \xe5\x02\n\x0cQTensorProto\x12\x12\n\x04dims\x18\x01\x20\x03(\x03R\x04di\
    ms\x12\x1c\n\tprecision\x18\x02\x20\x02(\x05R\tprecision\x12\x14\n\x05sc\
    ale\x18\x03\x20\x02(\x01R\x05scale\x12\x12\n\x04bias\x18\x04\x20\x02(\
    \x01R\x04bias\x12\x1b\n\tis_signed\x18\x05\x20\x02(\x08R\x08isSigned\x12\
    \x16\n\x04data\x18\x06\x20\x03(\x05R\x04dataB\x02\x10\x01\x12\x12\n\x04n\
    ame\x18\x07\x20\x01(\tR\x04name\x12@\n\tdata_type\x18\x08\x20\x01(\x0e2\
    \x1c.caffe2.TensorProto.DataType:\x05INT32R\x08dataType\x12\x16\n\x06sca\
    les\x18\t\x20\x03(\x01R\x06scales\x12\x16\n\x06biases\x18\n\x20\x03(\x01\
    R\x06biases\x12\x12\n\x04axis\x18\x0b\x20\x01(\x05R\x04axis\x12*\n\ris_m\
    ultiparam\x18\x0c\x20\x01(\x08:\x05falseR\x0cisMultiparam\";\n\x0cTensor\
    Protos\x12+\n\x06protos\x18\x01\x20\x03(\x0b2\x13.caffe2.TensorProtoR\
    \x06protos\"\xc6\x01\n\x0bTensorShape\x12\x12\n\x04dims\x18\x01\x20\x03(\
    \x03R\x04dims\x12@\n\tdata_type\x18\x02\x20\x01(\x0e2\x1c.caffe2.TensorP\
    roto.DataType:\x05FLOATR\x08dataType\x12!\n\x0cunknown_dims\x18\x03\x20\
    \x03(\x05R\x0bunknownDims\x12*\n\runknown_shape\x18\x04\x20\x01(\x08:\
    \x05falseR\x0cunknownShape\x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04name\
    \";\n\x0cTensorShapes\x12+\n\x06shapes\x18\x01\x20\x03(\x0b2\x13.caffe2.\
    TensorShapeR\x06shapes\"\xcc\x02\n\x10TensorBoundShape\x12)\n\x05shape\
    \x18\x01\x20\x01(\x0b2\x13.caffe2.TensorShapeR\x05shape\x12;\n\x08dim_ty\
    pe\x18\x02\x20\x03(\x0e2\x20.caffe2.TensorBoundShape.DimTypeR\x07dimType\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12$\n\x0eshape_is_final\
    \x18\x04\x20\x01(\x08R\x0cshapeIsFinal\"\x95\x01\n\x07DimType\x12\x0b\n\
    \x07UNKNOWN\x10\0\x12\x0c\n\x08CONSTANT\x10\x01\x12\t\n\x05BATCH\x10\x02\
    \x12\x18\n\x14BATCH_OF_FEATURE_MAX\x10\x03\x12\x20\n\x1cBATCH_OF_FEATURE\
    _MAX_DEFAULT\x10\x04\x12\x0f\n\x0bFEATURE_MAX\x10\x05\x12\x17\n\x13FEATU\
    RE_MAX_DEFAULT\x10\x06\"\x93\x01\n\x11TensorBoundShapes\x120\n\x06shapes\
    \x18\x01\x20\x03(\x0b2\x18.caffe2.TensorBoundShapeR\x06shapes\x12$\n\x0e\
    max_batch_size\x18\x02\x20\x01(\x03R\x0cmaxBatchSize\x12&\n\x0fmax_featu\
    re_len\x18\x03\x20\x01(\x03R\rmaxFeatureLen\"\xdd\x01\n\tAOTConfig\x12$\
    \n\x0emax_batch_size\x18\x01\x20\x02(\x03R\x0cmaxBatchSize\x12\x20\n\x0c\
    max_seq_size\x18\x02\x20\x02(\x03R\nmaxSeqSize\x12,\n\x12in_batch_broadc\
    ast\x18\x03\x20\x02(\x08R\x10inBatchBroadcast\x122\n\x15onnxifi_blacklis\
    t_ops\x18\x04\x20\x01(\tR\x13onnxifiBlacklistOps\x12&\n\x0fonnxifi_min_o\
    ps\x18\x05\x20\x01(\x05R\ronnxifiMinOps\"\xd4\x02\n\x08Argument\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x0c\n\x01f\x18\x02\x20\x01(\
    \x02R\x01f\x12\x0c\n\x01i\x18\x03\x20\x01(\x03R\x01i\x12\x0c\n\x01s\x18\
    \x04\x20\x01(\x0cR\x01s\x12!\n\x01t\x18\n\x20\x01(\x0b2\x13.caffe2.Tenso\
    rProtoR\x01t\x12\x1c\n\x01n\x18\x08\x20\x01(\x0b2\x0e.caffe2.NetDefR\x01\
    n\x12\x16\n\x06floats\x18\x05\x20\x03(\x02R\x06floats\x12\x12\n\x04ints\
    \x18\x06\x20\x03(\x03R\x04ints\x12\x18\n\x07strings\x18\x07\x20\x03(\x0c\
    R\x07strings\x12-\n\x07tensors\x18\x0b\x20\x03(\x0b2\x13.caffe2.TensorPr\
    otoR\x07tensors\x12\"\n\x04nets\x18\t\x20\x03(\x0b2\x0e.caffe2.NetDefR\
    \x04nets\x120\n\x08qtensors\x18\x0c\x20\x03(\x0b2\x14.caffe2.QTensorProt\
    oR\x08qtensors\"\xce\x01\n\x0cDeviceOption\x12\"\n\x0bdevice_type\x18\
    \x01\x20\x01(\x05:\x010R\ndeviceType\x12\x1b\n\tdevice_id\x18\x02\x20\
    \x01(\x05R\x08deviceId\x12\x1f\n\x0brandom_seed\x18\x03\x20\x01(\rR\nran\
    domSeed\x12\x1b\n\tnode_name\x18\x04\x20\x01(\tR\x08nodeName\x12\x20\n\
    \x0cnuma_node_id\x18\x05\x20\x01(\x05R\nnumaNodeId\x12\x1d\n\nextra_info\
    \x18\x06\x20\x03(\tR\textraInfo\"\x82\x03\n\x0bOperatorDef\x12\x14\n\x05\
    input\x18\x01\x20\x03(\tR\x05input\x12\x16\n\x06output\x18\x02\x20\x03(\
    \tR\x06output\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x12\n\
    \x04type\x18\x04\x20\x01(\tR\x04type\x12\"\n\x03arg\x18\x05\x20\x03(\x0b\
    2\x10.caffe2.ArgumentR\x03arg\x129\n\rdevice_option\x18\x06\x20\x01(\x0b\
    2\x14.caffe2.DeviceOptionR\x0cdeviceOption\x12\x16\n\x06engine\x18\x07\
    \x20\x01(\tR\x06engine\x12#\n\rcontrol_input\x18\x08\x20\x03(\tR\x0ccont\
    rolInput\x12+\n\x0eis_gradient_op\x18\t\x20\x01(\x08:\x05falseR\x0cisGra\
    dientOp\x12\x1d\n\ndebug_info\x18\n\x20\x01(\tR\tdebugInfo\x12\x16\n\x06\
    domain\x18\x0b\x20\x01(\tR\x06domain\x12\x1d\n\nop_version\x18\x0c\x20\
    \x01(\x03R\topVersion\"3\n\rMapFieldEntry\x12\x10\n\x03key\x18\x01\x20\
    \x02(\tR\x03key\x12\x10\n\x03val\x18\x02\x20\x02(\tR\x03val\"b\n\x0eBack\
    endOptions\x12!\n\x0cbackend_name\x18\x01\x20\x02(\tR\x0bbackendName\x12\
    -\n\x06option\x18\x02\x20\x03(\x0b2\x15.caffe2.MapFieldEntryR\x06option\
    \"\xa0\x01\n\rPartitionInfo\x12\x12\n\x04name\x18\x01\x20\x02(\tR\x04nam\
    e\x12\x1b\n\tdevice_id\x18\x02\x20\x03(\x05R\x08deviceId\x12\x1d\n\nextr\
    a_info\x18\x03\x20\x01(\tR\textraInfo\x12?\n\x0fbackend_options\x18\x04\
    \x20\x03(\x0b2\x16.caffe2.BackendOptionsR\x0ebackendOptions\"\xe3\x02\n\
    \x06NetDef\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12#\n\x02op\
    \x18\x02\x20\x03(\x0b2\x13.caffe2.OperatorDefR\x02op\x12\x12\n\x04type\
    \x18\x03\x20\x01(\tR\x04type\x12\x1f\n\x0bnum_workers\x18\x04\x20\x01(\
    \x05R\nnumWorkers\x129\n\rdevice_option\x18\x05\x20\x01(\x0b2\x14.caffe2\
    .DeviceOptionR\x0cdeviceOption\x12\"\n\x03arg\x18\x06\x20\x03(\x0b2\x10.\
    caffe2.ArgumentR\x03arg\x12%\n\x0eexternal_input\x18\x07\x20\x03(\tR\rex\
    ternalInput\x12'\n\x0fexternal_output\x18\x08\x20\x03(\tR\x0eexternalOut\
    put\x12<\n\x0epartition_info\x18\t\x20\x03(\x0b2\x15.caffe2.PartitionInf\
    oR\rpartitionInfo\"\xff\x03\n\rExecutionStep\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12/\n\x07substep\x18\x02\x20\x03(\x0b2\x15.caffe2.\
    ExecutionStepR\x07substep\x12\x18\n\x07network\x18\x03\x20\x03(\tR\x07ne\
    twork\x12\x19\n\x08num_iter\x18\x04\x20\x01(\x03R\x07numIter\x12-\n\x10c\
    riteria_network\x18\x05\x20\x01(\tR\x0fcriteriaNetworkB\x02\x18\x01\x12\
    \x1d\n\nreport_net\x18\x07\x20\x01(\tR\treportNet\x12'\n\x0freport_inter\
    val\x18\x08\x20\x01(\x05R\x0ereportInterval\x12\x20\n\x0crun_every_ms\
    \x18\x0b\x20\x01(\x03R\nrunEveryMs\x12/\n\x13concurrent_substeps\x18\x06\
    \x20\x01(\x08R\x12concurrentSubsteps\x12(\n\x10should_stop_blob\x18\t\
    \x20\x01(\tR\x0eshouldStopBlob\x12\x1b\n\tonly_once\x18\n\x20\x01(\x08R\
    \x08onlyOnce\x12)\n\x10create_workspace\x18\x0c\x20\x01(\x08R\x0fcreateW\
    orkspace\x128\n\x18num_concurrent_instances\x18\r\x20\x01(\x05R\x16numCo\
    ncurrentInstances\"\x85\x01\n\x07PlanDef\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12(\n\x07network\x18\x02\x20\x03(\x0b2\x0e.caffe2.NetD\
    efR\x07network\x12<\n\x0eexecution_step\x18\x03\x20\x03(\x0b2\x15.caffe2\
    .ExecutionStepR\rexecutionStep\"\x82\x02\n\tBlobProto\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04type\x18\x02\x20\x01(\tR\x04ty\
    pe\x12+\n\x06tensor\x18\x03\x20\x01(\x0b2\x13.caffe2.TensorProtoR\x06ten\
    sor\x12\x18\n\x07content\x18\x04\x20\x01(\x0cR\x07content\x12.\n\x07qten\
    sor\x18\x05\x20\x01(\x0b2\x14.caffe2.QTensorProtoR\x07qtensor\x12,\n\x12\
    content_num_chunks\x18\x06\x20\x01(\x05R\x10contentNumChunks\x12(\n\x10c\
    ontent_chunk_id\x18\x07\x20\x01(\x05R\x0econtentChunkId\"f\n\rDBReaderPr\
    oto\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06source\
    \x18\x02\x20\x01(\tR\x06source\x12\x17\n\x07db_type\x18\x03\x20\x01(\tR\
    \x06dbType\x12\x10\n\x03key\x18\x04\x20\x01(\tR\x03key\"\xfc\x01\n\x18Bl\
    obSerializationOptions\x12&\n\x0fblob_name_regex\x18\x01\x20\x01(\tR\rbl\
    obNameRegex\x12\x1d\n\nchunk_size\x18\x02\x20\x01(\x03R\tchunkSize\x12O\
    \n\x0cfloat_format\x18\x03\x20\x01(\x0e2,.caffe2.BlobSerializationOption\
    s.FloatFormatR\x0bfloatFormat\"H\n\x0bFloatFormat\x12\x11\n\rFLOAT_DEFAU\
    LT\x10\0\x12\x12\n\x0eFLOAT_PROTOBUF\x10\x01\x12\x12\n\x0eFLOAT_BFLOAT16\
    \x10\x02\"R\n\x14SerializationOptions\x12:\n\x07options\x18\x01\x20\x03(\
    \x0b2\x20.caffe2.BlobSerializationOptionsR\x07options*\xee\x01\n\x0fDevi\
    ceTypeProto\x12\r\n\tPROTO_CPU\x10\0\x12\x0e\n\nPROTO_CUDA\x10\x01\x12\
    \x10\n\x0cPROTO_MKLDNN\x10\x02\x12\x10\n\x0cPROTO_OPENGL\x10\x03\x12\x10\
    \n\x0cPROTO_OPENCL\x10\x04\x12\x0f\n\x0bPROTO_IDEEP\x10\x05\x12\r\n\tPRO\
    TO_HIP\x10\x06\x12\x0e\n\nPROTO_FPGA\x10\x07\x12\x0f\n\x0bPROTO_MSNPU\
    \x10\x08\x12\r\n\tPROTO_XLA\x10\t\x12\r\n\tPROTO_MLC\x10\n\x12'\n#PROTO_\
    COMPILE_TIME_MAX_DEVICE_TYPES\x10\x0bJ\xa0\xcb\x01\n\x07\x12\x05\0\0\x91\
    \x04\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\
    \x0f\n\xb4\x04\n\x02\x04\0\x12\x04\x0e\0e\x01\x1a/\x20TensorProto\x20sto\
    res\x20serialized\x20Tensor\x20objects.\n2\xf6\x03\x20A\x20few\x20notes\
    \x20about\x20the\x20Caffe2's\x20protobuffer\x20convention:\n\x20(1)\x20M\
    ost\x20objects\x20are\x20registered\x20by\x20their\x20types,\x20such\x20\
    as\x20operators\x20and\x20nets.\n\x20\x20\x20\x20\x20For\x20these,\x20we\
    \x20have\x20a\x20string-type\x20field\x20\"type\"\x20for\x20registration\
    \x20purposes.\n\x20(2)\x20We\x20do\x20not\x20use\x20extension\x20because\
    \x20that\x20used\x20to\x20create\x20quite\x20some\x20conflicts\n\x20\x20\
    \x20\x20\x20in\x20Caffe's\x20protobuf\x20design.\n\x20(3)\x20We\x20have\
    \x20not\x20used\x20any\x20proto3\x20specific\x20features,\x20such\x20as\
    \x20Any\x20or\x20Map.\x20This\n\x20\x20\x20\x20\x20is\x20mainly\x20for\
    \x20backward\x20compatibility\x20purposes\x20but\x20we\x20may\x20conside\
    r\x20using\n\x20\x20\x20\x20\x20those\x20in\x20the\x20future.\n\n\n\n\
    \x03\x04\0\x01\x12\x03\x0e\x08\x13\n,\n\x04\x04\0\x02\0\x12\x03\x10\x02\
    \x1a\x1a\x1f\x20The\x20dimensions\x20in\x20the\x20tensor.\n\n\x0c\n\x05\
    \x04\0\x02\0\x04\x12\x03\x10\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\
    \x10\x0b\x10\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x10\x11\x15\n\x0c\n\x05\
    \x04\0\x02\0\x03\x12\x03\x10\x18\x19\n\x19\n\x04\x04\0\x04\0\x12\x04\x13\
    \x02(\x03\x1a\x0b\x20Data\x20type\n\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03\
    \x13\x07\x0f\n\r\n\x06\x04\0\x04\0\x02\0\x12\x03\x14\x04\x12\n\x0e\n\x07\
    \x04\0\x04\0\x02\0\x01\x12\x03\x14\x04\r\n\x0e\n\x07\x04\0\x04\0\x02\0\
    \x02\x12\x03\x14\x10\x11\n%\n\x06\x04\0\x04\0\x02\x01\x12\x03\x17\x04\
    \x0e\x1a\r\x20Basic\x20types\n\"\x07\x20float\n\n\x0e\n\x07\x04\0\x04\0\
    \x02\x01\x01\x12\x03\x17\x04\t\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\
    \x03\x17\x0c\r\n\x14\n\x06\x04\0\x04\0\x02\x02\x12\x03\x18\x04\x0e\"\x05\
    \x20int\n\n\x0e\n\x07\x04\0\x04\0\x02\x02\x01\x12\x03\x18\x04\t\n\x0e\n\
    \x07\x04\0\x04\0\x02\x02\x02\x12\x03\x18\x0c\r\nJ\n\x06\x04\0\x04\0\x02\
    \x03\x12\x03\x19\x04\r\";\x20byte,\x20when\x20deserialized,\x20is\x20goi\
    ng\x20to\x20be\x20restored\x20as\x20uint8\n\n\x0e\n\x07\x04\0\x04\0\x02\
    \x03\x01\x12\x03\x19\x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\x03\x02\x12\x03\
    \x19\x0b\x0c\n\x17\n\x06\x04\0\x04\0\x02\x04\x12\x03\x1a\x04\x0f\"\x08\
    \x20string\n\n\x0e\n\x07\x04\0\x04\0\x02\x04\x01\x12\x03\x1a\x04\n\n\x0e\
    \n\x07\x04\0\x04\0\x02\x04\x02\x12\x03\x1a\r\x0e\n6\n\x06\x04\0\x04\0\
    \x02\x05\x12\x03\x1d\x04\r\x1a\x1f\x20Less-commonly\x20used\x20data\x20t\
    ypes\n\"\x06\x20bool\n\n\x0e\n\x07\x04\0\x04\0\x02\x05\x01\x12\x03\x1d\
    \x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\x05\x02\x12\x03\x1d\x0b\x0c\n\x18\n\
    \x06\x04\0\x04\0\x02\x06\x12\x03\x1e\x04\x0e\"\t\x20uint8_t\n\n\x0e\n\
    \x07\x04\0\x04\0\x02\x06\x01\x12\x03\x1e\x04\t\n\x0e\n\x07\x04\0\x04\0\
    \x02\x06\x02\x12\x03\x1e\x0c\r\n\x17\n\x06\x04\0\x04\0\x02\x07\x12\x03\
    \x1f\x04\r\"\x08\x20int8_t\n\n\x0e\n\x07\x04\0\x04\0\x02\x07\x01\x12\x03\
    \x1f\x04\x08\n\x0e\n\x07\x04\0\x04\0\x02\x07\x02\x12\x03\x1f\x0b\x0c\n\
    \x19\n\x06\x04\0\x04\0\x02\x08\x12\x03\x20\x04\x0f\"\n\x20uint16_t\n\n\
    \x0e\n\x07\x04\0\x04\0\x02\x08\x01\x12\x03\x20\x04\n\n\x0e\n\x07\x04\0\
    \x04\0\x02\x08\x02\x12\x03\x20\r\x0e\n\x18\n\x06\x04\0\x04\0\x02\t\x12\
    \x03!\x04\x0e\"\t\x20int16_t\n\n\x0e\n\x07\x04\0\x04\0\x02\t\x01\x12\x03\
    !\x04\t\n\x0e\n\x07\x04\0\x04\0\x02\t\x02\x12\x03!\x0c\r\n\x18\n\x06\x04\
    \0\x04\0\x02\n\x12\x03\"\x04\x0f\"\t\x20int64_t\n\n\x0e\n\x07\x04\0\x04\
    \0\x02\n\x01\x12\x03\"\x04\t\n\x0e\n\x07\x04\0\x04\0\x02\n\x02\x12\x03\"\
    \x0c\x0e\n\x19\n\x06\x04\0\x04\0\x02\x0b\x12\x03#\x04\x11\"\n\x20at::Hal\
    f\n\n\x0e\n\x07\x04\0\x04\0\x02\x0b\x01\x12\x03#\x04\x0b\n\x0e\n\x07\x04\
    \0\x04\0\x02\x0b\x02\x12\x03#\x0e\x10\n\x17\n\x06\x04\0\x04\0\x02\x0c\
    \x12\x03$\x04\x10\"\x08\x20double\n\n\x0e\n\x07\x04\0\x04\0\x02\x0c\x01\
    \x12\x03$\x04\n\n\x0e\n\x07\x04\0\x04\0\x02\x0c\x02\x12\x03$\r\x0f\n*\n\
    \x06\x04\0\x04\0\x02\r\x12\x03&\x04\x1d\"\x1b\x20zero-collision\x20hash\
    \x20state\n\n\x0e\n\x07\x04\0\x04\0\x02\r\x01\x12\x03&\x04\x17\n\x0e\n\
    \x07\x04\0\x04\0\x02\r\x02\x12\x03&\x1a\x1c\n\"\n\x06\x04\0\x04\0\x02\
    \x0e\x12\x03'\x04\x1a\"\x13\x20rebatching\x20buffer\n\n\x0e\n\x07\x04\0\
    \x04\0\x02\x0e\x01\x12\x03'\x04\x15\n\x0e\n\x07\x04\0\x04\0\x02\x0e\x02\
    \x12\x03'\x17\x19\n7\n\x04\x04\0\x02\x01\x12\x03*\x024\x1a*\x20The\x20ty\
    pe\x20of\x20the\x20deserialized\x20tensor\x20data\n\n\x0c\n\x05\x04\0\
    \x02\x01\x04\x12\x03*\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03*\x0b\
    \x13\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03*\x14\x1d\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x03*\x20!\n\x0c\n\x05\x04\0\x02\x01\x08\x12\x03*\"3\n\
    \x0c\n\x05\x04\0\x02\x01\x07\x12\x03*-2\n2\n\x04\x04\0\x04\x01\x12\x04-\
    \x025\x03\x1a$\x20The\x20format\x20of\x20the\x20serialized\x20data.\n\n\
    \x0c\n\x05\x04\0\x04\x01\x01\x12\x03-\x07\x1a\n\x90\x02\n\x06\x04\0\x04\
    \x01\x02\0\x12\x032\x04\x15\x1a\x80\x02\x20FMT_PROTOBUF\x20is\x20the\x20\
    existing\x20serialization\x20format\x20from\x20before\x20the\n\x20data_f\
    ormat\x20field\x20was\x20introduced.\x20Most\x20data\x20types\x20are\x20\
    serialized\x20using\n\x20the\x20protobuf\x20typed\x20fields,\x20although\
    \x20in\x20some\x20cases\x20raw\x20little\x20endian\x20data\n\x20is\x20st\
    ored\x20in\x20the\x20byte_data\x20field\x20instead.\n\n\x0e\n\x07\x04\0\
    \x04\x01\x02\0\x01\x12\x032\x04\x10\n\x0e\n\x07\x04\0\x04\x01\x02\0\x02\
    \x12\x032\x13\x14\n<\n\x06\x04\0\x04\x01\x02\x01\x12\x034\x04\x15\x1a-\
    \x20bfloat16\x20data\x20stored\x20in\x20the\x20raw_data\x20field.\n\n\
    \x0e\n\x07\x04\0\x04\x01\x02\x01\x01\x12\x034\x04\x10\n\x0e\n\x07\x04\0\
    \x04\x01\x02\x01\x02\x12\x034\x13\x14\n\xfc\x02\n\x04\x04\0\x02\x02\x12\
    \x03<\x021\x1a\xee\x02\x20data_format\x20is\x20a\x20SerializationFormat\
    \x20enum\x20value.\n\x20However,\x20we\x20intentionally\x20store\x20it\
    \x20as\x20an\x20integer\x20value\x20so\x20we\x20can\n\x20distinguish\x20\
    between\x20old\x20messages\x20that\x20do\x20not\x20have\x20a\x20data_for\
    mat\x20value\x20vs\n\x20new\x20messages\x20that\x20have\x20a\x20Serializ\
    ationFormat\x20value\x20that\x20we\x20don't\n\x20understand.\x20\x20If\
    \x20we\x20stored\x20this\x20as\x20an\x20enum\x20then\x20protobuf\x20woul\
    d\x20deserialize\n\x20both\x20of\x20these\x20cases\x20the\x20same\x20way\
    .\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03<\x02\n\n\x0c\n\x05\x04\0\x02\
    \x02\x05\x12\x03<\x0b\x11\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03<\x12\x1d\
    \n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03<\x20\"\n\x0c\n\x05\x04\0\x02\x02\
    \x08\x12\x03<#0\n\x0c\n\x05\x04\0\x02\x02\x07\x12\x03<./\n\x18\n\x04\x04\
    \0\x02\x03\x12\x03?\x020\x1a\x0b\x20For\x20float\n\n\x0c\n\x05\x04\0\x02\
    \x03\x04\x12\x03?\x02\n\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03?\x0b\x10\n\
    \x0c\n\x05\x04\0\x02\x03\x01\x12\x03?\x11\x1b\n\x0c\n\x05\x04\0\x02\x03\
    \x03\x12\x03?\x1e\x1f\n\x0c\n\x05\x04\0\x02\x03\x08\x12\x03?\x20/\n\r\n\
    \x06\x04\0\x02\x03\x08\x02\x12\x03?!.\n\xba\x03\n\x04\x04\0\x02\x04\x12\
    \x03G\x020\x1a\xac\x03\x20For\x20int32,\x20uint8,\x20int8,\x20uint16,\
    \x20int16,\x20bool,\x20and\x20float16\n\x20Note\x20about\x20float16:\x20\
    in\x20storage\x20we\x20will\x20basically\x20convert\x20float16\x20byte-w\
    ise\n\x20to\x20unsigned\x20short\x20and\x20then\x20store\x20them\x20in\
    \x20the\x20int32_data\x20field.\n\x20Note:\x20storing\x20int8\x20and\x20\
    uint8\x20values\x20in\x20this\x20field\x20unfortunately\x20results\x20in\
    \n\x20larger\x20serialized\x20data\x20than\x20necessary,\x20as\x20protob\
    uf's\x20varint\x20encoding\n\x20scheme\x20requires\x202\x20bytes\x20to\
    \x20represent\x20int8\x20and\x20uint8\x20values\x20that\x20have\x20the\n\
    \x20MSB\x20set.\n\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03G\x02\n\n\x0c\n\
    \x05\x04\0\x02\x04\x05\x12\x03G\x0b\x10\n\x0c\n\x05\x04\0\x02\x04\x01\
    \x12\x03G\x11\x1b\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03G\x1e\x1f\n\x0c\n\
    \x05\x04\0\x02\x04\x08\x12\x03G\x20/\n\r\n\x06\x04\0\x02\x04\x08\x02\x12\
    \x03G!.\n\x18\n\x04\x04\0\x02\x05\x12\x03I\x02\x1f\x1a\x0b\x20For\x20byt\
    es\n\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03I\x02\n\n\x0c\n\x05\x04\0\x02\
    \x05\x05\x12\x03I\x0b\x10\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03I\x11\x1a\
    \n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03I\x1d\x1e\n\x1a\n\x04\x04\0\x02\
    \x06\x12\x03K\x02!\x1a\r\x20For\x20strings\n\n\x0c\n\x05\x04\0\x02\x06\
    \x04\x12\x03K\x02\n\n\x0c\n\x05\x04\0\x02\x06\x05\x12\x03K\x0b\x10\n\x0c\
    \n\x05\x04\0\x02\x06\x01\x12\x03K\x11\x1c\n\x0c\n\x05\x04\0\x02\x06\x03\
    \x12\x03K\x1f\x20\n\x19\n\x04\x04\0\x02\x07\x12\x03M\x022\x1a\x0c\x20For\
    \x20double\n\n\x0c\n\x05\x04\0\x02\x07\x04\x12\x03M\x02\n\n\x0c\n\x05\
    \x04\0\x02\x07\x05\x12\x03M\x0b\x11\n\x0c\n\x05\x04\0\x02\x07\x01\x12\
    \x03M\x12\x1d\n\x0c\n\x05\x04\0\x02\x07\x03\x12\x03M\x20!\n\x0c\n\x05\
    \x04\0\x02\x07\x08\x12\x03M\"1\n\r\n\x06\x04\0\x02\x07\x08\x02\x12\x03M#\
    0\n\x18\n\x04\x04\0\x02\x08\x12\x03O\x021\x1a\x0b\x20For\x20int64\n\n\
    \x0c\n\x05\x04\0\x02\x08\x04\x12\x03O\x02\n\n\x0c\n\x05\x04\0\x02\x08\
    \x05\x12\x03O\x0b\x10\n\x0c\n\x05\x04\0\x02\x08\x01\x12\x03O\x11\x1b\n\
    \x0c\n\x05\x04\0\x02\x08\x03\x12\x03O\x1e\x20\n\x0c\n\x05\x04\0\x02\x08\
    \x08\x12\x03O!0\n\r\n\x06\x04\0\x02\x08\x08\x02\x12\x03O\"/\nK\n\x04\x04\
    \0\x02\t\x12\x03Q\x02\x1f\x1a>\x20store\x20the\x20raw\x20data,\x20conten\
    ts\x20are\x20serialized\x20as\x20little-endian\n\n\x0c\n\x05\x04\0\x02\t\
    \x04\x12\x03Q\x02\n\n\x0c\n\x05\x04\0\x02\t\x05\x12\x03Q\x0b\x10\n\x0c\n\
    \x05\x04\0\x02\t\x01\x12\x03Q\x11\x19\n\x0c\n\x05\x04\0\x02\t\x03\x12\
    \x03Q\x1c\x1e\n1\n\x04\x04\0\x02\n\x12\x03T\x02\x1b\x1a$\x20Optionally,\
    \x20a\x20name\x20for\x20the\x20tensor.\n\n\x0c\n\x05\x04\0\x02\n\x04\x12\
    \x03T\x02\n\n\x0c\n\x05\x04\0\x02\n\x05\x12\x03T\x0b\x11\n\x0c\n\x05\x04\
    \0\x02\n\x01\x12\x03T\x12\x16\n\x0c\n\x05\x04\0\x02\n\x03\x12\x03T\x19\
    \x1a\n\xc9\x01\n\x04\x04\0\x02\x0b\x12\x03Y\x02*\x1a\xbb\x01\x20Optional\
    ly,\x20a\x20TensorProto\x20can\x20contain\x20the\x20details\x20about\x20\
    the\x20device\x20that\n\x20it\x20was\x20serialized\x20from.\x20This\x20i\
    s\x20useful\x20in\x20cases\x20like\x20snapshotting\x20a\x20whole\n\x20wo\
    rkspace\x20in\x20a\x20multi-GPU\x20environment.\n\n\x0c\n\x05\x04\0\x02\
    \x0b\x04\x12\x03Y\x02\n\n\x0c\n\x05\x04\0\x02\x0b\x06\x12\x03Y\x0b\x17\n\
    \x0c\n\x05\x04\0\x02\x0b\x01\x12\x03Y\x18%\n\x0c\n\x05\x04\0\x02\x0b\x03\
    \x12\x03Y()\n\x94\x01\n\x04\x04\0\x03\0\x12\x04]\x02`\x03\x1a\x85\x01\
    \x20When\x20loading\x20from\x20chunks\x20this\x20is\x20going\x20to\x20in\
    dicate\x20where\x20to\x20put\x20data\x20in\x20the\n\x20full\x20array.\
    \x20When\x20not\x20used\x20full\x20data\x20have\x20to\x20be\x20present\n\
    \n\x0c\n\x05\x04\0\x03\0\x01\x12\x03]\n\x11\n\r\n\x06\x04\0\x03\0\x02\0\
    \x12\x03^\x04\x1d\n\x0e\n\x07\x04\0\x03\0\x02\0\x04\x12\x03^\x04\x0c\n\
    \x0e\n\x07\x04\0\x03\0\x02\0\x05\x12\x03^\r\x12\n\x0e\n\x07\x04\0\x03\0\
    \x02\0\x01\x12\x03^\x13\x18\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03^\
    \x1b\x1c\n\r\n\x06\x04\0\x03\0\x02\x01\x12\x03_\x04\x1b\n\x0e\n\x07\x04\
    \0\x03\0\x02\x01\x04\x12\x03_\x04\x0c\n\x0e\n\x07\x04\0\x03\0\x02\x01\
    \x05\x12\x03_\r\x12\n\x0e\n\x07\x04\0\x03\0\x02\x01\x01\x12\x03_\x13\x16\
    \n\x0e\n\x07\x04\0\x03\0\x02\x01\x03\x12\x03_\x19\x1a\n\x0b\n\x04\x04\0\
    \x02\x0c\x12\x03a\x02\x20\n\x0c\n\x05\x04\0\x02\x0c\x04\x12\x03a\x02\n\n\
    \x0c\n\x05\x04\0\x02\x0c\x06\x12\x03a\x0b\x12\n\x0c\n\x05\x04\0\x02\x0c\
    \x01\x12\x03a\x13\x1a\n\x0c\n\x05\x04\0\x02\x0c\x03\x12\x03a\x1d\x1f\n\n\
    \n\x02\x04\x01\x12\x04g\0{\x01\n\n\n\x03\x04\x01\x01\x12\x03g\x08\x14\n\
    \x0b\n\x04\x04\x01\x02\0\x12\x03h\x02\x1a\n\x0c\n\x05\x04\x01\x02\0\x04\
    \x12\x03h\x02\n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03h\x0b\x10\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03h\x11\x15\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03h\x18\x19\n\x0b\n\x04\x04\x01\x02\x01\x12\x03i\x02\x1f\n\x0c\n\
    \x05\x04\x01\x02\x01\x04\x12\x03i\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x05\
    \x12\x03i\x0b\x10\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03i\x11\x1a\n\x0c\
    \n\x05\x04\x01\x02\x01\x03\x12\x03i\x1d\x1e\n\x0b\n\x04\x04\x01\x02\x02\
    \x12\x03j\x02\x1c\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03j\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x02\x05\x12\x03j\x0b\x11\n\x0c\n\x05\x04\x01\x02\x02\
    \x01\x12\x03j\x12\x17\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03j\x1a\x1b\n\
    \x0b\n\x04\x04\x01\x02\x03\x12\x03k\x02\x1b\n\x0c\n\x05\x04\x01\x02\x03\
    \x04\x12\x03k\x02\n\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03k\x0b\x11\n\
    \x0c\n\x05\x04\x01\x02\x03\x01\x12\x03k\x12\x16\n\x0c\n\x05\x04\x01\x02\
    \x03\x03\x12\x03k\x19\x1a\n\x0b\n\x04\x04\x01\x02\x04\x12\x03l\x02\x1e\n\
    \x0c\n\x05\x04\x01\x02\x04\x04\x12\x03l\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x04\x05\x12\x03l\x0b\x0f\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03l\x10\
    \x19\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03l\x1c\x1d\n\x0b\n\x04\x04\
    \x01\x02\x05\x12\x03m\x02*\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03m\x02\
    \n\n\x0c\n\x05\x04\x01\x02\x05\x05\x12\x03m\x0b\x10\n\x0c\n\x05\x04\x01\
    \x02\x05\x01\x12\x03m\x11\x15\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03m\
    \x18\x19\n\x0c\n\x05\x04\x01\x02\x05\x08\x12\x03m\x1a)\n\r\n\x06\x04\x01\
    \x02\x05\x08\x02\x12\x03m\x1b(\n\x0b\n\x04\x04\x01\x02\x06\x12\x03n\x02\
    \x1b\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03n\x02\n\n\x0c\n\x05\x04\x01\
    \x02\x06\x05\x12\x03n\x0b\x11\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03n\
    \x12\x16\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03n\x19\x1a\n\x0b\n\x04\
    \x04\x01\x02\x07\x12\x03o\x02@\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\x03o\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x07\x06\x12\x03o\x0b\x1f\n\x0c\n\x05\x04\
    \x01\x02\x07\x01\x12\x03o\x20)\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03o,\
    -\n\x0c\n\x05\x04\x01\x02\x07\x08\x12\x03o.?\n\x0c\n\x05\x04\x01\x02\x07\
    \x07\x12\x03o9>\n.\n\x04\x04\x01\x02\x08\x12\x03r\x02\x1d\x1a!\x20Multi-\
    group\x20quantization\x20params\n\n\x0c\n\x05\x04\x01\x02\x08\x04\x12\
    \x03r\x02\n\n\x0c\n\x05\x04\x01\x02\x08\x05\x12\x03r\x0b\x11\n\x0c\n\x05\
    \x04\x01\x02\x08\x01\x12\x03r\x12\x18\n\x0c\n\x05\x04\x01\x02\x08\x03\
    \x12\x03r\x1b\x1c\n\x0b\n\x04\x04\x01\x02\t\x12\x03s\x02\x1e\n\x0c\n\x05\
    \x04\x01\x02\t\x04\x12\x03s\x02\n\n\x0c\n\x05\x04\x01\x02\t\x05\x12\x03s\
    \x0b\x11\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03s\x12\x18\n\x0c\n\x05\x04\
    \x01\x02\t\x03\x12\x03s\x1b\x1d\nq\n\x04\x04\x01\x02\n\x12\x03w\x02\x1b\
    \x1ad\x20Multi-group\x20quantization\x20needed,\x20indicates\x20in\x20wh\
    ich\x20dimension\n\x20we\x20do\x20the\x20\"group\x20wise\x20quantization\
    \"\n\n\x0c\n\x05\x04\x01\x02\n\x04\x12\x03w\x02\n\n\x0c\n\x05\x04\x01\
    \x02\n\x05\x12\x03w\x0b\x10\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03w\x11\
    \x15\n\x0c\n\x05\x04\x01\x02\n\x03\x12\x03w\x18\x1a\nJ\n\x04\x04\x01\x02\
    \x0b\x12\x03z\x025\x1a=\x20It\x20should\x20be\x20true\x20if\x20it\x20is\
    \x20a\x20multi-group\x20quantization\x20proto\n\n\x0c\n\x05\x04\x01\x02\
    \x0b\x04\x12\x03z\x02\n\n\x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03z\x0b\x0f\
    \n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03z\x10\x1d\n\x0c\n\x05\x04\x01\
    \x02\x0b\x03\x12\x03z\x20\"\n\x0c\n\x05\x04\x01\x02\x0b\x08\x12\x03z#4\n\
    \x0c\n\x05\x04\x01\x02\x0b\x07\x12\x03z.3\n\xad\x01\n\x02\x04\x02\x12\
    \x06\x80\x01\0\x82\x01\x01\x1a\x9e\x01\x20TensorProtos\x20stores\x20mult\
    iple\x20TensorProto\x20objects\x20in\x20one\x20single\x20proto.\x20This\
    \n\x20is\x20useful\x20for\x20small\x20tensors;\x20For\x20anything\x20big\
    ,\x20consider\x20using\x20a\x20DB\x20for\n\x20storage.\n\n\x0b\n\x03\x04\
    \x02\x01\x12\x04\x80\x01\x08\x14\n\x0c\n\x04\x04\x02\x02\0\x12\x04\x81\
    \x01\x02\"\n\r\n\x05\x04\x02\x02\0\x04\x12\x04\x81\x01\x02\n\n\r\n\x05\
    \x04\x02\x02\0\x06\x12\x04\x81\x01\x0b\x16\n\r\n\x05\x04\x02\x02\0\x01\
    \x12\x04\x81\x01\x17\x1d\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x81\x01\x20\
    !\n\x0c\n\x02\x04\x03\x12\x06\x84\x01\0\x8a\x01\x01\n\x0b\n\x03\x04\x03\
    \x01\x12\x04\x84\x01\x08\x13\n\x0c\n\x04\x04\x03\x02\0\x12\x04\x85\x01\
    \x02\x1a\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\x85\x01\x02\n\n\r\n\x05\x04\
    \x03\x02\0\x05\x12\x04\x85\x01\x0b\x10\n\r\n\x05\x04\x03\x02\0\x01\x12\
    \x04\x85\x01\x11\x15\n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x85\x01\x18\x19\
    \n\x0c\n\x04\x04\x03\x02\x01\x12\x04\x86\x01\x02@\n\r\n\x05\x04\x03\x02\
    \x01\x04\x12\x04\x86\x01\x02\n\n\r\n\x05\x04\x03\x02\x01\x06\x12\x04\x86\
    \x01\x0b\x1f\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\x86\x01\x20)\n\r\n\
    \x05\x04\x03\x02\x01\x03\x12\x04\x86\x01,-\n\r\n\x05\x04\x03\x02\x01\x08\
    \x12\x04\x86\x01.?\n\r\n\x05\x04\x03\x02\x01\x07\x12\x04\x86\x019>\n\x0c\
    \n\x04\x04\x03\x02\x02\x12\x04\x87\x01\x02\"\n\r\n\x05\x04\x03\x02\x02\
    \x04\x12\x04\x87\x01\x02\n\n\r\n\x05\x04\x03\x02\x02\x05\x12\x04\x87\x01\
    \x0b\x10\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\x87\x01\x11\x1d\n\r\n\x05\
    \x04\x03\x02\x02\x03\x12\x04\x87\x01\x20!\n\x0c\n\x04\x04\x03\x02\x03\
    \x12\x04\x88\x01\x024\n\r\n\x05\x04\x03\x02\x03\x04\x12\x04\x88\x01\x02\
    \n\n\r\n\x05\x04\x03\x02\x03\x05\x12\x04\x88\x01\x0b\x0f\n\r\n\x05\x04\
    \x03\x02\x03\x01\x12\x04\x88\x01\x10\x1d\n\r\n\x05\x04\x03\x02\x03\x03\
    \x12\x04\x88\x01\x20!\n\r\n\x05\x04\x03\x02\x03\x08\x12\x04\x88\x01\"3\n\
    \r\n\x05\x04\x03\x02\x03\x07\x12\x04\x88\x01-2\n\x0c\n\x04\x04\x03\x02\
    \x04\x12\x04\x89\x01\x02\x1b\n\r\n\x05\x04\x03\x02\x04\x04\x12\x04\x89\
    \x01\x02\n\n\r\n\x05\x04\x03\x02\x04\x05\x12\x04\x89\x01\x0b\x11\n\r\n\
    \x05\x04\x03\x02\x04\x01\x12\x04\x89\x01\x12\x16\n\r\n\x05\x04\x03\x02\
    \x04\x03\x12\x04\x89\x01\x19\x1a\n\x0c\n\x02\x04\x04\x12\x06\x8c\x01\0\
    \x8e\x01\x01\n\x0b\n\x03\x04\x04\x01\x12\x04\x8c\x01\x08\x14\n\x0c\n\x04\
    \x04\x04\x02\0\x12\x04\x8d\x01\x02\"\n\r\n\x05\x04\x04\x02\0\x04\x12\x04\
    \x8d\x01\x02\n\n\r\n\x05\x04\x04\x02\0\x06\x12\x04\x8d\x01\x0b\x16\n\r\n\
    \x05\x04\x04\x02\0\x01\x12\x04\x8d\x01\x17\x1d\n\r\n\x05\x04\x04\x02\0\
    \x03\x12\x04\x8d\x01\x20!\n\xbe\x02\n\x02\x04\x05\x12\x06\x95\x01\0\xad\
    \x01\x01\x1a\xaf\x02\x20TensorBoundShape\x20is\x20used\x20to\x20save\x20\
    bound\x20shape\x20inference\x20result\x20for\x20a\x20tensor.\n\x20Tensor\
    BoundShape.shape\x20is\x20inferred\x20shape\x20for\x20this\x20tensor.\n\
    \x20TensorBoundShape.dimType\x20contains\x20dim_type\x20for\x20every\x20\
    dimension.\n\x20eg:\x20for\x20dimension\x20i,\x20shape.dims[i]\x20is\x20\
    the\x20inferred\x20shape\x20and\n\x20dim_type[i]\x20is\x20corresponding\
    \x20dim_type.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x95\x01\x08\x18\n\x0c\n\
    \x04\x04\x05\x02\0\x12\x04\x96\x01\x02!\n\r\n\x05\x04\x05\x02\0\x04\x12\
    \x04\x96\x01\x02\n\n\r\n\x05\x04\x05\x02\0\x06\x12\x04\x96\x01\x0b\x16\n\
    \r\n\x05\x04\x05\x02\0\x01\x12\x04\x96\x01\x17\x1c\n\r\n\x05\x04\x05\x02\
    \0\x03\x12\x04\x96\x01\x1f\x20\n\x0e\n\x04\x04\x05\x04\0\x12\x06\x97\x01\
    \x02\xa7\x01\x03\n\r\n\x05\x04\x05\x04\0\x01\x12\x04\x97\x01\x07\x0e\n\
    \x19\n\x06\x04\x05\x04\0\x02\0\x12\x04\x98\x01\x04\x10\"\t\x20unknown\n\
    \n\x0f\n\x07\x04\x05\x04\0\x02\0\x01\x12\x04\x98\x01\x04\x0b\n\x0f\n\x07\
    \x04\x05\x04\0\x02\0\x02\x12\x04\x98\x01\x0e\x0f\n\x1a\n\x06\x04\x05\x04\
    \0\x02\x01\x12\x04\x99\x01\x04\x12\"\n\x20constant\n\n\x0f\n\x07\x04\x05\
    \x04\0\x02\x01\x01\x12\x04\x99\x01\x04\x0c\n\x0f\n\x07\x04\x05\x04\0\x02\
    \x01\x02\x12\x04\x99\x01\x10\x11\n>\n\x06\x04\x05\x04\0\x02\x02\x12\x04\
    \x9b\x01\x04\x0e\x1a.\x20batch,\x20corresponding\x20dimension\x20is\x20b\
    atch_size\n\n\x0f\n\x07\x04\x05\x04\0\x02\x02\x01\x12\x04\x9b\x01\x04\t\
    \n\x0f\n\x07\x04\x05\x04\0\x02\x02\x02\x12\x04\x9b\x01\x0c\r\nd\n\x06\
    \x04\x05\x04\0\x02\x03\x12\x04\x9e\x01\x04\x1d\x1aT\x20batch_of_feature_\
    max,\n\x20corresponding\x20shape\x20is\x20inferred_feature_length\x20*\
    \x20batch_size\n\n\x0f\n\x07\x04\x05\x04\0\x02\x03\x01\x12\x04\x9e\x01\
    \x04\x18\n\x0f\n\x07\x04\x05\x04\0\x02\x03\x02\x12\x04\x9e\x01\x1b\x1c\n\
    j\n\x06\x04\x05\x04\0\x02\x04\x12\x04\xa1\x01\x04%\x1aZ\x20batch_of_feat\
    ure_max_default\n\x20corresponding\x20shape\x20is\x20default_feature_len\
    gth\x20*\x20batch_size\n\n\x0f\n\x07\x04\x05\x04\0\x02\x04\x01\x12\x04\
    \xa1\x01\x04\x20\n\x0f\n\x07\x04\x05\x04\0\x02\x04\x02\x12\x04\xa1\x01#$\
    \nM\n\x06\x04\x05\x04\0\x02\x05\x12\x04\xa3\x01\x04\x14\x1a=\x20feature_\
    max,\x20corresponding\x20shape\x20is\x20inferred_feature_length\n\n\x0f\
    \n\x07\x04\x05\x04\0\x02\x05\x01\x12\x04\xa3\x01\x04\x0f\n\x0f\n\x07\x04\
    \x05\x04\0\x02\x05\x02\x12\x04\xa3\x01\x12\x13\nT\n\x06\x04\x05\x04\0\
    \x02\x06\x12\x04\xa5\x01\x04\x1c\x1aD\x20feature_max_default,\x20corresp\
    onding\x20shape\x20is\x20default_feature_length\n\n\x0f\n\x07\x04\x05\
    \x04\0\x02\x06\x01\x12\x04\xa5\x01\x04\x17\n\x0f\n\x07\x04\x05\x04\0\x02\
    \x06\x02\x12\x04\xa5\x01\x1a\x1b\n4\n\x04\x04\x05\x02\x01\x12\x04\xa8\
    \x01\x02\x20\"&\x20dim_type.size()\x20==\x20shape.dims.size()\n\n\r\n\
    \x05\x04\x05\x02\x01\x04\x12\x04\xa8\x01\x02\n\n\r\n\x05\x04\x05\x02\x01\
    \x06\x12\x04\xa8\x01\x0b\x12\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xa8\
    \x01\x13\x1b\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xa8\x01\x1e\x1f\n\x0c\
    \n\x04\x04\x05\x02\x02\x12\x04\xa9\x01\x02\x1b\n\r\n\x05\x04\x05\x02\x02\
    \x04\x12\x04\xa9\x01\x02\n\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\xa9\x01\
    \x0b\x11\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xa9\x01\x12\x16\n\r\n\x05\
    \x04\x05\x02\x02\x03\x12\x04\xa9\x01\x19\x1a\nu\n\x04\x04\x05\x02\x03\
    \x12\x04\xac\x01\x02#\x1ag\x20a\x20flag\x20to\x20indicate\x20whether\x20\
    the\x20shape\x20is\x20final\x20and\x20cannot\x20be\x20changed\n\x20eg:\
    \x20input/output\x20of\x20in-place\x20ops\n\n\r\n\x05\x04\x05\x02\x03\
    \x04\x12\x04\xac\x01\x02\n\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\xac\x01\
    \x0b\x0f\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xac\x01\x10\x1e\n\r\n\x05\
    \x04\x05\x02\x03\x03\x12\x04\xac\x01!\"\n\x0c\n\x02\x04\x06\x12\x06\xaf\
    \x01\0\xb3\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\xaf\x01\x08\x19\n\x0c\
    \n\x04\x04\x06\x02\0\x12\x04\xb0\x01\x02'\n\r\n\x05\x04\x06\x02\0\x04\
    \x12\x04\xb0\x01\x02\n\n\r\n\x05\x04\x06\x02\0\x06\x12\x04\xb0\x01\x0b\
    \x1b\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xb0\x01\x1c\"\n\r\n\x05\x04\x06\
    \x02\0\x03\x12\x04\xb0\x01%&\n\x0c\n\x04\x04\x06\x02\x01\x12\x04\xb1\x01\
    \x02$\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xb1\x01\x02\n\n\r\n\x05\x04\
    \x06\x02\x01\x05\x12\x04\xb1\x01\x0b\x10\n\r\n\x05\x04\x06\x02\x01\x01\
    \x12\x04\xb1\x01\x11\x1f\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xb1\x01\"\
    #\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xb2\x01\x02%\n\r\n\x05\x04\x06\x02\
    \x02\x04\x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\x06\x02\x02\x05\x12\x04\xb2\
    \x01\x0b\x10\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xb2\x01\x11\x20\n\r\n\
    \x05\x04\x06\x02\x02\x03\x12\x04\xb2\x01#$\n\x0c\n\x02\x04\x07\x12\x06\
    \xb5\x01\0\xbb\x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\xb5\x01\x08\x11\n\
    \x0c\n\x04\x04\x07\x02\0\x12\x04\xb6\x01\x02$\n\r\n\x05\x04\x07\x02\0\
    \x04\x12\x04\xb6\x01\x02\n\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\xb6\x01\
    \x0b\x10\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xb6\x01\x11\x1f\n\r\n\x05\
    \x04\x07\x02\0\x03\x12\x04\xb6\x01\"#\n\x0c\n\x04\x04\x07\x02\x01\x12\
    \x04\xb7\x01\x02\"\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\xb7\x01\x02\n\n\
    \r\n\x05\x04\x07\x02\x01\x05\x12\x04\xb7\x01\x0b\x10\n\r\n\x05\x04\x07\
    \x02\x01\x01\x12\x04\xb7\x01\x11\x1d\n\r\n\x05\x04\x07\x02\x01\x03\x12\
    \x04\xb7\x01\x20!\n\x0c\n\x04\x04\x07\x02\x02\x12\x04\xb8\x01\x02'\n\r\n\
    \x05\x04\x07\x02\x02\x04\x12\x04\xb8\x01\x02\n\n\r\n\x05\x04\x07\x02\x02\
    \x05\x12\x04\xb8\x01\x0b\x0f\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xb8\
    \x01\x10\"\n\r\n\x05\x04\x07\x02\x02\x03\x12\x04\xb8\x01%&\n\x0c\n\x04\
    \x04\x07\x02\x03\x12\x04\xb9\x01\x02,\n\r\n\x05\x04\x07\x02\x03\x04\x12\
    \x04\xb9\x01\x02\n\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\xb9\x01\x0b\x11\
    \n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xb9\x01\x12'\n\r\n\x05\x04\x07\
    \x02\x03\x03\x12\x04\xb9\x01*+\n\x0c\n\x04\x04\x07\x02\x04\x12\x04\xba\
    \x01\x02%\n\r\n\x05\x04\x07\x02\x04\x04\x12\x04\xba\x01\x02\n\n\r\n\x05\
    \x04\x07\x02\x04\x05\x12\x04\xba\x01\x0b\x10\n\r\n\x05\x04\x07\x02\x04\
    \x01\x12\x04\xba\x01\x11\x20\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\xba\
    \x01#$\n\x88\x01\n\x02\x04\x08\x12\x06\xbf\x01\0\xce\x01\x01\x1az\x20A\
    \x20named\x20argument\x20containing\x20either\x20singular\x20float,\x20i\
    nteger\x20and\x20string\n\x20values,\x20or\x20repeated\x20float,\x20int\
    \x20and\x20string\x20arrays.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\xbf\x01\
    \x08\x10\n\x0c\n\x04\x04\x08\x02\0\x12\x04\xc0\x01\x02\x1b\n\r\n\x05\x04\
    \x08\x02\0\x04\x12\x04\xc0\x01\x02\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\
    \xc0\x01\x0b\x11\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xc0\x01\x12\x16\n\r\
    \n\x05\x04\x08\x02\0\x03\x12\x04\xc0\x01\x19\x1a\n\x0c\n\x04\x04\x08\x02\
    \x01\x12\x04\xc2\x01\x02\x17\n\r\n\x05\x04\x08\x02\x01\x04\x12\x04\xc2\
    \x01\x02\n\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\xc2\x01\x0b\x10\n\r\n\
    \x05\x04\x08\x02\x01\x01\x12\x04\xc2\x01\x11\x12\n\r\n\x05\x04\x08\x02\
    \x01\x03\x12\x04\xc2\x01\x15\x16\n\x0c\n\x04\x04\x08\x02\x02\x12\x04\xc3\
    \x01\x02\x17\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xc3\x01\x02\n\n\r\n\
    \x05\x04\x08\x02\x02\x05\x12\x04\xc3\x01\x0b\x10\n\r\n\x05\x04\x08\x02\
    \x02\x01\x12\x04\xc3\x01\x11\x12\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\
    \xc3\x01\x15\x16\n\x0c\n\x04\x04\x08\x02\x03\x12\x04\xc4\x01\x02\x17\n\r\
    \n\x05\x04\x08\x02\x03\x04\x12\x04\xc4\x01\x02\n\n\r\n\x05\x04\x08\x02\
    \x03\x05\x12\x04\xc4\x01\x0b\x10\n\r\n\x05\x04\x08\x02\x03\x01\x12\x04\
    \xc4\x01\x11\x12\n\r\n\x05\x04\x08\x02\x03\x03\x12\x04\xc4\x01\x15\x16\n\
    \x0c\n\x04\x04\x08\x02\x04\x12\x04\xc5\x01\x02\x1e\n\r\n\x05\x04\x08\x02\
    \x04\x04\x12\x04\xc5\x01\x02\n\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\xc5\
    \x01\x0b\x16\n\r\n\x05\x04\x08\x02\x04\x01\x12\x04\xc5\x01\x17\x18\n\r\n\
    \x05\x04\x08\x02\x04\x03\x12\x04\xc5\x01\x1b\x1d\n\x0c\n\x04\x04\x08\x02\
    \x05\x12\x04\xc6\x01\x02\x18\n\r\n\x05\x04\x08\x02\x05\x04\x12\x04\xc6\
    \x01\x02\n\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\xc6\x01\x0b\x11\n\r\n\
    \x05\x04\x08\x02\x05\x01\x12\x04\xc6\x01\x12\x13\n\r\n\x05\x04\x08\x02\
    \x05\x03\x12\x04\xc6\x01\x16\x17\n\x0c\n\x04\x04\x08\x02\x06\x12\x04\xc8\
    \x01\x02\x1c\n\r\n\x05\x04\x08\x02\x06\x04\x12\x04\xc8\x01\x02\n\n\r\n\
    \x05\x04\x08\x02\x06\x05\x12\x04\xc8\x01\x0b\x10\n\r\n\x05\x04\x08\x02\
    \x06\x01\x12\x04\xc8\x01\x11\x17\n\r\n\x05\x04\x08\x02\x06\x03\x12\x04\
    \xc8\x01\x1a\x1b\n\x0c\n\x04\x04\x08\x02\x07\x12\x04\xc9\x01\x02\x1a\n\r\
    \n\x05\x04\x08\x02\x07\x04\x12\x04\xc9\x01\x02\n\n\r\n\x05\x04\x08\x02\
    \x07\x05\x12\x04\xc9\x01\x0b\x10\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\
    \xc9\x01\x11\x15\n\r\n\x05\x04\x08\x02\x07\x03\x12\x04\xc9\x01\x18\x19\n\
    \x0c\n\x04\x04\x08\x02\x08\x12\x04\xca\x01\x02\x1d\n\r\n\x05\x04\x08\x02\
    \x08\x04\x12\x04\xca\x01\x02\n\n\r\n\x05\x04\x08\x02\x08\x05\x12\x04\xca\
    \x01\x0b\x10\n\r\n\x05\x04\x08\x02\x08\x01\x12\x04\xca\x01\x11\x18\n\r\n\
    \x05\x04\x08\x02\x08\x03\x12\x04\xca\x01\x1b\x1c\n\x0c\n\x04\x04\x08\x02\
    \t\x12\x04\xcb\x01\x02$\n\r\n\x05\x04\x08\x02\t\x04\x12\x04\xcb\x01\x02\
    \n\n\r\n\x05\x04\x08\x02\t\x06\x12\x04\xcb\x01\x0b\x16\n\r\n\x05\x04\x08\
    \x02\t\x01\x12\x04\xcb\x01\x17\x1e\n\r\n\x05\x04\x08\x02\t\x03\x12\x04\
    \xcb\x01!#\n\x0c\n\x04\x04\x08\x02\n\x12\x04\xcc\x01\x02\x1b\n\r\n\x05\
    \x04\x08\x02\n\x04\x12\x04\xcc\x01\x02\n\n\r\n\x05\x04\x08\x02\n\x06\x12\
    \x04\xcc\x01\x0b\x11\n\r\n\x05\x04\x08\x02\n\x01\x12\x04\xcc\x01\x12\x16\
    \n\r\n\x05\x04\x08\x02\n\x03\x12\x04\xcc\x01\x19\x1a\n\x0c\n\x04\x04\x08\
    \x02\x0b\x12\x04\xcd\x01\x02&\n\r\n\x05\x04\x08\x02\x0b\x04\x12\x04\xcd\
    \x01\x02\n\n\r\n\x05\x04\x08\x02\x0b\x06\x12\x04\xcd\x01\x0b\x17\n\r\n\
    \x05\x04\x08\x02\x0b\x01\x12\x04\xcd\x01\x18\x20\n\r\n\x05\x04\x08\x02\
    \x0b\x03\x12\x04\xcd\x01#%\n\xef\x01\n\x02\x05\0\x12\x06\xd4\x01\0\xe2\
    \x01\x01\x1a\xe0\x01\x20DeviceType\x20that\x20Caffe2\x20currently\x20sup\
    ports.\n\x20Note:\x20if\x20you\x20add\x20a\x20device\x20type,\x20make\
    \x20sure\x20you\x20add\x20the\x20corresponding\x20device\n\x20line\x20in\
    \x20the\x20DeviceTypeName()\x20function\x20in\x20caffe2/utils/proto_util\
    s.cc\n\x20and\x20update\x20c10/core/DeviceType.h\n\n\x0b\n\x03\x05\0\x01\
    \x12\x04\xd4\x01\x05\x14\n,\n\x04\x05\0\x02\0\x12\x04\xd5\x01\x02\x10\"\
    \x1e\x20In\x20default,\x20we\x20will\x20use\x20CPU.\n\n\r\n\x05\x05\0\
    \x02\0\x01\x12\x04\xd5\x01\x02\x0b\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xd5\
    \x01\x0e\x0f\n\x15\n\x04\x05\0\x02\x01\x12\x04\xd6\x01\x02\x11\"\x07\x20\
    CUDA.\n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xd6\x01\x02\x0c\n\r\n\x05\
    \x05\0\x02\x01\x02\x12\x04\xd6\x01\x0f\x10\n,\n\x04\x05\0\x02\x02\x12\
    \x04\xd7\x01\x02\x13\"\x1e\x20Reserved\x20for\x20explicit\x20MKLDNN\n\n\
    \r\n\x05\x05\0\x02\x02\x01\x12\x04\xd7\x01\x02\x0e\n\r\n\x05\x05\0\x02\
    \x02\x02\x12\x04\xd7\x01\x11\x12\n\x16\n\x04\x05\0\x02\x03\x12\x04\xd8\
    \x01\x02\x13\"\x08\x20OpenGL\n\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\xd8\
    \x01\x02\x0e\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\xd8\x01\x11\x12\n\x16\n\
    \x04\x05\0\x02\x04\x12\x04\xd9\x01\x02\x13\"\x08\x20OpenCL\n\n\r\n\x05\
    \x05\0\x02\x04\x01\x12\x04\xd9\x01\x02\x0e\n\r\n\x05\x05\0\x02\x04\x02\
    \x12\x04\xd9\x01\x11\x12\n\x16\n\x04\x05\0\x02\x05\x12\x04\xda\x01\x02\
    \x12\"\x08\x20IDEEP.\n\n\r\n\x05\x05\0\x02\x05\x01\x12\x04\xda\x01\x02\r\
    \n\r\n\x05\x05\0\x02\x05\x02\x12\x04\xda\x01\x10\x11\n\x17\n\x04\x05\0\
    \x02\x06\x12\x04\xdb\x01\x02\x10\"\t\x20AMD\x20HIP\n\n\r\n\x05\x05\0\x02\
    \x06\x01\x12\x04\xdb\x01\x02\x0b\n\r\n\x05\x05\0\x02\x06\x02\x12\x04\xdb\
    \x01\x0e\x0f\n\x14\n\x04\x05\0\x02\x07\x12\x04\xdc\x01\x02\x11\"\x06\x20\
    FPGA\n\n\r\n\x05\x05\0\x02\x07\x01\x12\x04\xdc\x01\x02\x0c\n\r\n\x05\x05\
    \0\x02\x07\x02\x12\x04\xdc\x01\x0f\x10\n\x15\n\x04\x05\0\x02\x08\x12\x04\
    \xdd\x01\x02\x12\"\x07\x20MSNPU\n\n\r\n\x05\x05\0\x02\x08\x01\x12\x04\
    \xdd\x01\x02\r\n\r\n\x05\x05\0\x02\x08\x02\x12\x04\xdd\x01\x10\x11\n\x19\
    \n\x04\x05\0\x02\t\x12\x04\xde\x01\x02\x10\"\x0b\x20XLA\x20/\x20TPU\n\n\
    \r\n\x05\x05\0\x02\t\x01\x12\x04\xde\x01\x02\x0b\n\r\n\x05\x05\0\x02\t\
    \x02\x12\x04\xde\x01\x0e\x0f\n\x1a\n\x04\x05\0\x02\n\x12\x04\xdf\x01\x02\
    \x11\"\x0c\x20ML\x20Compute\n\n\r\n\x05\x05\0\x02\n\x01\x12\x04\xdf\x01\
    \x02\x0b\n\r\n\x05\x05\0\x02\n\x02\x12\x04\xdf\x01\x0e\x10\nP\n\x04\x05\
    \0\x02\x0b\x12\x04\xe1\x01\x02+\x1aB\x20Change\x20the\x20following\x20nu\
    mber\x20if\x20you\x20add\x20more\x20devices\x20in\x20the\x20code.\n\n\r\
    \n\x05\x05\0\x02\x0b\x01\x12\x04\xe1\x01\x02%\n\r\n\x05\x05\0\x02\x0b\
    \x02\x12\x04\xe1\x01(*\n\x91\x03\n\x02\x04\t\x12\x06\xea\x01\0\xf9\x01\
    \x01\x1a\x82\x03\x20Device-specific\x20options.\x20We\x20do\x20not\x20di\
    stinguish\x20DeviceOption\x20protos\x20for\n\x20different\x20DeviceTypes\
    ,\x20so\x20currently\x20all\x20devices\x20share\x20the\x20same\x20Device\
    Option\n\x20proto.\x20Fields\x20that\x20are\x20specific\x20to\x20a\x20de\
    vice\x20type\x20is\x20ignored\x20if\x20the\x20type\x20does\n\x20not\x20m\
    atch.\n\x20Note:\x20if\x20you\x20add\x20fields\x20to\x20the\x20DeviceOpt\
    ion,\x20make\x20sure\x20you\x20add\x20the\n\x20corresponding\x20changes\
    \x20to\x20IsSameDevice()\x20function\x20in\x20utils/proto_utils.{h,cc}.\
    \n\n\x0b\n\x03\x04\t\x01\x12\x04\xea\x01\x08\x14\n\xa1\x01\n\x04\x04\t\
    \x02\0\x12\x04\xed\x01\x021\x1a\x85\x01\x20[general]\x20Options\x20that\
    \x20need\x20to\x20be\x20carried\x20out\x20before\x20running\x20the\x20ex\
    ecution.\n\x20optional\x20DeviceType\x20device_type\x20=\x201\x20[\x20de\
    fault\x20=\x20CPU\x20];\n\"\x0b\x200\x20is\x20CPU.\n\n\r\n\x05\x04\t\x02\
    \0\x04\x12\x04\xed\x01\x02\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xed\x01\
    \x0b\x10\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xed\x01\x11\x1c\n\r\n\x05\x04\
    \t\x02\0\x03\x12\x04\xed\x01\x1f\x20\n\r\n\x05\x04\t\x02\0\x08\x12\x04\
    \xed\x01!0\n\r\n\x05\x04\t\x02\0\x07\x12\x04\xed\x01-.\nU\n\x04\x04\t\
    \x02\x01\x12\x04\xef\x01\x02\x1f\x1aG\x20[general]\x20Used\x20together\
    \x20with\x20device_type\x20to\x20identify\x20the\x20exact\x20device\n\n\
    \r\n\x05\x04\t\x02\x01\x04\x12\x04\xef\x01\x02\n\n\r\n\x05\x04\t\x02\x01\
    \x05\x12\x04\xef\x01\x0b\x10\n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xef\x01\
    \x11\x1a\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xef\x01\x1d\x1e\n[\n\x04\
    \x04\t\x02\x02\x12\x04\xf1\x01\x02\"\x1aM\x20[general]\x20The\x20random\
    \x20seed\x20to\x20start\x20the\x20device\x20random\x20number\x20generato\
    r\x20with.\n\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xf1\x01\x02\n\n\r\n\x05\
    \x04\t\x02\x02\x05\x12\x04\xf1\x01\x0b\x11\n\r\n\x05\x04\t\x02\x02\x01\
    \x12\x04\xf1\x01\x12\x1d\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xf1\x01\x20\
    !\n\x86\x01\n\x04\x04\t\x02\x03\x12\x04\xf4\x01\x02\x20\x1ax\x20[general\
    ]\x20What\x20node\x20this\x20op\x20should\x20execute\x20on.\n\x20Used\
    \x20for\x20net\x20transformation\x20purposes.\x20Must\x20be\x20empty\x20\
    at\x20execution\x20time.\n\n\r\n\x05\x04\t\x02\x03\x04\x12\x04\xf4\x01\
    \x02\n\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xf4\x01\x0b\x11\n\r\n\x05\x04\
    \t\x02\x03\x01\x12\x04\xf4\x01\x12\x1b\n\r\n\x05\x04\t\x02\x03\x03\x12\
    \x04\xf4\x01\x1e\x1f\n5\n\x04\x04\t\x02\x04\x12\x04\xf6\x01\x02\"\x1a'\
    \x20[CPU\x20and\x20Linux\x20specific]\x20NUMA\x20node\x20id\n\n\r\n\x05\
    \x04\t\x02\x04\x04\x12\x04\xf6\x01\x02\n\n\r\n\x05\x04\t\x02\x04\x05\x12\
    \x04\xf6\x01\x0b\x10\n\r\n\x05\x04\t\x02\x04\x01\x12\x04\xf6\x01\x11\x1d\
    \n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xf6\x01\x20!\nY\n\x04\x04\t\x02\x05\
    \x12\x04\xf8\x01\x02!\x1aK\x20[general]\x20Extra\x20information\x20passe\
    d,\x20not\x20used\x20at\x20execution\x20time\x20currently.\n\n\r\n\x05\
    \x04\t\x02\x05\x04\x12\x04\xf8\x01\x02\n\n\r\n\x05\x04\t\x02\x05\x05\x12\
    \x04\xf8\x01\x0b\x11\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xf8\x01\x12\x1c\
    \n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xf8\x01\x1f\x20\n$\n\x02\x04\n\x12\
    \x06\xfc\x01\0\xb5\x02\x01\x1a\x16\x20Operator\x20Definition.\n\n\x0b\n\
    \x03\x04\n\x01\x12\x04\xfc\x01\x08\x13\n+\n\x04\x04\n\x02\0\x12\x04\xfd\
    \x01\x02\x1c\"\x1d\x20the\x20name\x20of\x20the\x20input\x20blobs\n\n\r\n\
    \x05\x04\n\x02\0\x04\x12\x04\xfd\x01\x02\n\n\r\n\x05\x04\n\x02\0\x05\x12\
    \x04\xfd\x01\x0b\x11\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xfd\x01\x12\x17\n\
    \r\n\x05\x04\n\x02\0\x03\x12\x04\xfd\x01\x1a\x1b\n,\n\x04\x04\n\x02\x01\
    \x12\x04\xfe\x01\x02\x1d\"\x1e\x20the\x20name\x20of\x20output\x20top\x20\
    blobs\n\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\xfe\x01\x02\n\n\r\n\x05\x04\
    \n\x02\x01\x05\x12\x04\xfe\x01\x0b\x11\n\r\n\x05\x04\n\x02\x01\x01\x12\
    \x04\xfe\x01\x12\x18\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xfe\x01\x1b\x1c\
    \n4\n\x04\x04\n\x02\x02\x12\x04\xff\x01\x02\x1b\"&\x20the\x20operator\
    \x20name.\x20This\x20is\x20optional.\n\n\r\n\x05\x04\n\x02\x02\x04\x12\
    \x04\xff\x01\x02\n\n\r\n\x05\x04\n\x02\x02\x05\x12\x04\xff\x01\x0b\x11\n\
    \r\n\x05\x04\n\x02\x02\x01\x12\x04\xff\x01\x12\x16\n\r\n\x05\x04\n\x02\
    \x02\x03\x12\x04\xff\x01\x19\x1a\nc\n\x04\x04\n\x02\x03\x12\x04\x82\x02\
    \x02\x1b\x1aU\x20the\x20operator\x20type.\x20This\x20is\x20needed\x20to\
    \x20create\x20the\x20object\x20from\x20the\x20operator\n\x20registry.\n\
    \n\r\n\x05\x04\n\x02\x03\x04\x12\x04\x82\x02\x02\n\n\r\n\x05\x04\n\x02\
    \x03\x05\x12\x04\x82\x02\x0b\x11\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\x82\
    \x02\x12\x16\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\x82\x02\x19\x1a\nB\n\
    \x04\x04\n\x02\x04\x12\x04\x84\x02\x02\x1c\x1a4\x20arg\x20is\x20for\x20t\
    he\x20argument\x20defined\x20in\x20operator\x20schema\n\n\r\n\x05\x04\n\
    \x02\x04\x04\x12\x04\x84\x02\x02\n\n\r\n\x05\x04\n\x02\x04\x06\x12\x04\
    \x84\x02\x0b\x13\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\x84\x02\x14\x17\n\r\
    \n\x05\x04\n\x02\x04\x03\x12\x04\x84\x02\x1a\x1b\nE\n\x04\x04\n\x02\x05\
    \x12\x04\x87\x02\x02*\x1a7\x20The\x20device\x20option\x20that\x20the\x20\
    operator\x20should\x20run\x20under.\n\n\r\n\x05\x04\n\x02\x05\x04\x12\
    \x04\x87\x02\x02\n\n\r\n\x05\x04\n\x02\x05\x06\x12\x04\x87\x02\x0b\x17\n\
    \r\n\x05\x04\n\x02\x05\x01\x12\x04\x87\x02\x18%\n\r\n\x05\x04\n\x02\x05\
    \x03\x12\x04\x87\x02()\n\xaa\x02\n\x04\x04\n\x02\x06\x12\x04\x8e\x02\x02\
    \x1d\x1a\x9b\x02\x20Optionally,\x20one\x20can\x20specify\x20an\x20engine\
    \x20when\x20there\x20are\x20multiple\n\x20implementations\x20available\
    \x20simultaneously\x20for\x20one\x20device\x20type.\n\x20If\x20one\x20sp\
    ecifies\x20an\x20engine\x20but\x20that\x20engine\x20does\x20not\x20exist\
    \x20in\x20the\x20compiled\n\x20Caffe2\x20binary,\x20Caffe2\x20will\x20fa\
    ll\x20back\x20to\x20the\x20default\x20engine\x20of\x20that\x20device\n\
    \x20type.\n\n\r\n\x05\x04\n\x02\x06\x04\x12\x04\x8e\x02\x02\n\n\r\n\x05\
    \x04\n\x02\x06\x05\x12\x04\x8e\x02\x0b\x11\n\r\n\x05\x04\n\x02\x06\x01\
    \x12\x04\x8e\x02\x12\x18\n\r\n\x05\x04\n\x02\x06\x03\x12\x04\x8e\x02\x1b\
    \x1c\n\xe7\x02\n\x04\x04\n\x02\x07\x12\x04\x97\x02\x02$\x1a\xd8\x02\x20A\
    dditional\x20'fake'\x20inputs\x20used\x20for\x20expressing\x20control\
    \x20dependencies\n\x20in\x20the\x20operator\x20graph.\x20This\x20can\x20\
    be\x20used\x20to\x20ensure\x20that\x20an\n\x20operator\x20does\x20not\
    \x20run\x20until\x20another\x20operator\x20is\x20ready,\x20for\x20e.g.\n\
    \x20scheduling\x20control.\x20These\x20are\x20not\x20passed\x20as\x20act\
    ual\x20inputs\x20to\x20the\n\x20Operator\x20implementation,\x20and\x20ar\
    e\x20only\x20used\x20by\x20the\x20Net\x20class\x20for\n\x20scheduling\
    \x20purposes.\n\n\r\n\x05\x04\n\x02\x07\x04\x12\x04\x97\x02\x02\n\n\r\n\
    \x05\x04\n\x02\x07\x05\x12\x04\x97\x02\x0b\x11\n\r\n\x05\x04\n\x02\x07\
    \x01\x12\x04\x97\x02\x12\x1f\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\x97\x02\
    \"#\nr\n\x04\x04\n\x02\x08\x12\x04\x9b\x02\x025\x1ad\x20is_gradient_op\
    \x20argument\x20is\x20only\x20used\x20as\x20a\x20hint\x20in\x20shape\x20\
    inference\n\x20and\x20has\x20no\x20runtime\x20significance\n\n\r\n\x05\
    \x04\n\x02\x08\x04\x12\x04\x9b\x02\x02\n\n\r\n\x05\x04\n\x02\x08\x05\x12\
    \x04\x9b\x02\x0b\x0f\n\r\n\x05\x04\n\x02\x08\x01\x12\x04\x9b\x02\x10\x1e\
    \n\r\n\x05\x04\n\x02\x08\x03\x12\x04\x9b\x02!\"\n\r\n\x05\x04\n\x02\x08\
    \x08\x12\x04\x9b\x02#4\n\r\n\x05\x04\n\x02\x08\x07\x12\x04\x9b\x02.3\n\
    \xc2\x01\n\x04\x04\n\x02\t\x12\x04\xa0\x02\x02\"\x1a\xb3\x01\x20debug\
    \x20information\x20associated\x20with\x20the\x20construction\x20of\x20th\
    e\x20operator.\n\x20This\x20is\x20an\x20optional\x20string\x20with\x20no\
    \x20assumed\x20characteristics\x20as\n\x20operators\x20can\x20be\x20cons\
    tructed\x20in\x20any\x20language.\n\n\r\n\x05\x04\n\x02\t\x04\x12\x04\
    \xa0\x02\x02\n\n\r\n\x05\x04\n\x02\t\x05\x12\x04\xa0\x02\x0b\x11\n\r\n\
    \x05\x04\n\x02\t\x01\x12\x04\xa0\x02\x12\x1c\n\r\n\x05\x04\n\x02\t\x03\
    \x12\x04\xa0\x02\x1f!\n\x89\x05\n\x04\x04\n\x02\n\x12\x04\xad\x02\x02\
    \x1e\x1a\xfa\x04\x20the\x20domain\x20of\x20the\x20operator\x20to\x20help\
    \x20runtime\x20distinguish\x20which\x20operator\n\x20library\x20this\x20\
    OperatorDef\x20refers\x20to.\x20For\x20example,\x20both\x20caffe2\x20and\
    \x20aten\n\x20has\x20`Add`\x20operator,\x20with\x20domain,\x20we\x20can\
    \x20easily\x20decide\x20which\x20operator\n\x20to\x20execute.\x20to\x20s\
    upport\x20multiple\x20operator\x20libs,\x20we\x20use\x20domain\x20to\n\
    \x20distinguish\x20which\x20operator\x20lib\x20we\x20refer\x20to:\n\x20\
    \x20\x20-\x20\"caffe2\"\x20means\x20this\x20uses\x20Caffe2\x20operator\
    \x20library\n\x20\x20\x20-\x20\"aten\"\x20means\x20this\x20uses\x20ATen\
    \x20operator\x20library\n\x20\x20\x20-\x20\"c10\"\x20is\x20for\x20the\
    \x20fused\x20library\n\x20\x20\x20-\x20if\x20the\x20domain\x20is\x20miss\
    ing\x20or\x20empty,\x20we\x20use\x20\"caffe2\",\x20this\x20is\x20for\n\
    \x20\x20\x20\x20\x20legacy\x20models,\x20new\x20serializer\x20should\x20\
    always\x20export\x20an\x20OperatorDef\n\x20\x20\x20\x20\x20with\x20domai\
    n\x20and\x20op_version\n\n\r\n\x05\x04\n\x02\n\x04\x12\x04\xad\x02\x02\n\
    \n\r\n\x05\x04\n\x02\n\x05\x12\x04\xad\x02\x0b\x11\n\r\n\x05\x04\n\x02\n\
    \x01\x12\x04\xad\x02\x12\x18\n\r\n\x05\x04\n\x02\n\x03\x12\x04\xad\x02\
    \x1b\x1d\n\xb3\x02\n\x04\x04\n\x02\x0b\x12\x04\xb4\x02\x02!\x1a\xa4\x02\
    \x20each\x20operator\x20is\x20has\x20its\x20own\x20version\x20number.\n\
    \x20operator\x20version\x20information\n\x20each\x20time,\x20we\x20chang\
    e\x20the\x20API\x20or\x20semantics\x20of\x20the\x20operator,\n\x20we\x20\
    bump\x20the\x20version\x20for\x20the\x20operator.\n\x20the\x20runtime\
    \x20system\x20should\x20check\x20the\x20op_version\x20of\x20each\x20Oper\
    atorDef\n\x20and\x20decide\x20it\x20should\x20reject\x20or\x20accept\x20\
    the\x20model\n\n\r\n\x05\x04\n\x02\x0b\x04\x12\x04\xb4\x02\x02\n\n\r\n\
    \x05\x04\n\x02\x0b\x05\x12\x04\xb4\x02\x0b\x10\n\r\n\x05\x04\n\x02\x0b\
    \x01\x12\x04\xb4\x02\x11\x1b\n\r\n\x05\x04\n\x02\x0b\x03\x12\x04\xb4\x02\
    \x1e\x20\n\x95\x01\n\x02\x04\x0b\x12\x06\xb9\x02\0\xbc\x02\x01\x1a\x86\
    \x01\x20MapFieldEntry\x20follows\x20the\x20pattern\x20for\x20cross-proto\
    -version\x20maps.\n\x20See\x20https://developers.google.com/protocol-buf\
    fers/docs/proto3#maps\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\xb9\x02\x08\x15\
    \n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xba\x02\x02\x1a\n\r\n\x05\x04\x0b\x02\
    \0\x04\x12\x04\xba\x02\x02\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xba\x02\
    \x0b\x11\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xba\x02\x12\x15\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xba\x02\x18\x19\n\x0c\n\x04\x04\x0b\x02\x01\
    \x12\x04\xbb\x02\x02\x1a\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\xbb\x02\
    \x02\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xbb\x02\x0b\x11\n\r\n\x05\
    \x04\x0b\x02\x01\x01\x12\x04\xbb\x02\x12\x15\n\r\n\x05\x04\x0b\x02\x01\
    \x03\x12\x04\xbb\x02\x18\x19\n6\n\x02\x04\x0c\x12\x06\xbf\x02\0\xc4\x02\
    \x01\x1a(\x20Used\x20to\x20hold\x20backend-specific\x20options.\n\n\x0b\
    \n\x03\x04\x0c\x01\x12\x04\xbf\x02\x08\x16\nH\n\x04\x04\x0c\x02\0\x12\
    \x04\xc1\x02\x02#\x1a:\x20Name\x20of\x20the\x20backend\x20that\x20the\
    \x20specified\x20options\x20apply\x20to.\n\n\r\n\x05\x04\x0c\x02\0\x04\
    \x12\x04\xc1\x02\x02\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xc1\x02\x0b\
    \x11\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xc1\x02\x12\x1e\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\xc1\x02!\"\n8\n\x04\x04\x0c\x02\x01\x12\x04\xc3\
    \x02\x02$\x1a*\x20Flexible\x20map\x20for\x20passing\x20in\x20the\x20opti\
    ons.\n\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xc3\x02\x02\n\n\r\n\x05\x04\
    \x0c\x02\x01\x06\x12\x04\xc3\x02\x0b\x18\n\r\n\x05\x04\x0c\x02\x01\x01\
    \x12\x04\xc3\x02\x19\x1f\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xc3\x02\"\
    #\n%\n\x02\x04\r\x12\x06\xc7\x02\0\xd5\x02\x01\x1a\x17\x20Partition\x20d\
    efinition.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xc7\x02\x08\x15\n&\n\x04\x04\
    \r\x02\0\x12\x04\xc9\x02\x02\x1b\x1a\x18\x20Name\x20of\x20the\x20partiti\
    on.\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xc9\x02\x02\n\n\r\n\x05\x04\r\
    \x02\0\x05\x12\x04\xc9\x02\x0b\x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xc9\
    \x02\x12\x16\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xc9\x02\x19\x1a\n\xb7\x01\
    \n\x04\x04\r\x02\x01\x12\x04\xce\x02\x02\x1f\x1a\xa8\x01\x20A\x20list\
    \x20of\x20logic\x20device\x20ID,\x20indicating\x20which\x20devices\x20th\
    is\x20partition\n\x20can\x20be\x20executed\x20on.\x20If\x20empty,\x20it\
    \x20means\x20the\x20partition\x20won't\x20run\x20on\n\x20device\x20but\
    \x20on\x20host\x20CPU\x20instead.\n\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\
    \xce\x02\x02\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xce\x02\x0b\x10\n\r\n\
    \x05\x04\r\x02\x01\x01\x12\x04\xce\x02\x11\x1a\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\xce\x02\x1d\x1e\n!\n\x04\x04\r\x02\x02\x12\x04\xd1\x02\x02!\
    \x1a\x13\x20Extra\x20debug\x20info.\n\n\r\n\x05\x04\r\x02\x02\x04\x12\
    \x04\xd1\x02\x02\n\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xd1\x02\x0b\x11\n\
    \r\n\x05\x04\r\x02\x02\x01\x12\x04\xd1\x02\x12\x1c\n\r\n\x05\x04\r\x02\
    \x02\x03\x12\x04\xd1\x02\x1f\x20\nG\n\x04\x04\r\x02\x03\x12\x04\xd4\x02\
    \x02.\x1a9\x20Flexible\x20map\x20for\x20passing\x20options\x20specific\
    \x20to\x20a\x20backend.\n\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xd4\x02\
    \x02\n\n\r\n\x05\x04\r\x02\x03\x06\x12\x04\xd4\x02\x0b\x19\n\r\n\x05\x04\
    \r\x02\x03\x01\x12\x04\xd4\x02\x1a)\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\
    \xd4\x02,-\n#\n\x02\x04\x0e\x12\x06\xd8\x02\0\x83\x03\x01\x1a\x15\x20Net\
    work\x20definition.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xd8\x02\x08\x0e\n\
    \"\n\x04\x04\x0e\x02\0\x12\x04\xd9\x02\x02\x1b\"\x14\x20the\x20network's\
    \x20name\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xd9\x02\x02\n\n\r\n\x05\
    \x04\x0e\x02\0\x05\x12\x04\xd9\x02\x0b\x11\n\r\n\x05\x04\x0e\x02\0\x01\
    \x12\x04\xd9\x02\x12\x16\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xd9\x02\x19\
    \x1a\n\x80\x01\n\x04\x04\x0e\x02\x01\x12\x04\xdc\x02\x02\x1e\x1ar\x20Ope\
    rators\x20that\x20the\x20network\x20contains.\n\x20Note:\x20this\x20is\
    \x20not\x20named\x20\"operator\"\x20because\x20that\x20is\x20a\x20reserv\
    ed\x20word\x20in\x20C++.\n\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xdc\x02\
    \x02\n\n\r\n\x05\x04\x0e\x02\x01\x06\x12\x04\xdc\x02\x0b\x16\n\r\n\x05\
    \x04\x0e\x02\x01\x01\x12\x04\xdc\x02\x17\x19\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\xdc\x02\x1c\x1d\n\xfa\x01\n\x04\x04\x0e\x02\x02\x12\x04\xe2\
    \x02\x02\x1b\x1a\xeb\x01\x20The\x20type\x20of\x20network\x20that\x20the\
    \x20net\x20should\x20be\x20run\x20with.\x20This\x20routes\x20the\n\x20ne\
    twork\x20instantiation\x20to\x20different\x20execution\x20modes.\x20The\
    \x20default\x20mode,\n\x20\"simple\",\x20runs\x20the\x20operators\x20in\
    \x20a\x20sequential\x20way\x20as\x20the\x20original\x20Caffe\n\x20implem\
    entation\x20does.\n\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\xe2\x02\x02\n\
    \n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xe2\x02\x0b\x11\n\r\n\x05\x04\x0e\
    \x02\x02\x01\x12\x04\xe2\x02\x12\x16\n\r\n\x05\x04\x0e\x02\x02\x03\x12\
    \x04\xe2\x02\x19\x1a\n\xf8\x01\n\x04\x04\x0e\x02\x03\x12\x04\xe9\x02\x02\
    !\x1a\xe9\x01\x20the\x20number\x20of\x20workers,\x20if\x20the\x20operato\
    rs\x20in\x20the\x20network\x20is\x20to\x20be\x20carried\x20out\n\x20in\
    \x20parallel.\n\x20Note:\x20This\x20is\x20to\x20be\x20deprecated.\x20Usi\
    ng\x20the\x20arg\x20field\x20with\x20\"num_workers\"\x20as\n\x20key.\n\
    \x20Note\x202:\x20The\x20old\x20uses\x20of\x20this\x20were\x20never\x20a\
    ctually\x20cleaned\x20up\n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xe9\x02\
    \x02\n\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xe9\x02\x0b\x10\n\r\n\x05\
    \x04\x0e\x02\x03\x01\x12\x04\xe9\x02\x11\x1c\n\r\n\x05\x04\x0e\x02\x03\
    \x03\x12\x04\xe9\x02\x1f\x20\n\x90\x02\n\x04\x04\x0e\x02\x04\x12\x04\xef\
    \x02\x02*\x1a\x81\x02\x20The\x20device\x20option\x20for\x20the\x20networ\
    k.\x20If\x20a\x20network\x20has\x20a\x20specific\x20device\n\x20option\
    \x20and\x20one\x20of\x20its\x20operators\x20does\x20not\x20have\x20it\
    \x20set,\x20we\x20will\x20copy\x20over\x20the\n\x20device\x20option\x20t\
    o\x20the\x20operator.\x20This\x20allows\x20us\x20to\x20basically\x20avoi\
    d\x20putting\n\x20device\x20options\x20at\x20every\x20operator.\n\n\r\n\
    \x05\x04\x0e\x02\x04\x04\x12\x04\xef\x02\x02\n\n\r\n\x05\x04\x0e\x02\x04\
    \x06\x12\x04\xef\x02\x0b\x17\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\xef\
    \x02\x18%\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xef\x02()\n\x0c\n\x04\
    \x04\x0e\x02\x05\x12\x04\xf1\x02\x02\x1c\n\r\n\x05\x04\x0e\x02\x05\x04\
    \x12\x04\xf1\x02\x02\n\n\r\n\x05\x04\x0e\x02\x05\x06\x12\x04\xf1\x02\x0b\
    \x13\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xf1\x02\x14\x17\n\r\n\x05\x04\
    \x0e\x02\x05\x03\x12\x04\xf1\x02\x1a\x1b\n\x9a\x05\n\x04\x04\x0e\x02\x06\
    \x12\x04\xfe\x02\x02%\x1a\x8b\x05\x20Two\x20optional\x20fields\x20to\x20\
    declare\x20external\x20input\x20and\x20output\x20of\x20a\x20net.\n\x20If\
    \x20these\x20two\x20are\x20set,\x20when\x20a\x20net\x20is\x20created,\
    \x20we\x20will\x20sanity\x20check\x20for\n\x20every\x20op\x20whether\x20\
    its\x20input\x20is\x20declared\x20(either\x20as\x20an\x20external\x20inp\
    ut,\n\x20or\x20as\x20an\x20intermediate\x20blob\x20created\x20by\x20one\
    \x20of\x20the\x20ops),\x20and\x20sanity\x20check\n\x20if\x20all\x20blobs\
    \x20in\x20external_output\x20are\x20produced.\n\n\x20In\x20cases\x20of\
    \x20memory\x20optimization,\x20declaring\x20external_input\x20and\n\x20e\
    xternal_output\x20also\x20ensures\x20that\x20storage\x20of\x20these\x20b\
    lobs\x20are\x20persistent:\n\x20for\x20any\x20blob\x20in\x20external_inp\
    ut\x20and\x20external_output,\x20after\x20a\x20network\x20run\n\x20finis\
    hes,\x20their\x20content\x20are\x20actually\x20the\x20right\x20content.\
    \x20Any\x20intermediate\n\x20blobs'\x20contents\x20may\x20be\x20overwrit\
    ten.\n\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\xfe\x02\x02\n\n\r\n\x05\x04\
    \x0e\x02\x06\x05\x12\x04\xfe\x02\x0b\x11\n\r\n\x05\x04\x0e\x02\x06\x01\
    \x12\x04\xfe\x02\x12\x20\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\xfe\x02#$\
    \n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\xff\x02\x02&\n\r\n\x05\x04\x0e\x02\
    \x07\x04\x12\x04\xff\x02\x02\n\n\r\n\x05\x04\x0e\x02\x07\x05\x12\x04\xff\
    \x02\x0b\x11\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xff\x02\x12!\n\r\n\
    \x05\x04\x0e\x02\x07\x03\x12\x04\xff\x02$%\n>\n\x04\x04\x0e\x02\x08\x12\
    \x04\x82\x03\x02,\x1a0\x20Partitioning\x20info,\x20indexed\x20by\x20part\
    ition\x20names.\n\n\r\n\x05\x04\x0e\x02\x08\x04\x12\x04\x82\x03\x02\n\n\
    \r\n\x05\x04\x0e\x02\x08\x06\x12\x04\x82\x03\x0b\x18\n\r\n\x05\x04\x0e\
    \x02\x08\x01\x12\x04\x82\x03\x19'\n\r\n\x05\x04\x0e\x02\x08\x03\x12\x04\
    \x82\x03*+\n_\n\x02\x04\x0f\x12\x06\x88\x03\0\xc8\x03\x01\x1aQ\x20Execut\
    ionStep\x20is\x20actually\x20a\x20sort-of-hacky\x20way\x20we\x20simulate\
    \x20iteration\x20right\n\x20now.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\x88\
    \x03\x08\x15\n\xb0\x01\n\x04\x04\x0f\x02\0\x12\x04\x8c\x03\x02\x1b\x1a\
    \xa1\x01\x20ExecutionStep\x20should\x20either\x20contain\x20a\x20set\x20\
    of\x20substeps,\x20or\x20a\x20set\x20of\n\x20network\x20names\x20to\x20r\
    un\x20in\x20this\x20execution\x20step.\x20They\x20should\x20NOT\x20both\
    \x20be\x20set\n\x20at\x20the\x20same\x20time.\n\n\r\n\x05\x04\x0f\x02\0\
    \x04\x12\x04\x8c\x03\x02\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x8c\x03\
    \x0b\x11\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x8c\x03\x12\x16\n\r\n\x05\
    \x04\x0f\x02\0\x03\x12\x04\x8c\x03\x19\x1a\n^\n\x04\x04\x0f\x02\x01\x12\
    \x04\x8f\x03\x02%\x1aP\x20An\x20execution\x20step\x20could\x20be\x20recu\
    rsive,\x20in\x20which\x20it\x20involves\x20a\x20set\x20of\n\x20substeps.\
    \n\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\x8f\x03\x02\n\n\r\n\x05\x04\x0f\
    \x02\x01\x06\x12\x04\x8f\x03\x0b\x18\n\r\n\x05\x04\x0f\x02\x01\x01\x12\
    \x04\x8f\x03\x19\x20\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\x8f\x03#$\n\
    \xe5\x03\n\x04\x04\x0f\x02\x02\x12\x04\x97\x03\x02\x1e\x1a\xd6\x03\x20Al\
    ternatively,\x20an\x20execution\x20step\x20could\x20involve\x20one\x20or\
    \x20more\x20networks.\n\x20Note\x20that\x20you\x20cannot\x20have\x20both\
    \x20substeps\x20and\x20networks.\x20Choose\x20one.\n\x20Note\x20that\x20\
    an\x20execution\x20step\x20refers\x20networks\x20by\x20their\x20name.\
    \x20The\x20actual\n\x20network\x20definition\x20of\x20the\x20same\x20nam\
    e\x20should\x20be\x20included\x20in\x20the\x20network\x20field\n\x20of\
    \x20the\x20plan.\x20The\x20reason\x20is\x20that\x20a\x20network\x20objec\
    t\x20might\x20hold\x20internal\x20states\n\x20(think\x20of\x20a\x20data\
    \x20layer),\x20so\x20we\x20want\x20to\x20have\x20the\x20same\x20network\
    \x20object\x20that\n\x20multiple\x20steps\x20could\x20ask\x20to\x20run.\
    \n\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\x97\x03\x02\n\n\r\n\x05\x04\x0f\
    \x02\x02\x05\x12\x04\x97\x03\x0b\x11\n\r\n\x05\x04\x0f\x02\x02\x01\x12\
    \x04\x97\x03\x12\x19\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\x97\x03\x1c\
    \x1d\n\xf0\x01\n\x04\x04\x0f\x02\x03\x12\x04\x9c\x03\x02\x1e\x1a\xe1\x01\
    \x20Number\x20of\x20iterations\x20to\x20run\x20this\x20step.\x20The\x20s\
    ubsteps\x20or\x20the\x20networks\n\x20specified\x20will\x20be\x20run\x20\
    sequentially,\x20and\x20one\x20sequential\x20run\x20is\x20considered\n\
    \x20one\x20iteration.\x20If\x20this\x20is\x20not\x20set,\x20the\x20numbe\
    r\x20of\x20iterations\x20is\x20assumed\x20to\n\x20be\x201.\n\n\r\n\x05\
    \x04\x0f\x02\x03\x04\x12\x04\x9c\x03\x02\n\n\r\n\x05\x04\x0f\x02\x03\x05\
    \x12\x04\x9c\x03\x0b\x10\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\x9c\x03\
    \x11\x19\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\x9c\x03\x1c\x1d\n\xbf\x01\
    \n\x04\x04\x0f\x02\x04\x12\x04\xa1\x03\x029\x1a\xb0\x01\x20Criteria\x20n\
    etwork\x20specifies\x20a\x20single\x20output\x20(TensorCPU<bool>)\x20of\
    \n\x20size\x20(1),\x20is\x20run\x20on\x20every\x20iteration\x20by\x20the\
    \x20executor,\x20and\n\x20execution\x20terminates\x20when\x20the\x20outp\
    ut[0]\x20is\x20`false`.\n\n\r\n\x05\x04\x0f\x02\x04\x04\x12\x04\xa1\x03\
    \x02\n\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\xa1\x03\x0b\x11\n\r\n\x05\
    \x04\x0f\x02\x04\x01\x12\x04\xa1\x03\x12\"\n\r\n\x05\x04\x0f\x02\x04\x03\
    \x12\x04\xa1\x03%&\n\r\n\x05\x04\x0f\x02\x04\x08\x12\x04\xa1\x03'8\n\x0e\
    \n\x06\x04\x0f\x02\x04\x08\x03\x12\x04\xa1\x03(7\n/\n\x04\x04\x0f\x02\
    \x05\x12\x04\xa4\x03\x02!\x1a!\x20DEPRECATED.\x20Use\x20`run_every_ms`.\
    \n\n\r\n\x05\x04\x0f\x02\x05\x04\x12\x04\xa4\x03\x02\n\n\r\n\x05\x04\x0f\
    \x02\x05\x05\x12\x04\xa4\x03\x0b\x11\n\r\n\x05\x04\x0f\x02\x05\x01\x12\
    \x04\xa4\x03\x12\x1c\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xa4\x03\x1f\
    \x20\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\xa5\x03\x02%\n\r\n\x05\x04\x0f\
    \x02\x06\x04\x12\x04\xa5\x03\x02\n\n\r\n\x05\x04\x0f\x02\x06\x05\x12\x04\
    \xa5\x03\x0b\x10\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\xa5\x03\x11\x20\n\
    \r\n\x05\x04\x0f\x02\x06\x03\x12\x04\xa5\x03#$\n\xe6\x01\n\x04\x04\x0f\
    \x02\x07\x12\x04\xaa\x03\x02#\x1a\xd7\x01\x20If\x20provided,\x20execute\
    \x20this\x20step\x20at\x20every\x20time\x20interval\x20(in\x20millisecs)\
    \n\x20while\x20its\x20sibiling\x20execution\x20steps\x20execute\x20in\
    \x20parallel.\x20This\x20step\x20is\n\x20guaranteed\x20to\x20run\x20at\
    \x20least\x20once\x20after\x20all\x20non-interval\x20siblings\x20finishe\
    d.\n\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\xaa\x03\x02\n\n\r\n\x05\x04\
    \x0f\x02\x07\x05\x12\x04\xaa\x03\x0b\x10\n\r\n\x05\x04\x0f\x02\x07\x01\
    \x12\x04\xaa\x03\x11\x1d\n\r\n\x05\x04\x0f\x02\x07\x03\x12\x04\xaa\x03\
    \x20\"\n\x8c\x01\n\x04\x04\x0f\x02\x08\x12\x04\xae\x03\x02(\x1a~\x20If\
    \x20false\x20or\x20not\x20set,\x20execute\x20sub-steps\x20serially.\n\
    \x20If\x20true,\x20execute\x20all\x20substeps\x20concurrently,\x20each\
    \x20one\x20in\x20a\x20separate\x20thread.\n\n\r\n\x05\x04\x0f\x02\x08\
    \x04\x12\x04\xae\x03\x02\n\n\r\n\x05\x04\x0f\x02\x08\x05\x12\x04\xae\x03\
    \x0b\x0f\n\r\n\x05\x04\x0f\x02\x08\x01\x12\x04\xae\x03\x10#\n\r\n\x05\
    \x04\x0f\x02\x08\x03\x12\x04\xae\x03&'\n\xc2\x04\n\x04\x04\x0f\x02\t\x12\
    \x04\xbc\x03\x02'\x1a\xb3\x04\x20Name\x20of\x20a\x20scalar\x20boolean\
    \x20tensor.\n\x20ES\x20checks\x20this\x20blob\x20AFTER\x20every\x20subst\
    eps/subnets.\n\x20If\x20specified,\x20and\x20the\x20value\x20is\x20true,\
    \x20then\x20ES\x20will\x20skip\x20the\x20rest\x20and\x20return\n\x20imme\
    diately.\n\x20This\x20means\x20that\x20the\x20report_net\x20and\x20the\
    \x20first\x20step\x20will\x20always\x20be\x20called.\n\x20Use\x20cases:\
    \n\x201)\x20the\x20first\x20substep\x20stops\x20the\x20rest\x20if\x20dat\
    a\x20condition\x20not\x20met\n\x202)\x20the\x20first\x20substep\x20decid\
    e\x20which\x20of\x20the\x20rest\x20of\x20the\x20steps\x20should\x20be\
    \x20run.\n\x203)\x20external\x20control\n\n\x20**\x20It\x20is\x20the\x20\
    user's\x20responsibility\x20to\x20not\x20to\x20put\x20this\x20blob\x20in\
    \x20race\x20conditions.\n\x20**\x20For\x20example\x20when\x20setting\x20\
    this\x20blob\x20in\x20concurrent\x20substeps\n\n\r\n\x05\x04\x0f\x02\t\
    \x04\x12\x04\xbc\x03\x02\n\n\r\n\x05\x04\x0f\x02\t\x05\x12\x04\xbc\x03\
    \x0b\x11\n\r\n\x05\x04\x0f\x02\t\x01\x12\x04\xbc\x03\x12\"\n\r\n\x05\x04\
    \x0f\x02\t\x03\x12\x04\xbc\x03%&\n\x7f\n\x04\x04\x0f\x02\n\x12\x04\xc0\
    \x03\x02\x1f\x1aq\x20if\x20only_once\x20is\x20true,\x20this\x20step\x20w\
    ill\x20only\x20be\x20executed\x20once.\x20this\x20ONLY\x20takes\n\x20eff\
    ect\x20when\x20using\x20should_stop_blob\n\n\r\n\x05\x04\x0f\x02\n\x04\
    \x12\x04\xc0\x03\x02\n\n\r\n\x05\x04\x0f\x02\n\x05\x12\x04\xc0\x03\x0b\
    \x0f\n\r\n\x05\x04\x0f\x02\n\x01\x12\x04\xc0\x03\x10\x19\n\r\n\x05\x04\
    \x0f\x02\n\x03\x12\x04\xc0\x03\x1c\x1e\n\x8d\x01\n\x04\x04\x0f\x02\x0b\
    \x12\x04\xc4\x03\x02&\x1a\x7f\x20Whether\x20to\x20create\x20a\x20child\
    \x20workspace\x20for\x20this\x20step.\n\x20If\x20yes,\x20the\x20workflow\
    \x20and\x20nets\x20are\x20re-created\x20every\x20time\x20this\x20step\
    \x20is\x20run.\n\n\r\n\x05\x04\x0f\x02\x0b\x04\x12\x04\xc4\x03\x02\n\n\r\
    \n\x05\x04\x0f\x02\x0b\x05\x12\x04\xc4\x03\x0b\x0f\n\r\n\x05\x04\x0f\x02\
    \x0b\x01\x12\x04\xc4\x03\x10\x20\n\r\n\x05\x04\x0f\x02\x0b\x03\x12\x04\
    \xc4\x03#%\nT\n\x04\x04\x0f\x02\x0c\x12\x04\xc7\x03\x02/\x1aF\x20How\x20\
    many\x20copies\x20of\x20the\x20children\x20execution\x20steps\x20to\x20r\
    un\x20concurrently.\n\n\r\n\x05\x04\x0f\x02\x0c\x04\x12\x04\xc7\x03\x02\
    \n\n\r\n\x05\x04\x0f\x02\x0c\x05\x12\x04\xc7\x03\x0b\x10\n\r\n\x05\x04\
    \x0f\x02\x0c\x01\x12\x04\xc7\x03\x11)\n\r\n\x05\x04\x0f\x02\x0c\x03\x12\
    \x04\xc7\x03,.\n\x0c\n\x02\x04\x10\x12\x06\xca\x03\0\xd3\x03\x01\n\x0b\n\
    \x03\x04\x10\x01\x12\x04\xca\x03\x08\x0f\n\x8d\x02\n\x04\x04\x10\x02\0\
    \x12\x04\xcf\x03\x02\x1b\x1a\xfe\x01\x20All\x20the\x20networks\x20that\
    \x20are\x20used\x20in\x20this\x20execution.\x20Note\x20that\x20networks\
    \x20should\n\x20be\x20ordered\x20in\x20the\x20way\x20they\x20are\x20exec\
    uted,\x20i.e.\x20for\x20a\x20layer\x20in\x20a\x20network,\x20all\n\x20it\
    s\x20input\x20blobs\x20should\x20already\x20have\x20been\x20initialized\
    \x20by\x20the\x20layers\x20or\n\x20networks\x20defined\x20before\x20it.\
    \n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xcf\x03\x02\n\n\r\n\x05\x04\x10\
    \x02\0\x05\x12\x04\xcf\x03\x0b\x11\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xcf\x03\x12\x16\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xcf\x03\x19\x1a\nD\
    \n\x04\x04\x10\x02\x01\x12\x04\xd1\x03\x02\x1e\x1a6\x20The\x20networks\
    \x20that\x20are\x20going\x20to\x20be\x20used\x20in\x20this\x20plan.\n\n\
    \r\n\x05\x04\x10\x02\x01\x04\x12\x04\xd1\x03\x02\n\n\r\n\x05\x04\x10\x02\
    \x01\x06\x12\x04\xd1\x03\x0b\x11\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\
    \xd1\x03\x12\x19\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xd1\x03\x1c\x1d\n\
    \x0c\n\x04\x04\x10\x02\x02\x12\x04\xd2\x03\x02,\n\r\n\x05\x04\x10\x02\
    \x02\x04\x12\x04\xd2\x03\x02\n\n\r\n\x05\x04\x10\x02\x02\x06\x12\x04\xd2\
    \x03\x0b\x18\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xd2\x03\x19'\n\r\n\
    \x05\x04\x10\x02\x02\x03\x12\x04\xd2\x03*+\n\xe9\x01\n\x02\x04\x11\x12\
    \x06\xd8\x03\0\xe2\x03\x01\x1a\xda\x01\x20Protobuf\x20format\x20for\x20b\
    lobs\x20that\x20are\x20not\x20Tensors.\x20We\x20use\x20a\x20key\x20to\
    \x20store\x20the\n\x20type\x20of\x20the\x20blob.\x20For\x20example\x20fo\
    r\x20a\x20serialized\x20DBProto,\x20the\x20type\x20should\n\x20be\x20\"D\
    BReader\"\x20and\x20the\x20content\x20should\x20be\x20a\x20serialized\
    \x20DBProto\x20object.\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xd8\x03\x08\x11\
    \n\x0c\n\x04\x04\x11\x02\0\x12\x04\xd9\x03\x02\x1b\n\r\n\x05\x04\x11\x02\
    \0\x04\x12\x04\xd9\x03\x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xd9\x03\
    \x0b\x11\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xd9\x03\x12\x16\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xd9\x03\x19\x1a\n\x0c\n\x04\x04\x11\x02\x01\
    \x12\x04\xda\x03\x02\x1b\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xda\x03\
    \x02\n\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xda\x03\x0b\x11\n\r\n\x05\
    \x04\x11\x02\x01\x01\x12\x04\xda\x03\x12\x16\n\r\n\x05\x04\x11\x02\x01\
    \x03\x12\x04\xda\x03\x19\x1a\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xdb\x03\
    \x02\"\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xdb\x03\x02\n\n\r\n\x05\x04\
    \x11\x02\x02\x06\x12\x04\xdb\x03\x0b\x16\n\r\n\x05\x04\x11\x02\x02\x01\
    \x12\x04\xdb\x03\x17\x1d\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xdb\x03\
    \x20!\n\x0c\n\x04\x04\x11\x02\x03\x12\x04\xdc\x03\x02\x1d\n\r\n\x05\x04\
    \x11\x02\x03\x04\x12\x04\xdc\x03\x02\n\n\r\n\x05\x04\x11\x02\x03\x05\x12\
    \x04\xdc\x03\x0b\x10\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xdc\x03\x11\
    \x18\n\r\n\x05\x04\x11\x02\x03\x03\x12\x04\xdc\x03\x1b\x1c\n\x0c\n\x04\
    \x04\x11\x02\x04\x12\x04\xdd\x03\x02$\n\r\n\x05\x04\x11\x02\x04\x04\x12\
    \x04\xdd\x03\x02\n\n\r\n\x05\x04\x11\x02\x04\x06\x12\x04\xdd\x03\x0b\x17\
    \n\r\n\x05\x04\x11\x02\x04\x01\x12\x04\xdd\x03\x18\x1f\n\r\n\x05\x04\x11\
    \x02\x04\x03\x12\x04\xdd\x03\"#\n\x8d\x01\n\x04\x04\x11\x02\x05\x12\x04\
    \xe0\x03\x02(\x1a\x7f\x20If\x20blob\x20is\x20not\x20Tensor\x20and\x20is\
    \x20divided\x20into\x20chunks,\x20content_num_chunks\n\x20contains\x20nu\
    mber\x20of\x20chunks,\x20into\x20which\x20blob\x20was\x20divided.\n\n\r\
    \n\x05\x04\x11\x02\x05\x04\x12\x04\xe0\x03\x02\n\n\r\n\x05\x04\x11\x02\
    \x05\x05\x12\x04\xe0\x03\x0b\x10\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\
    \xe0\x03\x11#\n\r\n\x05\x04\x11\x02\x05\x03\x12\x04\xe0\x03&'\n\x0c\n\
    \x04\x04\x11\x02\x06\x12\x04\xe1\x03\x02&\n\r\n\x05\x04\x11\x02\x06\x04\
    \x12\x04\xe1\x03\x02\n\n\r\n\x05\x04\x11\x02\x06\x05\x12\x04\xe1\x03\x0b\
    \x10\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xe1\x03\x11!\n\r\n\x05\x04\
    \x11\x02\x06\x03\x12\x04\xe1\x03$%\n6\n\x02\x04\x12\x12\x06\xe5\x03\0\
    \xee\x03\x01\x1a(\x20Protobuf\x20format\x20to\x20serialize\x20DBReader.\
    \n\n\x0b\n\x03\x04\x12\x01\x12\x04\xe5\x03\x08\x15\n<\n\x04\x04\x12\x02\
    \0\x12\x04\xe7\x03\x02\x1b\x1a.\x20The\x20name\x20for\x20the\x20DB\x20ob\
    ject\x20in\x20the\x20workspace.\n\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\
    \xe7\x03\x02\n\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xe7\x03\x0b\x11\n\r\n\
    \x05\x04\x12\x02\0\x01\x12\x04\xe7\x03\x12\x16\n\r\n\x05\x04\x12\x02\0\
    \x03\x12\x04\xe7\x03\x19\x1a\n$\n\x04\x04\x12\x02\x01\x12\x04\xe9\x03\
    \x02\x1d\x1a\x16\x20The\x20source\x20of\x20the\x20DB\n\n\r\n\x05\x04\x12\
    \x02\x01\x04\x12\x04\xe9\x03\x02\n\n\r\n\x05\x04\x12\x02\x01\x05\x12\x04\
    \xe9\x03\x0b\x11\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xe9\x03\x12\x18\n\
    \r\n\x05\x04\x12\x02\x01\x03\x12\x04\xe9\x03\x1b\x1c\n\"\n\x04\x04\x12\
    \x02\x02\x12\x04\xeb\x03\x02\x1e\x1a\x14\x20The\x20type\x20of\x20the\x20\
    DB\n\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xeb\x03\x02\n\n\r\n\x05\x04\
    \x12\x02\x02\x05\x12\x04\xeb\x03\x0b\x11\n\r\n\x05\x04\x12\x02\x02\x01\
    \x12\x04\xeb\x03\x12\x19\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xeb\x03\
    \x1c\x1d\nE\n\x04\x04\x12\x02\x03\x12\x04\xed\x03\x02\x1a\x1a7\x20The\
    \x20current\x20key\x20of\x20the\x20DB\x20if\x20the\x20DB\x20supports\x20\
    seeking.\n\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xed\x03\x02\n\n\r\n\x05\
    \x04\x12\x02\x03\x05\x12\x04\xed\x03\x0b\x11\n\r\n\x05\x04\x12\x02\x03\
    \x01\x12\x04\xed\x03\x12\x15\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xed\
    \x03\x18\x19\n\x0c\n\x02\x04\x13\x12\x06\xf0\x03\0\x89\x04\x01\n\x0b\n\
    \x03\x04\x13\x01\x12\x04\xf0\x03\x08\x20\n\xb2\x01\n\x04\x04\x13\x02\0\
    \x12\x04\xf4\x03\x02&\x1a\xa3\x01\x20This\x20set\x20of\x20options\x20wil\
    l\x20only\x20apply\x20to\x20blobs\x20whose\x20name\x20matches\x20this\n\
    \x20pattern.\x20\x20If\x20the\x20blob_name_pattern\x20is\x20empty\x20the\
    n\x20it\x20will\x20be\x20treated\x20as\n\x20matching\x20all\x20blobs.\n\
    \n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xf4\x03\x02\n\n\r\n\x05\x04\x13\x02\
    \0\x05\x12\x04\xf4\x03\x0b\x11\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xf4\
    \x03\x12!\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xf4\x03$%\n\x8b\x02\n\x04\
    \x04\x13\x02\x01\x12\x04\xfb\x03\x02\x20\x1a\xfc\x01\x20Note:\n\x20-\x20\
    a\x20chunk_size\x20of\x200\x20means\x20\"use\x20the\x20default\x20chunk\
    \x20size\".\x20\x20The\x20default\x20chunk\n\x20\x20\x20size\x20is\x20co\
    ntrolled\x20by\x20the\x20--caffe2_tensor_chunk_size\x20command\x20line\
    \x20flag.\n\x20-\x20a\x20chunk\x20size\x20of\x20-1\x20means\x20to\x20dis\
    able\x20chunking,\x20and\x20serialize\x20the\x20blob\x20in\n\x20\x20\x20\
    a\x20single\x20chunk.\n\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xfb\x03\
    \x02\n\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xfb\x03\x0b\x10\n\r\n\x05\
    \x04\x13\x02\x01\x01\x12\x04\xfb\x03\x11\x1b\n\r\n\x05\x04\x13\x02\x01\
    \x03\x12\x04\xfb\x03\x1e\x1f\n\x0e\n\x04\x04\x13\x04\0\x12\x06\xfd\x03\
    \x02\x85\x04\x03\n\r\n\x05\x04\x13\x04\0\x01\x12\x04\xfd\x03\x07\x12\n\
    \x9a\x01\n\x06\x04\x13\x04\0\x02\0\x12\x04\x80\x04\x04\x16\x1a\x89\x01\
    \x20Use\x20the\x20current\x20default\x20serialization\x20format,\x20as\
    \x20chosen\x20by\x20the\n\x20current\x20version\x20of\x20the\x20code.\
    \x20\x20(At\x20the\x20time\x20of\x20writing\x20this\x20is\x20PROTOBUF)\n\
    \n\x0f\n\x07\x04\x13\x04\0\x02\0\x01\x12\x04\x80\x04\x04\x11\n\x0f\n\x07\
    \x04\x13\x04\0\x02\0\x02\x12\x04\x80\x04\x14\x15\nF\n\x06\x04\x13\x04\0\
    \x02\x01\x12\x04\x82\x04\x04\x17\x1a6\x20Store\x20the\x20data\x20in\x20t\
    he\x20TensorProto's\x20float_data\x20field\n\n\x0f\n\x07\x04\x13\x04\0\
    \x02\x01\x01\x12\x04\x82\x04\x04\x12\n\x0f\n\x07\x04\x13\x04\0\x02\x01\
    \x02\x12\x04\x82\x04\x15\x16\nZ\n\x06\x04\x13\x04\0\x02\x02\x12\x04\x84\
    \x04\x04\x17\x1aJ\x20Serialize\x20float\x20values\x20as\x20bfloat16.\x20\
    \x20Note\x20that\x20this\x20conversion\x20is\x20lossy.\n\n\x0f\n\x07\x04\
    \x13\x04\0\x02\x02\x01\x12\x04\x84\x04\x04\x12\n\x0f\n\x07\x04\x13\x04\0\
    \x02\x02\x02\x12\x04\x84\x04\x15\x16\nM\n\x04\x04\x13\x02\x02\x12\x04\
    \x88\x04\x02(\x1a?\x20Settings\x20for\x20how\x20to\x20serialize\x20tenso\
    rs\x20containing\x20float\x20values\n\n\r\n\x05\x04\x13\x02\x02\x04\x12\
    \x04\x88\x04\x02\n\n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\x88\x04\x0b\x16\
    \n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\x88\x04\x17#\n\r\n\x05\x04\x13\
    \x02\x02\x03\x12\x04\x88\x04&'\n\x0c\n\x02\x04\x14\x12\x06\x8b\x04\0\x91\
    \x04\x01\n\x0b\n\x03\x04\x14\x01\x12\x04\x8b\x04\x08\x1c\n\xe6\x01\n\x04\
    \x04\x14\x02\0\x12\x04\x90\x04\x020\x1a\xd7\x01\x20A\x20set\x20of\x20opt\
    ions\x20to\x20use\x20when\x20serialializing\x20blobs.\n\x20This\x20is\
    \x20a\x20list,\x20sorted\x20from\x20highest\x20to\x20lowest\x20precedenc\
    e.\x20\x20When\n\x20serializing\x20a\x20blob,\x20the\x20first\x20entry\
    \x20whose\x20blob_name_pattern\x20matches\x20the\n\x20blob\x20name\x20wi\
    ll\x20be\x20used.\n\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x90\x04\x02\n\n\
    \r\n\x05\x04\x14\x02\0\x06\x12\x04\x90\x04\x0b#\n\r\n\x05\x04\x14\x02\0\
    \x01\x12\x04\x90\x04$+\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x90\x04./\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
