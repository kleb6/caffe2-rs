// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `pytorch/caffe2/proto/hsm.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct NodeProto {
    // message fields
    pub children: ::protobuf::RepeatedField<NodeProto>,
    pub word_ids: ::std::vec::Vec<i32>,
    offset: ::std::option::Option<i32>,
    name: ::protobuf::SingularField<::std::string::String>,
    pub scores: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeProto {
    fn default() -> &'a NodeProto {
        <NodeProto as ::protobuf::Message>::default_instance()
    }
}

impl NodeProto {
    pub fn new() -> NodeProto {
        ::std::default::Default::default()
    }

    // repeated .caffe2.NodeProto children = 1;


    pub fn get_children(&self) -> &[NodeProto] {
        &self.children
    }
    pub fn clear_children(&mut self) {
        self.children.clear();
    }

    // Param is passed by value, moved
    pub fn set_children(&mut self, v: ::protobuf::RepeatedField<NodeProto>) {
        self.children = v;
    }

    // Mutable pointer to the field.
    pub fn mut_children(&mut self) -> &mut ::protobuf::RepeatedField<NodeProto> {
        &mut self.children
    }

    // Take field
    pub fn take_children(&mut self) -> ::protobuf::RepeatedField<NodeProto> {
        ::std::mem::replace(&mut self.children, ::protobuf::RepeatedField::new())
    }

    // repeated int32 word_ids = 2;


    pub fn get_word_ids(&self) -> &[i32] {
        &self.word_ids
    }
    pub fn clear_word_ids(&mut self) {
        self.word_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_word_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.word_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_word_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.word_ids
    }

    // Take field
    pub fn take_word_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.word_ids, ::std::vec::Vec::new())
    }

    // optional int32 offset = 3;


    pub fn get_offset(&self) -> i32 {
        self.offset.unwrap_or(0)
    }
    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional string name = 4;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated float scores = 5;


    pub fn get_scores(&self) -> &[f32] {
        &self.scores
    }
    pub fn clear_scores(&mut self) {
        self.scores.clear();
    }

    // Param is passed by value, moved
    pub fn set_scores(&mut self, v: ::std::vec::Vec<f32>) {
        self.scores = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scores(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.scores
    }

    // Take field
    pub fn take_scores(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.scores, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for NodeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.children {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.children)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.word_ids)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.offset = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.scores)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.children {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.word_ids {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.offset {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += 5 * self.scores.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.children {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.word_ids {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.offset {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.scores {
            os.write_float(5, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeProto {
        NodeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeProto>>(
                "children",
                |m: &NodeProto| { &m.children },
                |m: &mut NodeProto| { &mut m.children },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "word_ids",
                |m: &NodeProto| { &m.word_ids },
                |m: &mut NodeProto| { &mut m.word_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "offset",
                |m: &NodeProto| { &m.offset },
                |m: &mut NodeProto| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NodeProto| { &m.name },
                |m: &mut NodeProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "scores",
                |m: &NodeProto| { &m.scores },
                |m: &mut NodeProto| { &mut m.scores },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeProto>(
                "NodeProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeProto {
        static instance: ::protobuf::rt::LazyV2<NodeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeProto::new)
    }
}

impl ::protobuf::Clear for NodeProto {
    fn clear(&mut self) {
        self.children.clear();
        self.word_ids.clear();
        self.offset = ::std::option::Option::None;
        self.name.clear();
        self.scores.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TreeProto {
    // message fields
    pub root_node: ::protobuf::SingularPtrField<NodeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TreeProto {
    fn default() -> &'a TreeProto {
        <TreeProto as ::protobuf::Message>::default_instance()
    }
}

impl TreeProto {
    pub fn new() -> TreeProto {
        ::std::default::Default::default()
    }

    // optional .caffe2.NodeProto root_node = 1;


    pub fn get_root_node(&self) -> &NodeProto {
        self.root_node.as_ref().unwrap_or_else(|| <NodeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_root_node(&mut self) {
        self.root_node.clear();
    }

    pub fn has_root_node(&self) -> bool {
        self.root_node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_root_node(&mut self, v: NodeProto) {
        self.root_node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_node(&mut self) -> &mut NodeProto {
        if self.root_node.is_none() {
            self.root_node.set_default();
        }
        self.root_node.as_mut().unwrap()
    }

    // Take field
    pub fn take_root_node(&mut self) -> NodeProto {
        self.root_node.take().unwrap_or_else(|| NodeProto::new())
    }
}

impl ::protobuf::Message for TreeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.root_node {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.root_node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.root_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.root_node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TreeProto {
        TreeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeProto>>(
                "root_node",
                |m: &TreeProto| { &m.root_node },
                |m: &mut TreeProto| { &mut m.root_node },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TreeProto>(
                "TreeProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TreeProto {
        static instance: ::protobuf::rt::LazyV2<TreeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TreeProto::new)
    }
}

impl ::protobuf::Clear for TreeProto {
    fn clear(&mut self) {
        self.root_node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TreeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HierarchyProto {
    // message fields
    size: ::std::option::Option<i32>,
    pub paths: ::protobuf::RepeatedField<PathProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HierarchyProto {
    fn default() -> &'a HierarchyProto {
        <HierarchyProto as ::protobuf::Message>::default_instance()
    }
}

impl HierarchyProto {
    pub fn new() -> HierarchyProto {
        ::std::default::Default::default()
    }

    // optional int32 size = 1;


    pub fn get_size(&self) -> i32 {
        self.size.unwrap_or(0)
    }
    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i32) {
        self.size = ::std::option::Option::Some(v);
    }

    // repeated .caffe2.PathProto paths = 2;


    pub fn get_paths(&self) -> &[PathProto] {
        &self.paths
    }
    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::protobuf::RepeatedField<PathProto>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::protobuf::RepeatedField<PathProto> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::protobuf::RepeatedField<PathProto> {
        ::std::mem::replace(&mut self.paths, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HierarchyProto {
    fn is_initialized(&self) -> bool {
        for v in &self.paths {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.size = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.paths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.paths {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.size {
            os.write_int32(1, v)?;
        }
        for v in &self.paths {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HierarchyProto {
        HierarchyProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "size",
                |m: &HierarchyProto| { &m.size },
                |m: &mut HierarchyProto| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathProto>>(
                "paths",
                |m: &HierarchyProto| { &m.paths },
                |m: &mut HierarchyProto| { &mut m.paths },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HierarchyProto>(
                "HierarchyProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HierarchyProto {
        static instance: ::protobuf::rt::LazyV2<HierarchyProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HierarchyProto::new)
    }
}

impl ::protobuf::Clear for HierarchyProto {
    fn clear(&mut self) {
        self.size = ::std::option::Option::None;
        self.paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HierarchyProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HierarchyProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PathProto {
    // message fields
    word_id: ::std::option::Option<i32>,
    pub path_nodes: ::protobuf::RepeatedField<PathNodeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PathProto {
    fn default() -> &'a PathProto {
        <PathProto as ::protobuf::Message>::default_instance()
    }
}

impl PathProto {
    pub fn new() -> PathProto {
        ::std::default::Default::default()
    }

    // optional int32 word_id = 1;


    pub fn get_word_id(&self) -> i32 {
        self.word_id.unwrap_or(0)
    }
    pub fn clear_word_id(&mut self) {
        self.word_id = ::std::option::Option::None;
    }

    pub fn has_word_id(&self) -> bool {
        self.word_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_word_id(&mut self, v: i32) {
        self.word_id = ::std::option::Option::Some(v);
    }

    // repeated .caffe2.PathNodeProto path_nodes = 2;


    pub fn get_path_nodes(&self) -> &[PathNodeProto] {
        &self.path_nodes
    }
    pub fn clear_path_nodes(&mut self) {
        self.path_nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_path_nodes(&mut self, v: ::protobuf::RepeatedField<PathNodeProto>) {
        self.path_nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_path_nodes(&mut self) -> &mut ::protobuf::RepeatedField<PathNodeProto> {
        &mut self.path_nodes
    }

    // Take field
    pub fn take_path_nodes(&mut self) -> ::protobuf::RepeatedField<PathNodeProto> {
        ::std::mem::replace(&mut self.path_nodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PathProto {
    fn is_initialized(&self) -> bool {
        for v in &self.path_nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.word_id = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.path_nodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.word_id {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.path_nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.word_id {
            os.write_int32(1, v)?;
        }
        for v in &self.path_nodes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PathProto {
        PathProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "word_id",
                |m: &PathProto| { &m.word_id },
                |m: &mut PathProto| { &mut m.word_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PathNodeProto>>(
                "path_nodes",
                |m: &PathProto| { &m.path_nodes },
                |m: &mut PathProto| { &mut m.path_nodes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PathProto>(
                "PathProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PathProto {
        static instance: ::protobuf::rt::LazyV2<PathProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PathProto::new)
    }
}

impl ::protobuf::Clear for PathProto {
    fn clear(&mut self) {
        self.word_id = ::std::option::Option::None;
        self.path_nodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PathProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PathNodeProto {
    // message fields
    index: ::std::option::Option<i32>,
    length: ::std::option::Option<i32>,
    target: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PathNodeProto {
    fn default() -> &'a PathNodeProto {
        <PathNodeProto as ::protobuf::Message>::default_instance()
    }
}

impl PathNodeProto {
    pub fn new() -> PathNodeProto {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index.unwrap_or(0)
    }
    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 length = 2;


    pub fn get_length(&self) -> i32 {
        self.length.unwrap_or(0)
    }
    pub fn clear_length(&mut self) {
        self.length = ::std::option::Option::None;
    }

    pub fn has_length(&self) -> bool {
        self.length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_length(&mut self, v: i32) {
        self.length = ::std::option::Option::Some(v);
    }

    // optional int32 target = 3;


    pub fn get_target(&self) -> i32 {
        self.target.unwrap_or(0)
    }
    pub fn clear_target(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: i32) {
        self.target = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PathNodeProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.length = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.target = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.length {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.target {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.length {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.target {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PathNodeProto {
        PathNodeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &PathNodeProto| { &m.index },
                |m: &mut PathNodeProto| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "length",
                |m: &PathNodeProto| { &m.length },
                |m: &mut PathNodeProto| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "target",
                |m: &PathNodeProto| { &m.target },
                |m: &mut PathNodeProto| { &mut m.target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PathNodeProto>(
                "PathNodeProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PathNodeProto {
        static instance: ::protobuf::rt::LazyV2<PathNodeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PathNodeProto::new)
    }
}

impl ::protobuf::Clear for PathNodeProto {
    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.length = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PathNodeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PathNodeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1epytorch/caffe2/proto/hsm.proto\x12\x06caffe2\"\x99\x01\n\tNodeProt\
    o\x12-\n\x08children\x18\x01\x20\x03(\x0b2\x11.caffe2.NodeProtoR\x08chil\
    dren\x12\x19\n\x08word_ids\x18\x02\x20\x03(\x05R\x07wordIds\x12\x16\n\
    \x06offset\x18\x03\x20\x01(\x05R\x06offset\x12\x12\n\x04name\x18\x04\x20\
    \x01(\tR\x04name\x12\x16\n\x06scores\x18\x05\x20\x03(\x02R\x06scores\";\
    \n\tTreeProto\x12.\n\troot_node\x18\x01\x20\x01(\x0b2\x11.caffe2.NodePro\
    toR\x08rootNode\"M\n\x0eHierarchyProto\x12\x12\n\x04size\x18\x01\x20\x01\
    (\x05R\x04size\x12'\n\x05paths\x18\x02\x20\x03(\x0b2\x11.caffe2.PathProt\
    oR\x05paths\"Z\n\tPathProto\x12\x17\n\x07word_id\x18\x01\x20\x01(\x05R\
    \x06wordId\x124\n\npath_nodes\x18\x02\x20\x03(\x0b2\x15.caffe2.PathNodeP\
    rotoR\tpathNodes\"U\n\rPathNodeProto\x12\x14\n\x05index\x18\x01\x20\x01(\
    \x05R\x05index\x12\x16\n\x06length\x18\x02\x20\x01(\x05R\x06length\x12\
    \x16\n\x06target\x18\x03\x20\x01(\x05R\x06targetJ\x9d\x15\n\x06\x12\x04\
    \0\0=\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\0\
    \x0f\n\x9e\x08\n\x02\x04\0\x12\x04\x16\0\x1e\x01\x1a\\\x20Each\x20node\
    \x20in\x20the\x20hierarchy\x20contains\x20links\x20to\x20either\x20leaf\
    \x20nodes\x20or\x20more\n\x20non-terminal\x20nodes\n2\xc4\x02\x20Hierarc\
    hical\x20Softmax\x20protobuffer\x20convention:\n\x20The\x20HSM\x20operat\
    or\x20requires\x20a\x20hierarchy\x20of\x20vocabulary\x20words\x20in\x20t\
    he\x20form\x20of\x20a\n\x20tree\x20from\x20the\x20user.\x20This\x20tree\
    \x20is\x20expressed\x20using\x20the\x20proto\x20format.\n\x20TreeProto\
    \x20points\x20to\x20the\x20root\x20NodeProto\x20which\x20can\x20recursiv\
    ely\x20contain\x20children\n\x20NodeProtos\x20(internal\x20nodes)\x20or\
    \x20word_ids\x20(leaf\x20nodes).\n2\xec\x04\x20The\x20aforementioned\x20\
    TreeProto\x20is\x20internally\x20translated\x20into\x20a\x20list\x20of\
    \x20word_ids\n\x20tagged\x20with\x20a\x20list\x20of\x20NodeProtos\x20tha\
    t\x20lie\x20in\x20the\x20path\x20from\x20the\x20root\x20to\x20that\n\x20\
    word_id\x20using\x20hsm_util.create_hierarchy(tree_proto).\n\x20Specific\
    ally,\x20HierarchyProto\x20contains\x20a\x20list\x20of\x20PathProtos.\
    \x20Each\x20PathProto\n\x20belongs\x20to\x20a\x20word_id\x20and\x20conta\
    ins\x20a\x20list\x20of\x20PathNodeProtos.\x20Each\n\x20PathNodeProto\x20\
    contains\x20information\x20about\x20the\x20number\x20of\x20children\x20t\
    he\x20node\x20has\n\x20(length),\x20the\x20index\x20of\x20the\x20child\
    \x20node\x20that\x20lies\x20in\x20the\x20path\x20from\x20root\x20to\n\
    \x20word_id\x20(target)\x20and\x20a\x20cumulative\x20sum\x20of\x20childr\
    en\x20nodes\x20(index;\x20this\x20acts\x20as\n\x20the\x20weight\x20param\
    eter\x20matrix\x20offset).\n\n\n\n\x03\x04\0\x01\x12\x03\x16\x08\x11\n3\
    \n\x04\x04\0\x02\0\x12\x03\x18\x02\"\x1a&\x20Links\x20to\x20non-terminal\
    \x20children\x20nodes\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x18\x02\n\n\
    \x0c\n\x05\x04\0\x02\0\x06\x12\x03\x18\x0b\x14\n\x0c\n\x05\x04\0\x02\0\
    \x01\x12\x03\x18\x15\x1d\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x18\x20!\n-\
    \n\x04\x04\0\x02\x01\x12\x03\x1a\x02\x1e\x1a\x20\x20Links\x20to\x20termi\
    nal\x20(leaf)\x20nodes\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x1a\x02\n\
    \n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x1a\x0b\x10\n\x0c\n\x05\x04\0\x02\
    \x01\x01\x12\x03\x1a\x11\x19\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x1a\
    \x1c\x1d\n\x0b\n\x04\x04\0\x02\x02\x12\x03\x1b\x02\x1c\n\x0c\n\x05\x04\0\
    \x02\x02\x04\x12\x03\x1b\x02\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x1b\
    \x0b\x10\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x1b\x11\x17\n\x0c\n\x05\
    \x04\0\x02\x02\x03\x12\x03\x1b\x1a\x1b\n\x0b\n\x04\x04\0\x02\x03\x12\x03\
    \x1c\x02\x1b\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\x1c\x02\n\n\x0c\n\x05\
    \x04\0\x02\x03\x05\x12\x03\x1c\x0b\x11\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03\x1c\x12\x16\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\x1c\x19\x1a\n\x0b\
    \n\x04\x04\0\x02\x04\x12\x03\x1d\x02\x1c\n\x0c\n\x05\x04\0\x02\x04\x04\
    \x12\x03\x1d\x02\n\n\x0c\n\x05\x04\0\x02\x04\x05\x12\x03\x1d\x0b\x10\n\
    \x0c\n\x05\x04\0\x02\x04\x01\x12\x03\x1d\x11\x17\n\x0c\n\x05\x04\0\x02\
    \x04\x03\x12\x03\x1d\x1a\x1b\nx\n\x02\x04\x01\x12\x04\"\0$\x01\x1al\x20P\
    rotobuf\x20format\x20to\x20accept\x20hierarchy\x20for\x20hierarchical\
    \x20softmax\x20operator.\n\x20TreeProto\x20points\x20to\x20the\x20root\
    \x20node.\n\n\n\n\x03\x04\x01\x01\x12\x03\"\x08\x11\n\x0b\n\x04\x04\x01\
    \x02\0\x12\x03#\x02#\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03#\x02\n\n\x0c\
    \n\x05\x04\x01\x02\0\x06\x12\x03#\x0b\x14\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03#\x15\x1e\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03#!\"\nx\n\x02\x04\
    \x02\x12\x04(\0+\x01\x1al\x20Internal\x20Protobuf\x20format\x20which\x20\
    represents\x20the\x20path\x20in\x20the\x20tree\x20hierarchy\x20for\n\x20\
    each\x20word\x20in\x20the\x20vocabulary.\n\n\n\n\x03\x04\x02\x01\x12\x03\
    (\x08\x16\n\x0b\n\x04\x04\x02\x02\0\x12\x03)\x02\x1a\n\x0c\n\x05\x04\x02\
    \x02\0\x04\x12\x03)\x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03)\x0b\x10\
    \n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03)\x11\x15\n\x0c\n\x05\x04\x02\x02\
    \0\x03\x12\x03)\x18\x19\n\x0b\n\x04\x04\x02\x02\x01\x12\x03*\x02\x1f\n\
    \x0c\n\x05\x04\x02\x02\x01\x04\x12\x03*\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x01\x06\x12\x03*\x0b\x14\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03*\x15\
    \x1a\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03*\x1d\x1e\n\x97\x01\n\x02\
    \x04\x03\x12\x04/\02\x01\x1a\x8a\x01\x20Each\x20PathProto\x20belongs\x20\
    to\x20a\x20word\x20and\x20is\x20an\x20array\x20of\x20nodes\x20in\x20the\
    \n\x20path\x20from\x20the\x20root\x20to\x20the\x20leaf\x20(which\x20is\
    \x20the\x20word\x20itself)\x20in\x20the\x20tree.\n\n\n\n\x03\x04\x03\x01\
    \x12\x03/\x08\x11\n\x0b\n\x04\x04\x03\x02\0\x12\x030\x02\x1d\n\x0c\n\x05\
    \x04\x03\x02\0\x04\x12\x030\x02\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x030\
    \x0b\x10\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x030\x11\x18\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x030\x1b\x1c\n\x0b\n\x04\x04\x03\x02\x01\x12\x031\x02\
    (\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\x031\x02\n\n\x0c\n\x05\x04\x03\x02\
    \x01\x06\x12\x031\x0b\x18\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x031\x19#\
    \n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x031&'\nd\n\x02\x04\x04\x12\x046\0=\
    \x01\x1aX\x20Represents\x20a\x20node\x20in\x20the\x20path\x20from\x20the\
    \x20root\x20node\x20all\x20the\x20way\x20down\x20to\x20the\n\x20word\x20\
    (leaf).\n\n\n\n\x03\x04\x04\x01\x12\x036\x08\x15\n4\n\x04\x04\x04\x02\0\
    \x12\x038\x02\x1b\x1a'\x20Parameter\x20matrix\x20offset\x20for\x20this\
    \x20node\n\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x038\x02\n\n\x0c\n\x05\x04\
    \x04\x02\0\x05\x12\x038\x0b\x10\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x038\
    \x11\x16\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x038\x19\x1a\n!\n\x04\x04\x04\
    \x02\x01\x12\x03:\x02\x1c\x1a\x14\x20Number\x20of\x20children\n\n\x0c\n\
    \x05\x04\x04\x02\x01\x04\x12\x03:\x02\n\n\x0c\n\x05\x04\x04\x02\x01\x05\
    \x12\x03:\x0b\x10\n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03:\x11\x17\n\x0c\
    \n\x05\x04\x04\x02\x01\x03\x12\x03:\x1a\x1b\n1\n\x04\x04\x04\x02\x02\x12\
    \x03<\x02\x1c\x1a$\x20Index\x20of\x20the\x20next\x20node\x20in\x20the\
    \x20path\n\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03<\x02\n\n\x0c\n\x05\
    \x04\x04\x02\x02\x05\x12\x03<\x0b\x10\n\x0c\n\x05\x04\x04\x02\x02\x01\
    \x12\x03<\x11\x17\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03<\x1a\x1b\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
